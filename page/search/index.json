[{"content":"Spring5新功能 整个 Spring5 框架的代码基于 Java8，运行时兼容 JDK9\nSpring 5.0 框架自带了通用的日志封装 Spring5 已经移除 Log4jConfigListener，官方建议使用 Log4j2\nSpring5 框架整合 Log4j2(漏洞)\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!--日志级别以及优先级排序: OFF \u0026gt; FATAL \u0026gt; ERROR \u0026gt; WARN \u0026gt; INFO \u0026gt; DEBUG \u0026gt; TRACE \u0026gt; ALL --\u0026gt; \u0026lt;!--Configuration 后面的 status 用于设置 log4j2 自身内部的信息输出，可以不设置，当设置成 trace 时，可以看到 log4j2 内部各种详细输出--\u0026gt; \u0026lt;configuration status=\u0026#34;INFO\u0026#34;\u0026gt; \u0026lt;!--先定义所有的 appender--\u0026gt; \u0026lt;appenders\u0026gt; \u0026lt;!--输出日志信息到控制台--\u0026gt; \u0026lt;console name=\u0026#34;Console\u0026#34; target=\u0026#34;SYSTEM_OUT\u0026#34;\u0026gt; \u0026lt;!--控制日志输出的格式--\u0026gt; \u0026lt;PatternLayout pattern=\u0026#34;%d{yyyy-MM-dd HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n\u0026#34;/\u0026gt; \u0026lt;/console\u0026gt; \u0026lt;/appenders\u0026gt; \u0026lt;!--然后定义 logger，只有定义 logger 并引入的 appender，appender 才会生效!--\u0026gt; \u0026lt;!--root：用于指定项目的根日志，如果没有单独指定 Logger，则会使用 root 作为默认的日志输出--\u0026gt; \u0026lt;loggers\u0026gt; \u0026lt;root level=\u0026#34;info\u0026#34;\u0026gt; \u0026lt;appender-ref ref=\u0026#34;Console\u0026#34;/\u0026gt; \u0026lt;/root\u0026gt; \u0026lt;/loggers\u0026gt; \u0026lt;/configuration\u0026gt; private static final Logger log = LoggerFactory.getLogger(UserLog.class); public static void main(String[] args) { log.info(\u0026#34;hello log4j2\u0026#34;); log.warn(\u0026#34;hello log4j\u0026#34;); } Spring5 框架核心容器支持@Nullable 注解 @Nullable 注解可以使用在方法、属性、参数上面，\n在方法上注解,表示方法返回可以为空，\n在属性上注解,表示属性值可以为空，\n在参数值旁边注解,参数值可以为空\nSpring5 核心容器支持函数式风格 GenericApplicationContext @Test public void getGenericApplicationContext(){ GenericApplicationContext context = new GenericApplicationContext(); 调用 context 的方法对象注册 context.refresh(); // context.registerBean(User.class, User::new);  // User user = (User) context.getBean(\u0026#34;spring5.test.User\u0026#34;);  context.registerBean(\u0026#34;user1\u0026#34;, User.class, User::new); User user = (User) context.getBean(\u0026#34;user1\u0026#34;); System.out.println(user); } JUnit5单元测试框架 //JUnit4 @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(\u0026#34;classpath:bean1.xml\u0026#34;) public class JTest4 { @Autowired private UserService userService; @Test public void test1(){ userService.accountMoney(); } } //JUint5 //@ExtendWith(SpringExtension.class) //@Configuration(\u0026#34;classpath:bean1.xml\u0026#34;) @SpringJUnitConfig(locations = \u0026#34;classpath:bean1.xml\u0026#34;) public class JTest5 { @Autowired private UserService userService; @Test public void test1(){ userService.accountMoney(); } } Spring5 框架新功能——Webflux（类似于springMVC） Webflux是 Spring5 添加新的模块，用于 web 开发的，功能和 SpringMVC 类似的，Webflux 使用 当前一种比较流行的响应式编程出现的框架。\n使用传统 web 框架，比如 SpringMVC，这些基于 Servlet 容器，Webflux 是一种异步非阻塞的框架，异步非阻塞的框架在 Servlet3.1 以后才支持，核心是基于 Reactor 的相关 API 实现的。\n 解释什么是异步非阻塞 ：\n异步和同步 （针对调用者）\n同步： 调用者发送请求，如果等着对方回应之后才去做其他事情就是同步\n异步： 调用者发送请求，如果发送请求之后不等着对方回应就去做其他事情就是异步 √\n非阻塞和阻塞 （针对被调用者）\n阻塞： 被调用者受到请求之后，做完请求任务之后才给出反馈就是阻塞\n非阻塞： 被调用者受到请求之后，受到请求之后马上给出反馈然后再去做事情就是非阻塞 √\n Webflux特点\n 非阻塞式：在有限资源下，提高系统吞吐量和伸缩性，以 Reactor 为基础实现响应式编程 函数式编程：Spring5 框架基于 java8，Webflux 使用 Java8 函数式编程方式实现路由请求  SpringMVC和Webflux之间区别\n相同：两个框架都可以使用注解方式，都运行在 Tomcat 等容器中\n不同：SpringMVC 采用命令式编程，Webflux 采用异步响应式编程\n响应式编程（Java 实现）  概念：什么是响应式编程 响应式编程是一种面向数据流和变化传播的编程范式。这意味着可以在编程语言中很方便 地表达静态或动态的数据流，而相关的计算模型会自动将变化的值通过数据流进行传播。\n例子：电子表格程序就是响应式编程的一个例子。单元格可以包含字面值或类似\u0026quot;=B1+C1\u0026quot;的公 式，而包含公式的单元格的值会依据其他单元格的值的变化而变化。\n Java8 及其之前版本是提供的观察者模式两个类 Observer 和 Observable实现\npublic class ObserverDemo extends Observable { public static void main(String[] args) { ObserverDemo observer = new ObserverDemo(); observer.addObserver(new Observer() { @Override public void update(Observable o, Object arg) { System.out.println(\u0026#34;发生变化\u0026#34;); } }); observer.addObserver(new Observer() { @Override public void update(Observable o, Object arg) { System.out.println(\u0026#34;准备变化\u0026#34;); } }); observer.setChanged(); //数据变化  observer.notifyObservers(); //通知  } } 响应式编程（Reactor 实现） 响应式编程操作中，Reactor 是满足 Reactive 规范框架\nReactor 有两个核心类，Mono 和 Flux，这两个类实现接口 Publisher，提供丰富操作符。Flux 对象实现发布者，返回 N 个元素；Mono 实现发布者，返回 0 或者 1 个元素\nFlux 和 Mono 都是数据流的发布者，使用 Flux 和 Mono 都可以发出三种数据信号： 元素值，错误信号，完成信号，错误信号和完成信号都代表终止信号，终止信号用于告诉 订阅者数据流结束了，错误信号终止数据流同时把错误信息传递给订阅者\n\u0026lt;!--第一步 引入依赖--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.projectreactor\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;reactor-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.1.5.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; //第二步 编程代码 public static void main(String[] args) { //just 方法直接声明  Flux.just(1,2,3,4); Mono.just(1); //其他的方法  Integer[] array = {1,2,3,4}; Flux.fromArray(array); List\u0026lt;Integer\u0026gt; list = Arrays.asList(array); Flux.fromIterable(list); Stream\u0026lt;Integer\u0026gt; stream = list.stream(); Flux.fromStream(stream); } 三种信号特点\n① 错误信号和完成信号都是终止信号，不能共存的\n② 如果没有发送任何元素值，而是直接发送错误或者完成信号，表示是空数据流\n③ 如果没有错误信号，没有完成信号，表示是无限数据流\n调用 just 或者其他方法只是声明数据流，数据流并没有发出，只有进行订阅之后才会触发数据流，不订阅什么都不会发生的！！\n*//just方法声明后,进行订阅*  Flux.just(1,2,3,4).subscribe(System.out::print); Mono.just(1).subscribe(System.out::print); 操作符\n对数据流进行一道道操作，成为操作符，比如工厂流水线\nmap 元素映射为新元素\nflatMap 元素映射为流；把每个元素转换流，把转换之后多个流合并大的流\nSpringWebflux 执行流程和核心 API   SpringWebflux 基于 Reactor，默认使用容器是 Netty，Netty 是高性能的 NIO 框架，异步非阻塞的框架\n  SpringWebflux 核心控制器 DispatchHandler，实现接口 WebHandler 接口\n  SpringWebflux 里面 DispatcherHandler负责请求的处理\nHandlerMapping请求查询到处理的方法\nHandlerAdapter真正负责请求处理\nHandlerResultHandler响应结果处理\n  SpringWebflux 实现函数式编程，\n两个接口：RouterFunction（路由处理） 和 HandlerFunction（处理函数）\n  SpringWebflux（基于注解编程模型） SpringWebflux 实现方式有两种：注解编程模型和函数式编程模型\n使用注解编程模型方式，和之前 SpringMVC 使用相似的，只需要把相关依赖配置到项目中， SpringBoot 自动配置相关运行容器，默认情况下使用 Netty 服务器\nSpringMVC 方式实现，同步阻塞的方式，基于 SpringMVC+Servlet+Tomcat\nSpringWebflux 方式实现，异步非阻塞 方式，基于 SpringWebflux+Reactor+Netty\n//用户操作接口 public interface UserService { //根据id查询用户  Mono\u0026lt;User\u0026gt; getUserById(int id);//Mono返回单个或零个元素  //查询所有用户  Flux\u0026lt;User\u0026gt; getAllUser();//Flux返回多个元素  //添加用户  Mono\u0026lt;Void\u0026gt; saveUserInfo(Mono\u0026lt;User\u0026gt; user); } //接口实现类 //创建map集合存储数据 @Repository public class UserServiceImpl implements UserService { private final Map\u0026lt;Integer,User\u0026gt; users = new HashMap\u0026lt;\u0026gt;(); public UserServiceImpl() { this.users.put(1,new User(\u0026#34;lucy\u0026#34;,\u0026#34;nan\u0026#34;,20)); this.users.put(2,new User(\u0026#34;mary\u0026#34;,\u0026#34;nv\u0026#34;,30)); this.users.put(3,new User(\u0026#34;jack\u0026#34;,\u0026#34;nv\u0026#34;,50)); } //根据id查询  @Override public Mono\u0026lt;User\u0026gt; getUserById(int id) { return Mono.justOrEmpty(this.users.get(id)); } //查询多个用户  @Override public Flux\u0026lt;User\u0026gt; getAllUser() { return Flux.fromIterable(this.users.values()); } //添加用户  @Override public Mono\u0026lt;Void\u0026gt; saveUserInfo(Mono\u0026lt;User\u0026gt; userMono) { return userMono.doOnNext(person -\u0026gt; { //向map集合里面放值  int id = users.size()+1; users.put(id,person); }).thenEmpty(Mono.empty()); } } @RestController public class UserController { //注入 service  @Autowired private UserService userService; //id 查询  @GetMapping(\u0026#34;/user/{id}\u0026#34;) public Mono\u0026lt;User\u0026gt; geetUserId(@PathVariable int id) { return userService.getUserById(id); } //查询所有  @GetMapping(\u0026#34;/user\u0026#34;) public Flux\u0026lt;User\u0026gt; getUsers() { return userService.getAllUser(); } //添加  @PostMapping(\u0026#34;/saveuser\u0026#34;) public Mono\u0026lt;Void\u0026gt; saveUser(@RequestBody User user) { Mono\u0026lt;User\u0026gt; userMono = Mono.just(user); return userService.saveUserInfo(userMono); } } SpringWebflux（基于函数式编程模型）  （1）在使用函数式编程模型操作时候，需要自己初始化服务器\n（2）基于函数式编程模型时候，有两个核心接口：RouterFunction（实现路由功能，请求转发 给对应的 handler）和 HandlerFunction（处理请求生成响应的函数）。核心任务定义两个函数 式接口的实现并且启动需要的服务器。\n（ 3 ） SpringWebflux 请 求 和 响 应 不 再 是 ServletRequest 和 ServletResponse ，而是 ServerRequest 和 ServerResponse\n public class UserHandler { private final UserService userService; public UserHandler(UserService userService) { this.userService = userService; } //根据 id 查询  public Mono\u0026lt;ServerResponse\u0026gt; getUserById(ServerRequest request) { //获取 id 值  int userId = Integer.valueOf(request.pathVariable(\u0026#34;id\u0026#34;)); //空值处理  Mono\u0026lt;ServerResponse\u0026gt; notFound = ServerResponse.notFound().build(); //调用 service 方法得到数据  Mono\u0026lt;User\u0026gt; userMono = this.userService.getUserById(userId); //把 userMono 进行转换返回  //使用 Reactor 操作符 flatMap  return userMono.flatMap(person -\u0026gt; ServerResponse.ok().contentType(MediaType.APPLICATION_JSON).body(fromObject(person))) .switchIfEmpty(notFound); } //查询所有  public Mono\u0026lt;ServerResponse\u0026gt; getAllUsers() { //调用 service 得到结果  Flux\u0026lt;User\u0026gt; users = this.userService.getAllUser(); return ServerResponse.ok().contentType(MediaType.APPLICATION_JSON) .body(users,User.class); } //添加  public Mono\u0026lt;ServerResponse\u0026gt; saveUser(ServerRequest request) { //得到 user 对象  Mono\u0026lt;User\u0026gt; userMono = request.bodyToMono(User.class); return ServerResponse.ok().build(this.userService.saveUserInfo(userMono)); } } //1 创建 Router 路由 public RouterFunction\u0026lt;ServerResponse\u0026gt; routingFunction() { //创建 hanler 对象  UserService userService = new UserServiceImpl(); UserHandler handler = new UserHandler(userService); //设置路由  return RouterFunctions.route( GET(\u0026#34;/users/{id}\u0026#34;).and(accept(APPLICATION_JSON)),handler::getUserById) .andRoute(GET(\u0026#34;/users\u0026#34;).and(accept(APPLICATION_JSON)),handler::getAllUsers); } //2 创建服务器完成适配 public void createReactorServer() { //路由和 handler 适配  RouterFunction\u0026lt;ServerResponse\u0026gt; route = routingFunction(); HttpHandler httpHandler = toHttpHandler(route); ReactorHttpHandlerAdapter adapter = new ReactorHttpHandlerAdapter(httpHandler); //创建服务器  HttpServer httpServer = HttpServer.create(); httpServer.handle(adapter).bindNow();//立即生效 } //最终调用 public static void main(String[] args) throws Exception{ Server server = new Server(); server.createReactorServer(); System.out.println(\u0026#34;enter to exit\u0026#34;); System.in.read(); } //使用 WebClient 调用 public class Client { public static void main(String[] args) { //调用服务器地址  WebClient webClient = WebClient.create(\u0026#34;http://127.0.0.1:5794\u0026#34;); //根据 id 查询  String id = \u0026#34;1\u0026#34;; User userresult = webClient.get().uri(\u0026#34;/users/{id}\u0026#34;, id) .accept(MediaType.APPLICATION_JSON).retrieve().bodyToMono(User.class).block(); System.out.println(userresult.getName()); //查询所有  Flux\u0026lt;User\u0026gt; results = webClient.get().uri(\u0026#34;/users\u0026#34;) .accept(MediaType.APPLICATION_JSON).retrieve().bodyToFlux(User.class); results.map(stu -\u0026gt; stu.getName()) .buffer().doOnNext(System.out::println).blockFirst(); } } ","date":"2022-01-21T15:31:42+08:00","permalink":"https://damaicao.github.io/post/spring5%E6%96%B0%E5%8A%9F%E8%83%BD/","title":"Spring5新功能"},{"content":"事务操作 事务概念 什么是事务 事务是数据库操作最基本单元，逻辑上一组操作，要么都成功，如果有一个失败所有操 作都失败\n事务四个特性 - ACID   原子性：\n事务包含要执行的所有操作要么全部成功，要么全部失败，进行回滚（回滚就是将所有操作还原）。因此事务的操作若成功了就一定对数据库做了改变，若操作失败则不能对数据库有任何影响。\n  一致性：\n指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。\n拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。\n  隔离性：\n隔离性是为了保证每一个用户在开启并使用事务时，不被其他事务操作所干扰，保持独立的工作不受外界干扰，主要就是防止多个用户对数据库同一张表的访问操作。例如：对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行.\n  持久性：\n比如一个事务一旦提交以后，那么对数据库表的操作改变就是永久的（比如删除了表中一条记录就永久删除了），即便是数据库系统遇到故障异常情况事务操作仍然会产生改变。\n  模拟事务操作环境 try { //第一步 开启事务  //第二步 进行业务操作  userDao.reduceMoney();//lucy 少 100  int x=10/0; userDao.addMoney(); //mary 多 100  //第三步 没有发生异常，提交事务 } catch (Exception e){ //第四步 出现异常，事务回滚  } Spring 事务管理介绍   事务添加到 JavaEE 三层结构里面 Service 层（业务逻辑层）\n  在 Spring 进行事务管理操作 ；两种方式：编程式事务管理、声明式事务管理（推荐使用）\n  声明式事务管理\n 基于注解方式（推荐使用） 基于 xml 配置文件方式    在 Spring 进行声明式事务管理，底层使用 AOP 原理\n  Spring 事务管理 API ：提供一个接口，代表事务管理器，这个接口针对不同的框架提供不同的实现类\n  注解声明式事务管理 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34; xmlns:tx=\u0026#34;http://www.springframework.org/schema/tx\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\u0026#34;\u0026gt; \u0026lt;bean id=\u0026#34;TransactionManager\u0026#34; class=\u0026#34;org.springframework.jdbc.datasource.DataSourceTransactionManager\u0026#34;\u0026gt; \u0026lt;!--注入数据源--\u0026gt; \u0026lt;property name=\u0026#34;dataSource\u0026#34; ref=\u0026#34;dataSource\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!--开启事务注解--\u0026gt; \u0026lt;tx:annotation-driven transaction-manager=\u0026#34;TransactionManager\u0026#34;/\u0026gt; \u0026lt;!--3、在 service 类上面（或者 service 类里面方法上面）添加事务注解--\u0026gt; \u0026lt;!-- （1）@Transactional，这个注解添加到类上面，也可以添加方法上面 （2）如果把这个注解添加类上面，这个类里面所有的方法都添加事务 （3）如果把这个注解添加方法上面，为这个方法添加事务——@Transactional --\u0026gt; \u0026lt;/beans\u0026gt; @Service @Transactional public class UserService { @Autowired private UserDao userDao; // @Transactional  public void accountMoney(){ userDao.reduceMoney();//lucy 少 100  int x=10/0; userDao.addMoney(); //mary 多 100  } } 声明式事务管理参数配置 propagation (事务传播行为) @Transactional(propagation = Propagation.REQUIRED) 多事务方法直接进行调用，这个过程中事务 是如何进行管理的\n\rimg\r\nioslation（事务隔离级别） 事务有特性成为隔离性，多事务操作之间不会产生影响。不考虑隔离性产生很多问题\n有三个读问题：\n 脏读： 一个未提交事务读取到另一个未提交事务的数据\n不可重复读： 一个未提交事务读取到另一提交事务修改数据\n虚读： 一个未提交事务读取到另一提交事务添加数据\n \rimg\r\n解决：通过设置事务隔离级别，解决读问题\n@Transactional(propagation = Propagation.REQUIRED,isolation = Isolation.REPEATABLE_READ) timeout (超时) @Transactional(timeout = -1) 事务需要在一定时间内进行提交，如果不提交进行回滚\n默认值是 -1（不超时） ，设置时间以秒单位进行计算\nreadOnly：是否只读 读：查询操作，写：添加修改删除操作\nreadOnly 默认值 false，表示可以查询，可以添加修改删除操作\nreadOnly 值是 true，设置成 true 之后，只能查询\nrollbackFor：回滚 设置出现哪些异常进行事务回滚\nnoRollbackFor：不回滚 设置出现哪些异常不进行事务回滚\nXML 声明式事务管理 在 spring 配置文件中进行配置 ：\n\u0026lt;!--创建事务管理器--\u0026gt; \u0026lt;bean id=\u0026#34;TransactionManager\u0026#34; class=\u0026#34;org.springframework.jdbc.datasource.DataSourceTransactionManager\u0026#34;\u0026gt; \u0026lt;!--注入数据源--\u0026gt; \u0026lt;property name=\u0026#34;dataSource\u0026#34; ref=\u0026#34;dataSource\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!--配置通知--\u0026gt; \u0026lt;tx:advice id=\u0026#34;txadvice\u0026#34;\u0026gt; \u0026lt;!--配置事务参数--\u0026gt; \u0026lt;tx:attributes\u0026gt; \u0026lt;!--指定哪种规则的方法上面添加事务--\u0026gt; \u0026lt;tx:method name=\u0026#34;accountMoney\u0026#34; propagation=\u0026#34;REQUIRED\u0026#34;/\u0026gt; \u0026lt;/tx:attributes\u0026gt; \u0026lt;/tx:advice\u0026gt; \u0026lt;!--配置切入点和切面--\u0026gt; \u0026lt;aop:config\u0026gt; \u0026lt;!--配置切入点--\u0026gt; \u0026lt;aop:pointcut id=\u0026#34;pt\u0026#34; expression=\u0026#34;execution(* spring5.service.UserService.*(..))\u0026#34;/\u0026gt; \u0026lt;!--配置切面--\u0026gt; \u0026lt;aop:advisor advice-ref=\u0026#34;txadvice\u0026#34; pointcut-ref=\u0026#34;pt\u0026#34;/\u0026gt; \u0026lt;/aop:config\u0026gt; 完全注解声明式事务管理 ","date":"2022-01-20T20:51:47+08:00","permalink":"https://damaicao.github.io/post/spring5%E4%BA%8B%E5%8A%A1%E6%93%8D%E4%BD%9C/","title":"Spring事务操作"},{"content":"Spring JdbcTemplate详解 - 知乎 (zhihu.com)\nJdbcTemplate Spring 框架对 JDBC 进行封装，使用 JdbcTemplate 方便实现对数据库操作\n在 spring 配置文件配置数据库连接池 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\u0026#34;\u0026gt; \u0026lt;context:component-scan base-package=\u0026#34;spring5\u0026#34;\u0026gt;\u0026lt;/context:component-scan\u0026gt; \u0026lt;context:property-placeholder location=\u0026#34;classpath:jdbc.properties\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;dataSource\u0026#34; class=\u0026#34;com.alibaba.druid.pool.DruidDataSource\u0026#34; destroy-method=\u0026#34;close\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;driverClassName\u0026#34; value=\u0026#34;${prop.driverClass}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;${prop.url}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;${prop.userName}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;${prop.password}\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;jdbcTemplate\u0026#34; class=\u0026#34;org.springframework.jdbc.core.JdbcTemplate\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;dataSource\u0026#34; ref=\u0026#34;dataSource\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; prop.driverClass=com.mysql.cj.jdbc.Driver prop.url=jdbc:mysql://localhost:3306/user_db?serverTimezone=UTC\u0026amp;characterEncoding=UTF-8 prop.userName=root prop.password=root 创建 service 类，创建 dao 类，在 dao 注入 jdbcTemplate 对象 //service @Service public class BookService { @Autowired private BookDao bookDao; } //dao实现类 @Repository public class BookDaoImpl implements BookDao { @Autowired private JdbcTemplate jdbcTemplate; } JdbcTemplate 操作数据库 添加 //实现类 @Override public void add(Book book) { String sql = \u0026#34;insert into t_book values(?,?,?)\u0026#34;; Object[] args = {book.getUserId(), book.getUsername(),book.getUsertus()}; int update = jdbcTemplate.update(sql,args); System.out.println(update); } 修改和删除 //修改 @Override public void updateBook(Book book) { String sql = \u0026#34;update t_book set username=?,ustatus=? where user_id=?\u0026#34;; Object[] args = {book.getUsername(), book.getUsertus(),book.getUserId()}; int update = jdbcTemplate.update(sql, args); System.out.println(update); } //删除 @Override public void delete(String id) { String sql = \u0026#34;delete from t_book where user_id=?\u0026#34;; int update = jdbcTemplate.update(sql, id); System.out.println(update); } 查询返回某个值 public int selectCount() { String sql = \u0026#34;select count(*) from t_book\u0026#34;; //queryForObject方法中：第一个参数代表--sql语句；第二个参数代表--返回类型class  Integer count = jdbcTemplate.queryForObject(sql, Integer.class); return count; } 查询返回对象 @Override public Book findBookInfo(String id) { String sql = \u0026#34;select * from t_book where user_id=?\u0026#34;; /* queryForObject方法中： 第一个参数：sql语句 第二个参数：RowMapper 是接口，针对返回不同类型数据，使用这个接口里面 实现类 完成数据封装 第三个参数：sql 语句值 */ Book book = jdbcTemplate.queryForObject(sql, new BeanPropertyRowMapper\u0026lt;Book\u0026gt;(Book.class), id); return book; } 查询返回集合 //所用场景：查询图书列表分页、、 //查询返回集合 @Override public List\u0026lt;Book\u0026gt; findAllBook() { String sql = \u0026#34;select * from t_book\u0026#34;; //调用方法  List\u0026lt;Book\u0026gt; bookList = jdbcTemplate.query(sql, new BeanPropertyRowMapper\u0026lt;Book\u0026gt;(Book.class)); return bookList; } 批量添加操作 //批量添加 @Override public void batchAddBook(List\u0026lt;Object[]\u0026gt; batchArgs) { String sql = \u0026#34;insert into t_book values(?,?,?)\u0026#34;; //batchUpdate方法 第一个参数：sql语句  // 第二个参数：List集合，添加多条记录数据  int[] ints = jdbcTemplate.batchUpdate(sql, batchArgs); System.out.println(Arrays.toString(ints)); } 批量修改操作 //批量修改(同批量添加一样，调用同一个方法) @Override public void batchUpdateBook(List\u0026lt;Object[]\u0026gt; batchArgs) { String sql = \u0026#34;update t_book set username=?,ustatus=? where user_id=?\u0026#34;; int[] ints = jdbcTemplate.batchUpdate(sql, batchArgs); System.out.println(Arrays.toString(ints)); } ","date":"2022-01-20T17:03:51+08:00","permalink":"https://damaicao.github.io/post/jdbctemplate/","title":"JdbcTemplate"},{"content":"本文参考了 : Spring AOP——Spring 中面向切面编程 - SharpCJ - 博客园 (cnblogs.com)\nAOP基本概念  面向切面编程（方面），利用 AOP 可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。 通俗描述：不通过修改源代码方式，在主干功能里面添加新功能 AOP 要达到的效果是，保证开发者不修改源代码的前提下，去为系统中的业务组件添加某种通用功能。  AOP底层原理 AOP 底层使用动态代理 ，动态代理有两种情况：\n  有接口情况，使用 JDK 动态代理 ；创建接口实现类代理对象，增强类的方法\n静态 AOP 实现， AOP 框架在编译阶段对程序源代码进行修改，生成了静态的 AOP 代理类（生成的 *.class 文件已经被改掉了，需要使用特定的编译器），比如 AspectJ。\n  没有接口情况，使用 CGLIB 动态代理；创建子类的代理对象，增强类的方法\n动态 AOP 实现， AOP 框架在运行阶段对动态生成代理对象（在内存中以 JDK 动态代理，或 CGlib 动态地生成 AOP 代理类），如 SpringAOP。\n  \r常用 AOP 实现比较\r\nAOP的JDK 动态代理 使用 JDK 动态代理，使用 Proxy 类里面的方法创建代理对象\npublic static Object newProxyInstance( ClassLoader loader, //类加载器  Class\u0026lt;?\u0026gt;[] interfaces, //增强方法所在的类，这个类实现的接口，*支持多个接口*  InvocationHandler h) //实现这个接口 InvocationHandler，创建代理对象，写增强的部分 AOP 术语 AOP 领域中的特性术语：\n 通知（Advice）: AOP 框架中的增强处理。通知描述了切面何时执行以及如何执行增强处理。  1）前置通知 2）后置通知 3）环绕通知 4）异常通知 5）最终通知   连接点（join point）: 连接点表示应用执行过程中能够插入切面的一个点，这个点可以是方法的调用、异常的抛出。在 Spring AOP 中，连接点总是方法的调用。(可增强) 切点（PointCut）: 可以插入增强处理的连接点。(已增强) 切面（Aspect）: 切面是通知和切点的结合。 引入（Introduction）：引入允许我们向现有的类添加新的方法或者属性。 织入（Weaving）: 将增强处理添加到目标对象中，并创建一个被增强的对象，这个过程就是  AOP操作 Spring 框架一般都是基于 AspectJ 实现 AOP 操作\nAspectJ AspectJ 不是 Spring 组成部分，独立 AOP 框架，一般把 AspectJ 和 Spirng 框架一起使 用，进行 AOP 操作\n基于 AspectJ 实现 AOP 操作：\n 基于 xml 配置文件实现 基于注解方式实现（使用）  切入点表达式\n 切入点表达式作用：知道对哪个类里面的哪个方法进行增强 语法结构： execution([权限修饰符] [返回类型] [类全路径] [方法名称]([参数列表]))  例 1：对 com.atguigu.dao.BookDao 类里面的 add 进行增强 execution(* com.atguigu.dao.BookDao.add(..)) 例 2：对 com.atguigu.dao.BookDao 类里面的所有的方法进行增强 execution(* com.atguigu.dao.BookDao.* (..)) 例 3：对 com.atguigu.dao 包里面所有类，类里面所有方法进行增强 execution(* com.atguigu.dao.. (..))    AspectJ 注解(主要) //被增强的类 @Component public class User { public void add(){ //执行异常通知  // int i = 10/0;  System.out.println(\u0026#34;add...\u0026#34;); } } //创建增强类（编写增强逻辑） //在增强类里面，创建方法，让不同方法代表不同通知类型 //增强的类 @Component @Aspect //生成代理对象 @Order(3) // 数值越小优先级越大 public class UserProxy { //相同切入点  @Pointcut(value = \u0026#34;execution(* spring5.aopanno.User.add(..))\u0026#34;) public void pointdemo(){ } //前置通知  //@Before注解表示作为前置通知  // @Before(value = \u0026#34;execution(* spring5.aopanno.User.add(..))\u0026#34;)  @Before(value = \u0026#34;pointdemo()\u0026#34;)//相同切入点抽取使用！  public void before() { System.out.println(\u0026#34;before......\u0026#34;); } //后置通知  @AfterReturning(value = \u0026#34;execution(* spring5.aopanno.User.add(..))\u0026#34;) public void AfterReturn(){ System.out.println(\u0026#34;AfterReturn......\u0026#34;); } //异常通知  @AfterThrowing(value = \u0026#34;execution(* spring5.aopanno.User.add(..))\u0026#34;) public void AfterThrowing(){ System.out.println(\u0026#34;AfterThrowing......\u0026#34;); } //最终通知  @After(value = \u0026#34;execution(* spring5.aopanno.User.add(..))\u0026#34;) public void after(){ System.out.println(\u0026#34;after......\u0026#34;); } //环绕通知  @Around(value = \u0026#34;execution(* spring5.aopanno.User.add(..))\u0026#34;) public void Around(ProceedingJoinPoint proceedingJoinPoint) throws Throwable { System.out.println(\u0026#34;Around before......\u0026#34;); proceedingJoinPoint.proceed(); System.out.println(\u0026#34;Around after......\u0026#34;); } } @Component @Aspect //生成代理对象 @Order(1) // 数值越小优先级越大 public class PersonProxy { @Before(value = \u0026quot;execution(* spring5.aopanno.User.add(..))\u0026quot;) public void after(){ System.out.println(\u0026quot;person after\u0026quot;); } } \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:aop=\u0026#34;http://www.springframework.org/schema/aop\u0026#34; xmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\u0026#34;\u0026gt; \u0026lt;!-- 开启注解扫描 --\u0026gt; \u0026lt;context:component-scan base-package=\u0026#34;spring5.aopanno\u0026#34;\u0026gt;\u0026lt;/context:component-scan\u0026gt; \u0026lt;!-- 开启Aspect生成代理对象--\u0026gt; \u0026lt;aop:aspectj-autoproxy\u0026gt;\u0026lt;/aop:aspectj-autoproxy\u0026gt; \u0026lt;/beans\u0026gt; \r通过注解声明 5 种通知类型\r\n有多个增强类对同一个方法进行增强，设置增强类优先级\nAspectJ 配置文件 @Configuration //配置类 @ComponentScan(basePackages = {\u0026#34;spring5\u0026#34;}) //组件扫描 @EnableAspectJAutoProxy(proxyTargetClass = true) //生成代理对象 public class ConfigAop { } \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:aop=\u0026#34;http://www.springframework.org/schema/aop\u0026#34; xmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\u0026#34;\u0026gt; \u0026lt;!-- 开启注解扫描 --\u0026gt; \u0026lt;context:component-scan base-package=\u0026#34;spring5.aopanno\u0026#34;\u0026gt;\u0026lt;/context:component-scan\u0026gt; \u0026lt;!-- 开启Aspect生成代理对象--\u0026gt; \u0026lt;aop:aspectj-autoproxy\u0026gt;\u0026lt;/aop:aspectj-autoproxy\u0026gt; \u0026lt;bean id=\u0026#34;book\u0026#34; class=\u0026#34;spring5.aopxml.Book\u0026#34;\u0026gt;\u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;bookProxy\u0026#34; class=\u0026#34;spring5.aopxml.BookProxy\u0026#34;\u0026gt;\u0026lt;/bean\u0026gt; \u0026lt;!--配置aop增强--\u0026gt; \u0026lt;aop:config\u0026gt; \u0026lt;!--切入点--\u0026gt; \u0026lt;aop:pointcut id=\u0026#34;p\u0026#34; expression=\u0026#34;execution(* spring5.aopxml.Book.buy(..))\u0026#34;/\u0026gt; \u0026lt;!--配置切面--\u0026gt; \u0026lt;aop:aspect ref=\u0026#34;bookProxy\u0026#34;\u0026gt; \u0026lt;!--增强作用在具体的方法上--\u0026gt; \u0026lt;aop:before method=\u0026#34;before\u0026#34; pointcut-ref=\u0026#34;p\u0026#34;/\u0026gt; \u0026lt;/aop:aspect\u0026gt; \u0026lt;/aop:config\u0026gt; \u0026lt;/beans\u0026gt; ","date":"2022-01-19T12:07:44+08:00","permalink":"https://damaicao.github.io/post/aop/","title":"Aop"},{"content":"一、IOC容器 IOC容器 什么是IOC  控制反转,把对象创建和对象之间的调用过程，交给Spring进行管理 使用IOC目的：为了降低耦合度  IOC底层原理 xml解析、工厂模式、反射\nSpring提供的IOC容器实现的两种方式（两个接口） BeanFactory接口：IOC容器基本实现是Spring内部接口的使用接口，不提供给开发人员进行使用\n（加载配置文件时候不会创建对象，在获取对象时才会创建对象。)\n采取的懒加载的方式,在获取对象时才会实例化\nSpring源码解析：BeanFactory深入理解_FromNowOnUntilTheEnd-CSDN博客_beanfactory\nApplicationContext接口：BeanFactory接口的子接口，提供更多更强大的功能，提供给开发人员使用\n（加载配置文件时候就会把在配置文件对象进行创建.)\n在工厂初始化时立即实例化对象\nSpring核心讲解篇——ApplicationContext - 知乎 (zhihu.com)\nApplicationContext接口的实现类 二、IOC容器-Bean管理 Spring Bean管理 - CoderJerry - 博客园 (cnblogs.com)\n1.IOC操作Bean管理 指两个操作\n Spring创建对象 Spring注入属性  2.Bean管理操作的两种方式 3.基于xml配置文件方式实现   在spring配置文件中使用bean标签\n  \u0026lt;bean id=\u0026quot;user\u0026quot; class=\u0026quot;spring5.User\u0026quot;\u0026gt;\u0026lt;/bean\u0026gt;     属性介绍\n id:标识名 class:类全路径    创建对象时候，默认也是执行无参数构造方法完成对象创建\n  4.基于XML方式注入属性 DI：依赖注入(注入属性)\n1. set方式注入   在类里面set\n  \u0026lt;bean id=\u0026#34;book\u0026#34; class=\u0026#34;spring5.Book\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;bname\u0026#34; value=\u0026#34;2333\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt;   2. 有参构造函数注入   在类里面构造\n  \u0026lt;bean id=\u0026#34;orders\u0026#34; class=\u0026#34;spring5.Orders\u0026#34;\u0026gt; \u0026lt;constructor-arg name=\u0026#34;oname\u0026#34; value=\u0026#34;abc\u0026#34;\u0026gt;\u0026lt;/constructor-arg\u0026gt; \u0026lt;constructor-arg name=\u0026#34;address\u0026#34; value=\u0026#34;cba\u0026#34;\u0026gt;\u0026lt;/constructor-arg\u0026gt; \u0026lt;/bean\u0026gt;   3. p名称空间注入(了解)   xmlns:p=\u0026#34;http://www.springframework.org/schema/p\u0026#34; \u0026lt;bean id=\u0026#34;book\u0026#34; class=\u0026#34;spring5.Book\u0026#34; p:bname=\u0026#34;very\u0026#34; p:bauthor=\u0026#34;good\u0026#34;\u0026gt;   4. 注入空值和特殊符号   \u0026lt;!--null值--\u0026gt; \u0026lt;property name=\u0026#34;address\u0026#34;\u0026gt; \u0026lt;!--属性里边添加一个null标签--\u0026gt; \u0026lt;null/\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;!--（2）特殊符号赋值--\u0026gt; \u0026lt;!--属性值包含特殊符号 a 把\u0026lt;\u0026gt;进行转义 \u0026amp;lt; \u0026amp;gt; b 把带特殊符号内容写到CDATA --\u0026gt; \u0026lt;property name=\u0026#34;address\u0026#34;\u0026gt; \u0026lt;!--\u0026lt;value=\u0026#34;\u0026lt;\u0026lt;南京\u0026gt;\u0026gt;\u0026#34;\u0026gt;\u0026lt;/value\u0026gt;--\u0026gt; \u0026lt;value\u0026gt;\u0026lt;![CDATA[\u0026lt;\u0026lt;南京\u0026gt;\u0026gt;]]\u0026gt;\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt;   注入属性-外部bean   \u0026lt;bean id=\u0026#34;userService\u0026#34; class=\u0026#34;spring5.service.UserService\u0026#34;\u0026gt; \u0026lt;!--注入userDao对象 name属性：类里面属性名称 ref属性：注入userDao对象bean标签id值 --\u0026gt; \u0026lt;property name=\u0026#34;userDao\u0026#34; ref=\u0026#34;userDaoImpl\u0026#34;\u0026gt;\t\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;userDaoImpl\u0026#34; class=\u0026#34;spring5.dao.UserDaoImpl\u0026#34;\u0026gt; \u0026lt;/bean\u0026gt;   注入内部bean和级联赋值   注入属性-内部bean\n\u0026lt;bean id=\u0026#34;emp\u0026#34; class=\u0026#34;spring5.bean.Emp\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;ename\u0026#34; value=\u0026#34;lucy\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;gender\u0026#34; value=\u0026#34;girl\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;!--\u0026lt;property name=\u0026#34;dept\u0026#34; ref=\u0026#34;dept\u0026#34;\u0026gt;\u0026lt;/property\u0026gt;--\u0026gt; \u0026lt;property name=\u0026#34;dept\u0026#34;\u0026gt; \u0026lt;bean id=\u0026#34;dept\u0026#34; class=\u0026#34;spring5.bean.Dept\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;dname\u0026#34; value=\u0026#34;安保\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt;   注入属性-级联赋值\n  public Dept getDept(){//返回对象  return dept; }   \u0026lt;bean id=\u0026#34;emp\u0026#34; class=\u0026#34;spring5.bean.Emp\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;ename\u0026#34; value=\u0026#34;lucy\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;gender\u0026#34; value=\u0026#34;girl\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;dept\u0026#34; ref=\u0026#34;dept\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;dept.dname\u0026#34; value=\u0026#34;cwb\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;dept\u0026#34; class=\u0026#34;spring5.bean.Dept\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;dname\u0026#34; value=\u0026#34;安保\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt;     IOC 操作 Bean 管理——xml 注入集合属性   注入数组, List ,Map和Set集合类型属性\n  \u0026lt;property name=\u0026#34;courses\u0026#34;\u0026gt; \u0026lt;array\u0026gt; \u0026lt;value\u0026gt;java\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;python\u0026lt;/value\u0026gt; \u0026lt;/array\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;list\u0026#34;\u0026gt; \u0026lt;list\u0026gt; \u0026lt;value\u0026gt;c\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;c++\u0026lt;/value\u0026gt; \u0026lt;/list\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;maps\u0026#34;\u0026gt; \u0026lt;map\u0026gt; \u0026lt;entry key=\u0026#34;JAVA\u0026#34; value=\u0026#34;java\u0026#34;\u0026gt;\u0026lt;/entry\u0026gt; \u0026lt;entry key=\u0026#34;PYTHON\u0026#34; value=\u0026#34;python\u0026#34;\u0026gt;\u0026lt;/entry\u0026gt; \u0026lt;/map\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;sets\u0026#34;\u0026gt; \u0026lt;set\u0026gt; \u0026lt;value\u0026gt;mysql\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;redis\u0026lt;/value\u0026gt; \u0026lt;/set\u0026gt; \u0026lt;/property\u0026gt;   在集合里面设置对象类型值\n  \u0026lt;property name=\u0026#34;courseList\u0026#34;\u0026gt; \u0026lt;list\u0026gt; \u0026lt;ref bean=\u0026#34;course1\u0026#34;\u0026gt;\u0026lt;/ref\u0026gt; \u0026lt;ref bean=\u0026#34;course2\u0026#34;\u0026gt;\u0026lt;/ref\u0026gt; \u0026lt;/list\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;bean id=\u0026#34;course1\u0026#34; class=\u0026#34;spring5.colletiontype.Course\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;cname\u0026#34; value=\u0026#34;Sprint5\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;course2\u0026#34; class=\u0026#34;spring5.colletiontype.Course\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;cname\u0026#34; value=\u0026#34;Sprint6\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt;     把集合注入部分提取出来\n  xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd\u0026#34;\u0026gt;   \u0026lt;util:list id=\u0026#34;bookList\u0026#34;\u0026gt; \u0026lt;value\u0026gt;123\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;213\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;321\u0026lt;/value\u0026gt; \u0026lt;/util:list\u0026gt; \u0026lt;bean id=\u0026#34;book\u0026#34; class=\u0026#34;spring5.colletiontype.Book\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;list\u0026#34; ref=\u0026#34;bookList\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt;     5.Bean 管理（FactoryBean）   Spring 有两种类型 bean，一种普通 bean，另外一种工厂 bean（FactoryBean）\n  普通 bean：在配置文件中定义 bean 类型就是返回类型\n  工厂 bean：在配置文件定义 bean 类型可以和返回类型不一样\n  第一步 创建类，让这个类作为工厂 bean，实现接口 FactoryBean\n  第二步 实现接口里面的方法，在实现的方法中定义返回的 bean 类型\n  public class MyBean implements FactoryBean\u0026lt;Course\u0026gt; { @Override public Course getObject() throws Exception { Course course = new Course(); course.setCname(\u0026#34;abc\u0026#34;); return course; } }   \u0026lt;bean id=\u0026#34;myBean\u0026#34; class=\u0026#34;spring5.factorybean.MyBean\u0026#34;\u0026gt;\u0026lt;/bean\u0026gt;     6.bean的作用域      类别 说明     singleton 默认值; 在Spring IOC容器中仅存在一个Bean实例，Bean以单例方式存在。(内存地址相同)   prototype 每次从容器中调用Bean时，都返回一个新的实例;   request 每次HTTP请求都会创建一个新的Bean，仅适用于WebApplicationContext环境   session 同一个HTTP Session 共享一个Bean，不同Session使用不同Bean，仅适用于WebApplicationContext 环境   application Bean的作用域为ServletContext ，仅适用于WebApplicationContext环境。      作用域就是指作用范围:单例则表示对象的作用范围是整个Spring容器,而prototype则表示不管理作用范围,每次get就直接创建新的\n  设置单实例对象和多实例对象 在 spring 配置文件 bean 标签里面属性（scope）用于设置单实例还是多实例\n\u0026lt;bean id=\u0026#34;book\u0026#34; class=\u0026#34;spring5.colletiontype.Book\u0026#34; scope=\u0026#34;prototype\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;list\u0026#34; ref=\u0026#34;bookList\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; singleton 和 prototype 区别   singleton 单实例，prototype 多实例\n  设置 scope 值是 singleton 时候，加载 spring 配置文件时候就会创建单实例对象\n  设置 scope 值是 prototype 时候，不是在加载 spring 配置文件时候创建对象，在调用 getBean 方法时候创建多实例对象\n   7.Bean的生命周期 Spring Bean的生命周期（非常详细） - Chandler Qian - 博客园 (cnblogs.com)\nSpring Bean的完整生命周期从创建Spring容器开始，直到最终Spring容器销毁Bean\nbean生命周期的执行顺序   通过构造器创建 bean 实例（无参数构造）\n  为 bean 的属性设置值和对其他 bean 引用（调用 set 方法）\n  调用 bean 的初始化的方法（需要进行配置初始化的方法）\n  bean 可以使用了（对象获取到了）\n  当容器关闭时候，调用 bean 的销毁的方法（需要进行配置销毁的方法）\n  \u0026lt;bean id=\u0026#34;orders\u0026#34; class=\u0026#34;spring5.bean.Orders\u0026#34; init-method=\u0026#34;initMethod\u0026#34; destroy-method=\u0026#34;destroyMethod\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;oname\u0026#34; value=\u0026#34;sj\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt;   ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;bean4.xml\u0026#34;); //手动销毁 context.close(); ApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;bean2.xml\u0026#34;); ((ClassPathXmlApplicationContext) context).close();   bean 的后置处理器，bean 生命周期有七步\n  通过构造器创建 bean 实例（无参数构造）\n  为 bean 的属性设置值和对其他 bean 引用（调用 set 方法）\n  把 bean 实例传递 bean 后置处理器的方法 postProcessBeforeInitialization\n  调用 bean 的初始化的方法（需要进行配置初始化的方法）\n  把 bean 实例传递 bean 后置处理器的方法 postProcessAfterInitialization\n  bean 可以使用了（对象获取到了）\n  当容器关闭时候，调用 bean 的销毁的方法（需要进行配置销毁的方法）\n  \u0026lt;!--配置后置处理器--\u0026gt; \u0026lt;bean id=\u0026#34;myBeanPost\u0026#34; class=\u0026#34;spring5.bean.MyBeanPost\u0026#34;\u0026gt;   public class MyBeanPost implements BeanPostProcessor { @Override public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException { System.out.println(\u0026#34;初始化之前\u0026#34;); return null; } @Override public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException { System.out.println(\u0026#34;初始化之后\u0026#34;); return null; } }   8.Bean管理XML方式(自动装配) 1、什么是自动装配 根据指定装配规则（属性名称或者属性类型)，Spring自动将匹配的属性值进行注入\n\u0026lt;!--实现自动装配 bean标签属性autowire，配置自动装配 autowire属性常用两个值: byName根据属性名称注入, 注入的bean的id值与类属性名称要一样 byType根据属性类型注入, 多属性会错误 --\u0026gt; \u0026lt;!--\u0026lt;bean id=\u0026#34;emp\u0026#34; class=\u0026#34;spring5.autowire.Emp\u0026#34; autowire=\u0026#34;byName\u0026#34;\u0026gt;--\u0026gt; \u0026lt;bean id=\u0026#34;emp\u0026#34; class=\u0026#34;spring5.autowire.Emp\u0026#34; autowire=\u0026#34;byType\u0026#34;\u0026gt; \u0026lt;!--\u0026lt;property name=\u0026#34;dept\u0026#34; ref=\u0026#34;dept\u0026#34;\u0026gt;\u0026lt;/property\u0026gt;--\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;dept\u0026#34; class=\u0026#34;spring5.autowire.Dept\u0026#34;\u0026gt;\u0026lt;/bean\u0026gt; 9.IOC 操作 Bean 管理(外部属性文件) 方式一：直接配置数据库信息 （1）配置Druid（德鲁伊）连接池 （2）引入Druid（德鲁伊）连接池依赖 jar 包\n\u0026lt;bean id=\u0026#34;dataSource\u0026#34; class=\u0026#34;com.alibaba.druid.pool.DruidDataSource\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;driverClassName\u0026#34; value=\u0026#34;com.mysql.cj.jdbc.Driver\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;jdbc:mysql://localhost:3306/userDb\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;root\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;root\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; 方式二：引入外部属性文件配置数据库连接池 （1）创建外部属性文件，properties 格式文件，写数据库信息（jdbc.properties）\nxmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34; xsi:schemaLocation=\u0026#34; http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\u0026#34; \u0026lt;context:property-placeholder location=\u0026#34;classpath:jdbc.properties\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;dataSource\u0026#34; class=\u0026#34;com.alibaba.druid.pool.DruidDataSource\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;driverClassName\u0026#34; value=\u0026#34;${prop.driverClass}\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;${prop.url}\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;${prop.userName}\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;${prop.password}\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; 10.IOC 操作 Bean 管理(基于注解方式) 什么是注解   注解是代码特殊标记，格式：@注解名称(属性名称=属性值, 属性名称=属性值…)\n  使用注解，注解作用在类上面，方法上面，属性上面\n  使用注解目的：简化 xml 配置\n  Spring 针对 Bean 管理中创建对象提供注解 下面四个注解功能是一样的,仅仅是为了对Bean进行分层是结构更清晰，都可以用来创建 bean 实例\n  @Component - 通用注解:用于在Spring中加入Bean\n  @Service @Component 标注业务层\n  @Controller @Component 标注控制层\n  @Repository 等价于 @Component 标注数据访问层(DAO)\n基于注解方式实现对象创建 第一步 引入依赖 （引入spring-aop jar包）\n第二步 开启组件扫描\n\u0026lt;!--开启组件扫描 1 如果扫描多个包，多个包使用逗号隔开 2 扫描包上层目录 --\u0026gt; \u0026lt;!--\u0026lt;context:component-scan base-package=\u0026#34;spring5.dao, spring5.service\u0026#34;\u0026gt;\u0026lt;/context:component-scan\u0026gt;--\u0026gt; \u0026lt;context:component-scan base-package=\u0026#34;spring5\u0026#34;\u0026gt;\u0026lt;/context:component-scan\u0026gt; 第三步 创建类，在类上面添加创建对象注解\n//在注解里面 value 属性值可以省略不写， //默认值是类名称，首字母小写 //UserService -- userService //若注解中没有指定id则默认使用简单类名且小写开头 @Component(value = \u0026#34;userService\u0026#34;) //注解等同于XML配置文件：\u0026lt;bean id=\u0026#34;userService\u0026#34; class=\u0026#34;..\u0026#34;/\u0026gt; public class UserService { public void add() { System.out.println(\u0026#34;service add.......\u0026#34;); } } 开启组件扫描细节配置 \u0026lt;!-- use-default-filters=\u0026#34;false\u0026#34; 表示现在不使用默认 filter，自己配置 filter context:include-filter ，设置扫描哪些内容 type=\u0026#34;annotation\u0026#34; 根据注解来扫描 expression=\u0026#34;org.springframework.stereotype.Controller\u0026#34;表达式:指扫描Controller注解 --\u0026gt; \u0026lt;context:component-scan base-package=\u0026#34;spring5\u0026#34; use-defaultfilters=\u0026#34;false\u0026#34;\u0026gt; \u0026lt;context:include-filter type=\u0026#34;annotation\u0026#34; expression=\u0026#34;org.springframework.stereotype.Controller\u0026#34;/\u0026gt;\u0026lt;!--代表只扫描Controller注解的类--\u0026gt; \u0026lt;/context:component-scan\u0026gt; \u0026lt;!-- 下面配置扫描包所有内容 context:exclude-filter： 设置哪些内容不进行扫描 --\u0026gt; \u0026lt;context:component-scan base-package=\u0026#34;spring5\u0026#34;\u0026gt; \u0026lt;context:exclude-filter type=\u0026#34;annotation\u0026#34; expression=\u0026#34;org.springframework.stereotype.Controller\u0026#34;/\u0026gt; \u0026lt;!--表示Controller注解的类之外一切都进行扫描--\u0026gt; \u0026lt;/context:component-scan\u0026gt; 基于注解方式实现属性注入   @Autowired：根据属性类型进行自动装配\n  把 service 和 dao 对象创建，在 service 和 dao 类添加创建对象注解\n  在 service 注入 dao 对象，在 service 类添加 dao 类型属性，在属性上面使用注解\n  注意:若通过类型注入,则当Spring中存在多个类型都匹配的Bean时直接报错\n  @Service public class UserService { //定义 dao 类型属性  //不需要添加 set 方法  //添加注入属性注解,自动注入实现类  @Autowired private UserDao userDao; public void add() { System.out.println(\u0026#34;service add.......\u0026#34;); userDao.add(); } } //Dao实现类 @Repository //@Repository(value = \u0026#34;userDaoImpl1\u0026#34;) public class UserDaoImpl implements UserDao { @Override public void add() { System.out.println(\u0026#34;dao add.....\u0026#34;); } }     @Qualifier：根据名称进行注入，这个@Qualifier 注解的使用，和上面@Autowired 一起使用\n  //定义 dao 类型属性 //不需要添加 set 方法 //添加注入属性注解 //根据类型进行注入 @Autowired //根据名称进行注入（目的在于区别同一接口下有多个实现类，根据类型就无法选择，从而出错！） @Qualifier(value = \u0026#34;userDaoImpl1\u0026#34;) private UserDao userDao; //实现类 @Repository(value = \u0026#34;userDaoImpl1\u0026#34;) public class UserDaoImpl implements UserDao     @Resource：可以根据类型注入，也可以根据名称注入（它属于javax包下的注解，不推荐使用！）\n  @Value：注入普通类型属性\n  @Value属性注入功能根据注入的内容来源可分为两类：通过配置文件的属性注入和通过非配置文件的属性注入。\n  通过配置文件的注入根据配置文件的来源又可分为两类：一类为默认的Spring Boot会自动加载的配置文件application.properties中的属性；另一类为自定义配置文件中的属性，需要先通过@PropertySource加载。\n  @PropertySource(\u0026#34;classpath:my.properties\u0026#34;) @Value(\u0026#34;hello\u0026#34;)//基本类型  private String info; @Value(\u0026#34;#{true and false}\u0026#34;) //SPEL表达式  private String info1; @Value(\u0026#34;${prop.password}\u0026#34;) //注入属性配置  private String info2;     完全注解开发 创建配置类，替代 xml 配置文件\n@Configuration //作为配置类，替代 xml 配置文件 @ComponentScan(basePackages = {\u0026quot;com.atguigu\u0026quot;}) public class SpringConfig //加载配置类 ApplicationContext context = new AnnotationConfigApplicationContext(SpringConfig.class); ","date":"2022-01-16T19:35:55+08:00","permalink":"https://damaicao.github.io/post/ioc%E5%AE%B9%E5%99%A8/","title":"IOC容器"},{"content":"一、什么是Spring？ 1、什么是spring?（面试题） Spring是一个开源的Java EE开发框架。Spring框架的核心功能可以应用在任何Java应用程序中，但对Java EE平台上的Web应用程序有更好的扩展性。Spring框架的目标是使得Java EE应用程序的开发更加简捷，通过使用POJO为基础的编程模型促进良好的编程风格。\n  Spring是轻量级的开源的JavaEE框架\n  Spring可以解决企业应用开发的复杂性。\n  Spring有两个核心部分:IOC和Aop\n  IOC:控制反转,把创建对象过程交给Spring进行管理)\n  Aop:面向切面,不修改源代码进行功能增强\n    Spring特点\n 方便解耦，简化开发 Aop编程支持 方便程序测试 方便和其他框架进行整合; 方便进行事务操作, 降低API开发难度·    spring下载地址\n","date":"2022-01-16T16:47:27+08:00","permalink":"https://damaicao.github.io/post/spring%E6%A1%86%E6%9E%B6%E7%AE%80%E8%BF%B0/","title":"Spring框架简述"},{"content":"本笔记由B站小伙伴(别人家的孩子小明,汉苍茫茫)开源提供\nhttps://shimo.im/docs/vkCKkj3YxGtygrVg/\nhttps://shimo.im/docs/PJAUY30F1uYksv0h/\n视频【计算机科学速成课】40集全/精校] - Crash Course Computer Science_哔哩哔哩_bilibili\n[TOC]\n第一课：计算机早期历史 0、课程目标：从高层次总览一系列计算机话题，快速入门计算机科学。 1、计算机技术的影响——进入信息时代   出现自动化农业设备与医疗设备\n  全球通信和全球教育机会变得普遍\n  出现意想不到的虚拟现实/无人驾驶/人工智能等新领域\n  2、计算机的实质： 极其简单的组件，通过一层层的抽象，来做出复杂的操作。\n计算机中的很多东西，底层其实都很简单，让人难以理解的，是一层层精妙的抽象。像一个越来越小的俄罗斯套娃。\n3、关于计算的历史：   公元前2500年，算盘出现，为十进制，功能类似一个计数器。\n  公元前2500年-公元1500年：星盘、计算尺等依靠机械运动的计算设备出现\n  公元1613年：computer的概念出现，当时指的是专门做计算的职业，\n  1694年：步进计算器出现，是世界上第一台能自动完成加减乘除的计算器。\n  1694-1900年：计算表兴起，类似于字典，可用于查找各种庞大的计算值。\n  1823年：差分机的设想出现，可以做函数计算，但计划最后失败。\n  19世纪中期：分析机的设想出现，设想存在可计算一切的通用计算机。\n  1890年：打孔卡片制表机。原理：在纸上打孔→孔穿过针→针泡入汞→电路连通→齿轮使计数+1。\n  第二课：电子计算机的发展史 1、电子计算机元器件变化： 继电器→真空管→晶体管\n2、计算机的出现背景： 20世纪人口暴增，科学与工程进步迅速，航天计划成形。以上导致数据的复杂度急剧上升、计算量暴增，对于计算的自动化、高速有迫切的需求。\n3、电子计算机的发展： 1945年 哈佛马克1：使用继电器，用电磁效应，控制机械开关，缺点为有磨损和延迟。\n*最早还因为有虫子飞进去导致故障，引申出bug=故障的意思。\n1943年 巨人1号：使用真空管（三极管），制造出世界上第一个可编程的计算机。\n1946年 ENIAC：第一个电子数值积分计算机，为第一台通用计算机。\n1947年 晶体管出现，使用的是固态的半导体材料，相对真空管更可靠。\n1950s 空军ANFSQ-7： 真空管到达计算极限。\n1957年 IBM 608： 第一个消费者可购买的晶体管计算机出现。\n第三课：布尔逻辑与逻辑门 1、计算机为什么使用二进制：   计算机的元器件晶体管只有2种状态，通电（1）\u0026amp;断电（0），用二进制可直接根据元器件的状态来设计计算机。\n  而且，数学中的“布尔代数”分支，可以用True和False（可用1代表True，0代表False）进行逻辑运算，代替实数进行计算。\n  计算的状态越多，信号越容易混淆，影响计算。对于当时每秒运算百万次以上的晶体管，信号混淆是特别让人头疼的的。\n  2、布尔代数\u0026amp;布尔代数在计算机中的实现   变量：没有常数，仅True和False这两个变量。\n  三个基本操作：\n   NOT/AND/OR。  1）NOT操作： 1命名：称为NOT门/非门。\n2作用：将输入布尔值反转。输入的True或False，输出为False或True。\n3晶体管的实现方式：\n  半导体通电True，则线路接地，无输出电流，为False。\n  半导体不通电False，则输出电流从右边输出，为True。\n  2）AND操作 1命名：AND门/与门\n2作用：由2个输入控制输出，仅当2个输入input1和input2都为True时，输出才为True，2个输入的其余情况，输出均为False。*可以理解为，2句话（输入）完全没有假的，整件事（输出）才是真的。\n3用晶体管实现的方式：\n串联两个晶体管，仅当2个晶体管都通电，输出才有电流（True）\n3）OR操作 1命名：OR门/或门\n2作用：由2个输入控制输出，只要其中一个输入为True，则输出True。\n3用晶体管实现的方式：\n使用2个晶体管，将它们并联到电路中，只要有一个晶体管通电，则输出有电流（True）。\n3、特殊的逻辑运算——异或 1命名：XOR门/异或门\n2作用：2个输入控制一个输出。当2个输入均为True时，输出False，其余情况与OR门相同。\n3图示：\n先用一个OR门，将其与AND门并联，AND门与NOT门串联，最后让NOT与AND门并联，获得输出。\n\rimg\r\n4、逻辑门的符号表示 1作用：将逻辑门简化，将逻辑门用于构建更大的组件，而不至于太复杂。\n2图示：\n  非门：用三角形+圆圈表示\n  与门：用D型图案表示\n  或门：用类似D向右弯曲的图案表示\n  异或门：用或门+一个圆弧表示\n  5、抽象的好处 使得分工明确，不同职业的工程师各司其职,而不用担心其他细节。\n第四课：二进制 1、二进制的原理，存储单元MB/GB/TB解释 0计算机中的二进制表示：\n单个数字1或0，1位二进制数字命名为位(bit),也称1比特。\n1字节（byte）的概念：\n1byte=8bit，即1byte代表8位数字。最早期的电脑为八位的，即以八位为单位处理数据。为了方便，将八位数字命名为1字节（1byte）.\n2十进制与二进制的区别：\n  十进制有10个数字，0-9，逢10进1（不存在10这个数字），则每向左进一位，数字大10倍。\n  二进制有2个数字，0-1，逢2进1,（不存在2这个数字），则每向左进一位，数字大2倍。\n  2如何进行二进制与十进制联系起来：\n 将十进制与二进制的位数提取出来，编上单位：  eg.二进制的1011=12^0 + 12^1 + 02^2 + 12^3= 11（从右往左数）\neg.十进制的1045= 110^3 + 010^2 + 410^1 + 510^0\n3十进制与二进制的图示：\n十进制的263\n二进制的10110111\n4二进制的运算：\n相同的位数相加，逢2进1\n5 byte在电脑中的单位换算：\n1kb=2^10bit = 1024byte =1000b\n1TB=1000GB\n1GB=十亿字节=1000MB=10^6KB\n6 32位与64位电脑的区别\n32位的最大数为43亿左右\n64位的最大数为9.2*10^18\n2、正数、负数、正数、浮点数的表示 1）计算机中表示数字的方法\n1整数：\n表示方法:\n  第1位：表示正负 1是负，0是正（补码）\n  其余31位/63位： 表示实数\n  2浮点数（Floating Point Numbers）：\n定义：小数点可在数字间浮动的数（非整数）\n表示方法：IEEE 754标准下\n用类似科学计数法的方式，存储十进制数值\n  浮点数=有效位数*指数\n  32位数字中：第1位表示正负，第2-9位存指数。剩下23位存有效位数\n  eg.625.9=0.6259（有效位数）*10^3（指数）\n3、美国信息交换标准代码-ASCⅡ，用来表示字符 1全称：美国信息交换标准代码\n2作用：用数字给英文字母及符号编号\n3内容：7位代码，可存放128个不同的值。\n4图示：\n4、UNICODE，统一所有字符编码的标准 1诞生背景：1992诞生，随着计算机在亚洲兴起，需要解决ASCⅡ不够表达所有语言的问题。\n为提高代码的互用性，而诞生的编码标准。\n2内容：UNICODE为17组的16位数字，有超过100万个位置，可满足所有语言的字符需求。\n第五课：算术逻辑单元 1、什么是算术逻辑单元 1命名：简称ALU，Arithmetic\u0026amp;Logic Unit\n2组成：ALU有2个单元，1个算术单元和1个逻辑单元（Arithmetic Unit和Logic Unit）\n3作用：计算机中负责运算的组件，处理数字/逻辑运算的最基本单元。\n2、算术单元 1）基本组件：\n  由半加器、全加器组成\n  半加器、全加器由AND、OR、NOT、XOR门组成\n  2）加法运算\n1组件：AND、OR、NOT、XOR门\n2元素：输入A，输入B，输出（均为1个bit，即0或1）\n3半加器：\n  作用：用于计算个位的数字加减。\n  输入：A，B\n  输出：总和，进位\n  抽象：\n  4全加器：\n作用：用于计算超过1位的加法，由于涉及进位，因此有3个输入（C充当进位）。\n原理图示：\n3）如何用半加器与全加器做8位数的加法\n1说明：以8位行波加法器为例\n  用半加器处理第1位数（个位）的加法，得到的和为结果的第1位。\n  将输出的进位，输入到第2位用的全加器的输入C中。\n  将第2位的2个数用全加器计算，得到的和为结果的第2位（sum）。\n  将第2位计算的进位连接到百位的全加器输入C中。\n  在第3-8位上，循环第3-4步的操作。\n  *现在电脑使用的加法器叫“超前进位加法器”\n4）算术单元支持的其他运算\n3、溢出的概念 内容：在有限的空间内，无法存储位数过大的数，则称为溢出。\n说明：第8位的进位如果为1，则无法存储，此时容易引发错误，所以应该尽量避免溢出。\n4、逻辑单元 作用：执行逻辑操作，如NOT、AND、OR等操作，以及做简单的数值测试。\n5、ALU的抽象 1）作用：ALU的抽象让工程师不再考虑逻辑门层面的组成，简化工作。\n2）图示：\n像一个大“V”。\n3）说明：\n图示内容包括：\n  输入A，B\n  输出\n  标志：溢出、零、负数\n  第六课 寄存器与内存 0、课程导入 当玩游戏、写文档时如果断电，进度会丢失，这是为什么？\n  原因是这是电脑使用的是RAM（随机存取存储器），俗称内存，内存只能在通电情况下存储数据。\n  本节课程将讲述内存的工作原理。\n  1、概念梳理 锁存器：锁存器是利用AND、OR、NOT逻辑门，实现存储1位数字的器件。\n寄存器：1组并排的锁存器\n矩阵：以矩阵的方式来存放锁存器的组合件，nn门锁矩阵可存放n^2个锁存器，但同一时间只能写入/读取1个数字。（早期为1616矩阵）\n位址：锁存器在矩阵中的行数与列数。eg.12行 8列\n多路复用器：一组电线，输入2进制的行址\u0026amp;列址，可启用矩阵中某个锁存器\n内存（RAM）：随机存取存储器，由一系列矩阵以及电路组成的器件，可根据地址来写入、读取数据。类似于人类的短期记忆，记录当前在做什么事情。\n2、锁存器 作用：存储1位数字。\n图示：\n2.5、门锁： 锁存器需要同时输入2个数字，不太方便。\n为了使用更方便，只用1根电线控制数据输入，发展了门锁这个器件。另外，用另一根电线来控制整个结构的开关。（和复位作用不同）\n3、寄存器 作用：并排使用门锁，存储多位数字\n图示：\n4、门锁矩阵 作用：\nn*n的矩阵有n^2个位址，则可以存储n^2个数。但1个矩阵只可记录1位数字，n个矩阵组合在一起，才可记录n位数。如1个8位数，会按位数分成8个数，分别存储在8个矩阵的同一个位址中。\n8个矩阵，则可以记录256个8位数字。\n通俗理解：\n16*16的门锁矩阵，可理解为1个公寓，1个公寓256个房间。\n8个门锁矩阵并排放，则有了8个公寓。\n规定每一个公寓同一个编号的房间，都有一样的标记（地址），共同组成8位数字。\n那么8个公寓就能存 （8*256 / 8）个数字。\n原因：\n16*16的门锁矩阵虽然有256个位置，但每次只能存/取其中1个位置的数字。因此，要表示8位数字，就需要同时调用8个门锁矩阵。\n图示：\n使用方法：在多路复用器中输入位址，x行x列（2进制），即可点亮x行x列的锁存器。\n举例：\n   行列数 矩阵1 矩阵2 矩阵3 矩阵4 矩阵5 矩阵6 矩阵7 矩阵8     1行5列 1 0 1 1 0 0 1 0   2行3列 0 1 0 0 1 1 0 1    5、内存 粗略定义：将一堆独立的存储模块和电路看做1个单元，组成内存方块，n个内存方块组成内存模块。在一个电路板上所有的内存方块统称为内存(RAM)。\n第七课 中央处理器（CPU） 1、概念梳理   CPU（Central Processing Unit）：中央处理单元，负责执行程序。通常由寄存器/控制单元/ALU/时钟组成。与RAM配合，执行计算机程序。CPU和RAM之间用“地址线”、“数据线”和“允许读/写线”进行通信。\n  指令：指示计算机要做什么，多条指令共同组成程序。如数学指令，内存指令。\n  时钟：负责管理CPU运行的节奏，以精确地间隔，触发电信号，控制单元用这个信号，推动CPU的内部操作。\n  时钟速度：CPU执行“取指令→解码→执行”中每一步的速度叫做“时钟速度”，单位赫兹Hz，表示频率。\n  超频/降频：\n  超频，修改时钟速度，加快CPU的速度，超频过多会让CPU过热或产生乱码。\n  降频，降低时钟速度，达到省电的效果，对笔记本/手机很重要。\n  微体系框架：以高层次视角看计算机，如当我们用一条线链接2个组件时，这条线只是所有必须线路的抽象。\n  2、CPU工作原理 1）必要组件：   指令表：给CPU支持的所有指令分配ID\n  控制单元：像指挥部，有序的控制指令的读取、运行与写入。\n  指令地址寄存器：类似于银行取号。该器件只按顺序通报地址，让RAM按顺序将指令交给指令寄存器。\n  指令寄存器：存储具体的指令代码。\n  2）过程   取指令：指令地址寄存器发地址给RAM→RAM发该地址内的数据给指令寄存器→指令寄存器接受数据\n  解码：指令寄存器根据数据发送指令给控制单元 →控制单元解码（逻辑门确认操作码）\n  执行阶段：控制单元执行指令(→涉及计算时→调用所需寄存器→传输入\u0026amp;操作码给ALU执行）→调用RAM特定地址的数据→RAM将结果传入寄存器→指令地址寄存器+1\n  第八课 指令和程序 1、概念梳理  指令：指示计算机要做什么的代码（机器码），多条指令共同组成程序。如数学指令，内存指令。 注:指令和数据都是存在同一个内存里的。 指令集：记录指令名称、用法、操作码以及所需RAM地址位数的表格。  2、指令的执行   原则：\n  RAM每一个地址中，都存放0或1个数据。\n  特定的数字组合，就表示为一个指令，否则表示一个值。\n  LOAD指令：\n  计算机会按地址的顺序，读取RAM中所记录的指令/数据。\n  计算机接受到指令后，如LOAD_A，则通过数据线将数据传至寄存器A。\n  ADD指令：\n  ADD B A指令告诉ALU，把寄存器B和寄存器中的数字加起来，存到寄存器A中。\n  JUMP指令：\n  遇到JUMP指令，程序会跳转至对应的RAM地址读取数据。\n  JUMP指令可以有条件跳转（如JUMP-negative），也可以无条件跳转。\n  3、计算机指令长度 由于早期计算机每个字只有8位，指令只占4位，意味着只能有16个指令，这远远不够。\n现代计算机有两种方式解决指令不够用的问题：\n最直接的是用更多位来表示指令，如32位或64位。\n采用“可变指令长度”，令不同的指令的长度不同，尽量节约位数。\n假设1个字为16位，如果某指令不需要操作内存，则可以省去寻址的位数。\n该情况下，部分指令后面需要跟数据，如JUMP，称为立即值。\n第九课 高级CPU设计 0、概念梳理   缓存：在CPU中的小块RAM，用于存储批量指令。\n  缓存命中：想要的数据已经在缓存里\n  缓存未命中：想要的数据不在缓存里\n  脏位：缓存里每块空间，有个特殊标记，叫脏位，用于检测缓存内的数据是否与RAM一致。\n  多核处理器：一个CPU芯片中，有多个独立处理单元。\n  1、现代CPU如何提升性能： 早期通过加快晶体管速度，来提升CPU速度。但很快该方法到达了极限。\n后来给CPU设计了专门除法电路+其他电路来做复杂操作：如游戏，视频解码\n2、缓存： 为了不让CPU空等数据，在CPU内部设置了一小块内存，称为缓存，让RAM可以一次传输一批数据到CPU中。（不加缓存，CPU没位置放大量数据）\n缓存也可以当临时空间，存一些中间值，适合长/复杂的运算。\n空等原因：从RAM到CPU的数据传输有延迟（要通过总线，RAM还要时间找地址、取数据、配置、输出数据）。\n3、缓存同步： 缓存同步一般发生在CPU缓存已满，但CPU仍需往缓存内输入数据。此时，被标记为脏位的数据会优先传输回RAM,腾出位置以防被覆盖，导致计算结果有误。\n4、指令流水线： 作用：让取址→解码→执行三个步骤同时进行。并行执行指令，提升CPU性能。\n原本需要3个时钟周期执行1个指令，现在只需要1个时钟周期。\n设计难点：数据具有依赖性。\n数据依赖性解决方法：\n动态排序、乱序运行、预测分支（高端CPU）\n5、一次性处理多条指令 6、同时运行多个指令流（多核CPU） 多核处理器：一个CPU芯片中，有多个独立处理单元。但因为它们整合紧密，可以共享一些资源。\n7、超级计算机（多个CPU） 在一台计算机中，用无数个CPU，做怪兽级的复杂运算，如模拟宇宙形成。\n第十课 早期的编程方式 1、早期，程序如何进入计算机 程序必须人为地输入计算机。早期，电脑无内存的概念，人们通过打孔纸卡等物理手段，输入数据（数字），进入计算机。\n2、早期计算机的编程   打孔纸卡/纸带：在纸卡上打孔，用读卡器读取连通电路，进行编程。原因，穿孔纸卡便宜、可靠也易懂。62500张纸卡=5MB数据\n  插线板：通过插拔线路的方式，改变器件之间的连接方式，进行编程。\n  面板拨开关（1980s前）：通过拨动面板上的开关，进行编程。输入二进制操作码，按存储按钮，推进至下一个内存位，直至操作完内存，按运行键执行程序。（内存式电脑）\n  3、现代计算机基础结构——冯诺依曼计算机 冯诺依曼计算机的标志是，一个处理器(有算术逻辑单元)+数据寄存器+指令寄存器+指令地址寄存器+内存\n第十一课 编程语言发展史 0、概念梳理 伪代码：用自然语言（中文、英语等）对程序的高层次描述，称为“伪代码”\n汇编器：用于将汇编语言装换成机器语言。一条汇编语句对应一条机器指令。\n助记符（汇编器）：\n软件\n1、早期二进制写代码 先前都是硬件层面的编程，硬件编程非常麻烦，所以程序员想要一种更通用的编程方法，就是软件。\n早期，人们先在纸上写伪代码，用\u0026quot;操作码表\u0026quot;把伪代码转成二进制机器码，翻译完成后，程序可以喂入计算机并运行。\n2、汇编器\u0026amp;助记符 背景：1940~1950s，程序员开发出一种新语言， 更可读 更高层次。每个操作码分配一个简单名字，叫\u0026quot;助记符\u0026quot;。但计算机不能读懂“助记符”，因此人们写了二进制程序“汇编器来帮忙”\n作用：汇编器读取用\u0026quot;汇编语言\u0026quot;写的程序，然后转成\u0026quot;机器码\u0026quot;。\n3、最早高级编程语言“A-0” 汇编只是修饰了一下机器码，一般来说，一条汇编指令对应一条机器指令，所以汇编码和底层硬件的连接很紧密，汇编器仍然强迫程序员思考底层逻辑。\n1950s，为释放超算潜力，葛丽丝·霍普博士，设计了一个高级编程语言，叫 \u0026ldquo;Arithmetic Language Version 0\u0026rdquo;，一行高级编程语言 可以转成几十条二进制指令。但由于当时人们认为，计算机只能做计算，而不能做程序，A-0未被广泛使用。\n过程：高级编程语言→编译器→汇编码/机器码\n4、开始广泛应用的高级编程语言FORTRAN 1957年由IBM1957年发布，平均来说，FORTRAN 写的程序，比等同的手写汇编代码短 20 倍， FORTRAN 编译器会把代码转成机器码。\n5、通用编程语言——COBOL 1959年，研发可以在不同机器上通用编程语言。\n最后研发出一门高级语言：\u0026ldquo;普通面向商业语言\u0026rdquo;，简称 COBOL\n每个计算架构需要一个 COBOL 编译器，不管是什么电脑都可以运行相同的代码，得到相同结果。\n6、现代编程语言:1960s-2000 1960s起，编程语言设计进入黄金时代。\n1960 ：LGOL, LISP 和 BASIC 等语言\n70年代有：Pascal，C 和 Smalltalk\n80年代有：C++，Objective-C 和 Perl\n90年代有：Python，Ruby 和 Java\n*7、安全漏洞\u0026amp;补丁由来： 在1940年代，是用打孔纸带进行的，但程序出现了问题（也就是漏洞），为了节约时间，只能贴上胶带也就是打补丁来填补空隙，漏洞和补丁因此得名。\n第十二课 编程基础-语句和函数 1、变量、赋值语句 如a=5 ，其中a为可赋值的量，叫做变量。把数字 5 放a里面.这叫\u0026quot;赋值语句\u0026quot;，即把一个值赋给一个变量\n2、if判断 可以想成是 \u0026ldquo;如果 X 为真，那么执行 Y，反之，则不执行Y\u0026rdquo;，if语句就像岔路口，走哪条路取决于条件的真假。\n3、while循环 当满足条件时进入循环，进入循环后，当条件不满足时，跳出循环。\n4、for循环 for循环不判断条件，判断次数，会循环特定次数，不判断条件。for 的特点是，每次结束， i 会 +1\n5、函数 当一个代码很常用的时候，我们把它包装成一个函数（也叫方法或者子程序），其他地方想用这个代码，只需要写函数名即可。\n第13课 算法入门 0、基本慨念 算法：解决问题的基本步骤\n1、选择排序 数组：一组数据\n选择排序的复杂度为O(n²)\n2、大O表示法 大O表示法（算法）的复杂度：算法的输入大小和运行步骤之间的关系，来表示运行速度的量级\n3、归并排序 归并排序的算法复杂度为O（n*log n），n是需要比较+合并的次数，和数组大小成正比，log n是合并步骤所需要的的次数，归并排序比选择排序更有效率\n4、Dijkstra算法 一开始复杂度为O(n²)，后来复杂度为O（nlog n +I），在下图中，n表示节点数，I表示有多少条线。\n第十四集 数据结构 1、数组 下标 数组（Array），也叫列表（list）或向量（Vector），是一种数据结构。为了拿出数组中某个值，我们要指定一个下标（index），大多数编程语言里，数组下标都从 0 开始，用方括号 [ ] 代表访问数组。注意：很容易混淆 \u0026ldquo;数组中第 5 个数\u0026rdquo; 和 \u0026ldquo;数组下标为 5 的数\u0026rdquo;，数组下标为5的数是数组里面的第6个数\n2、字符串 即字母 数字 标点等组成的数组，字符串在内存里以0结尾。\n3、矩阵 可以把矩阵看成数组的数组\n4、结构体 把几个有关系的变量存在一起叫做结构体\n5、指针 指针是一种特殊变量，指向一个内存地址，因此得名。\n6、节点 以指针为变量的结构体叫节点\n7、链表 用节点可以做链表，链表是一种灵活数据结构，能存很多个 节点 (node)，灵活性是通过每个节点 指向 下一个节点实现的。链表可以是循环的也可以是非循环的，非循环的最后一个指针是0\n8、队列 \u0026ldquo;队列\u0026rdquo; 就像邮局排队，谁先来就排前面，这叫 先进先出（FIFO——first in first out），可以把\u0026quot;栈\u0026quot;想成一堆松饼,做好一个新松饼，就堆在之前上面,吃的时候，是从最上面开始\n9、栈 栈是后进先出(LIFO)\n10、树 11、图 如果数据随意连接，有循环，我们称之为图，如下图\n第15课 阿兰图灵 0.可判定性问题 是否存在一种算法，输入正式逻辑语句 输出准确的\u0026quot;是\u0026quot;或\u0026quot;否\u0026quot;答案？\n 阿隆佐邱奇，Lambda算子  美国数学家 阿隆佐·丘奇，开发了一个叫\u0026quot;Lambda 算子\u0026quot;的数学表达系统，证明其不存在。\n 图灵机  只要有足够的规则，状态和纸带，图灵机可以解决一切计算问题。和图灵机一样完备，叫做图灵完备。\n 停机问题  证明图灵机不能解决所有问题。\n 图灵测试  向人和机器同时发信息，收到的回答无法判断哪个是人，哪个是计算机，则计算机达到了智能程度。\n第16课 软件工程 1、对象 当任务庞大，函数太多，我们需要把函数打包成层级，把相关代码都放一起，打包成对象。对象可以包括其他对象，函数和变量。把函数打包成对象的思想叫做“面向对象编程”，面向对象的核心是隐藏复杂度，选择性的公布功能。\n3、API 当团队接收到子团队编写的对象时，需要文档和程序编程接口（API）来帮助合作。API控制哪些函数和数据让外部访问，哪些仅供内部。\n4、集成开发环境（IDE） 程序员用来专门写代码的工具\n6、调试（debug） IDE帮你检查错误，并提供信息，帮你解决问题，这个过程叫调试\n7、文档与注释 文档一般放在一个叫做README的文件里，文档也可以直接写成“注释”，放在源代码里，注释是标记过的一段文字，编译代码时，注释会被忽略。注释的唯一作用是帮助开发者理解代码。\n8、版本控制 版本控制，又称源代码管理。大型软件公司会把会把代码放到一个中心服务器上，叫\u0026quot;代码仓库\u0026quot;，程序员可以把想修改的代码借出，修改后再提交回代码仓库。版本控制可以跟踪所有变化，如果发现bug，全部或部分代码，可以\u0026quot;回滚\u0026quot;到之前的稳定版。\n9、质量控制 测试可以统称“质量保证测试”（QA），作用是找bug\n10、beta alpha beta版软件，即是软件接近完成，但没有完全被测试过，公司有时会向公众发布beta版，以帮助发现问题。alpha是beta前的版本，一般很粗糙，只在内部测试\n第17课 集成电路与摩尔定律（硬件的发展） 1. 分立元件与数字暴政 一开始，计算机都有独立组件构成，叫**\u0026ldquo;分立元件\u0026rdquo;** ， 然后不同组件再用线连在一起，这会导致计算机的构成很复杂，这个问题叫做数字暴政。\n2. 集成电路与仙童半导体 封装复杂性：与其把多个独立部件用电线连起来，拼装出计算机，不如把多个组件包在一起，变成一个新的独立组件。这种新的独立组件就叫集成电路（IC），仙童半导体（用硅做成）让集成电路变成了现实。为了不用焊接或用一大堆线，发明了印刷电路板（PCB），他通过蚀刻金属线的方式把零件连接到一起\n光刻0421 即用光把复杂图案印到材料上。我们把一片薄片状的硅叫做晶圆，通过一系列生产步骤，将晶圆表面薄膜的特定部分除去的工艺叫做光刻。\n摩尔定律 每两年左右，得益于材料和制造技术的发展 ，同样大小的空间，能塞进两倍数量的晶体管。\n进一步小型化会碰到的问题\n1、由于光的波长限制，精度已到极限。\n2、量子隧穿效应：当晶体管非常小，电极之间可能只距离几个原子，电子会跳过间隙，会产生漏电问题\n第18课 操作系统   操作系统(OS)\n 操作系统也是一种程序，不过它有操作硬件的特殊权限，可以运行和管理其他程序。    批处理\n 一个程序运行后会自动运行下一个程序。    外部设备\n 和计算机连着的其他设备，如打印机。    设备驱动程序\n 为了使所写程序和不同类型的电脑兼容，我们需要操作系统充当软件和硬件之间的媒介，更具体地说，操作系统提供程序编程接口(API)来抽象硬件,叫“设备驱动程序”。程序员可以用标准化机制，和输入输出硬件（I/O）交互，    多任务处理\n 操作系统能使多个程序在单个CPU上同时进行的能力，叫做“多任务处理”    虚拟内存\n 多程序处理带来了一个程序所占用内存可能不连续的问题，导致程序员难以追踪一个程序，为了解决这个问题操作系统会把内存地址虚拟化，这叫“虚拟内存”。    动态内存分配\n 虚拟内存的机制使程序的内存大小可以灵活增减，叫做“动态内存分配”，对程序来说，内存看上去是连续的。    内存保护\n 给每个程序分配单独的内存，那当这个程序出现混乱时，它不会影响到其他程序的内存，同时也能有效地防止恶意程序篡改其他程序，这叫做内存保护。    多用户分时操作系统（Multics）\n 用来处理多用户同时使用一台计算机的情况，即每个用户只能用一小部分处理器，内存等，    Unix\n 把操作系统分成两个部分，一个是操作系统的核心部分，如内存管理，多任务和输入/输出处理，这叫做“内核”，第二部分是一堆有用的工具，比如程序和运行库。    第19课 内存和储存介质（存储技术的发展） 纸卡 纸带 问题：读取慢 难修改 难存临时值\n延迟线存储器 利用线的延迟在线里存储数据，又叫顺序存储器或者循环存储器。\n存在问题：1 不能随意调出数据\n​ 2 难以增加内存密度\n磁芯 利用电磁感应原理\n问题 成本高\n磁带 问题 访问速度慢\n磁鼓 与磁带相似\n硬盘 与磁带相似\n内存层次结构 在计算机中，高速昂贵和低速便宜的内存混合使用以取得一个平衡\n软盘 除了磁盘是软的，其他都和硬盘一样，好处是便携\n光盘 原理：光盘表面有很多小坑，造成光的不同反射，光学传感器会捕获到，并解码为 1 和 0\n固定硬盘（SSD） 里面是集成电路\n第 20 课 文件系统 为什么要采用文件格式： 可以随便存文件数据，但按格式存会更方便\nTXT 文本文件 用ASCII解码\nWAV 音频文件 记录的是振幅\nBMP 图片文件： 记录每个像素的红绿蓝 RGB 值\n目录文件： 用来解决多文件问题，存其他文件的信息，比如开头，结尾，创建时间等\n平面文件系统 - Flat File System 文件都在同一个层次，早期空间小，只有十几个文件，平面系统够用\n解决文件紧密的排序造成的问题 \\1. 把空间划分成一块块\n\\2. 文件拆分存在多个块里\n碎片整理 文件的增删改查会不可避免的造成文件散落在各个块里，如果是磁带这样的存储介质就会造成 问题，所以需要碎片整理——计算机把文件内容调换位置\n分层文件系统 - Hierarchical File System： 有不同文件夹，文件夹可以层层嵌套\n第21课 压缩 压缩的好处 能存更多文件，传输也更快\n游程编码 Run-Length Encoding 适合经常出现相同值的文件，以吃豆人游戏为例：\n无损压缩 Lossless compression 没有损失任何数据的压缩。\n霍夫曼树 Huffman Tree和字典编码 Dictionary coders 一种高效的编码模式，以压缩图片为例\n感知编码 Perceptual coding和有损压缩 jpeg 格式 删掉人类无法感知的数据的有损压缩方法，叫做“感知编码”，如音频文件，人类听不到超声波，所以可以舍去，MP3就是音频的一种压缩形式。\n有损压缩的一个例子就是jpeg模式\n时间冗余 Temporal redundancy 一个视频由很多图片构成，其中很多图片的背景一样，这就构成了时间冗余，很多视频编码格式，只存变化的部分。进阶的视频压缩模式会找到帧与帧的相似性，然后打补丁，MPEG-4 是视频压缩的常见标准。\n第 22 课 命令行界面 人机交互 （Human-Computer Interaction）发展史 计算机早期同时输入程序和数据（用纸卡/纸带）\n运行开始直到结束，中间没有人类进行操作，\n原因是计算机很贵，不能等人类慢慢输入，执行完结果打印到纸上 (02:34)\n到1950年代，计算机足够便宜+快，人类和计算机交互式操作变得可行\n为了让人类输入到计算机，改造之前就有的打字机，变成电传打字机 (02:44~05:38)\n到1970年代末，屏幕成本足够低，屏幕代替电传打字机，屏幕成为标配 (07:24)\n人机交互工具的变化 早期输出数据是打印到纸上，而输入是用纸卡/纸带一次性把程序和数据都给进去\nQWERTY 打字机的发展\n电传打字机 Teletype machine\n作用：用于发电报，使两人可以远距离沟通\n命令行界面 Command line interface 输入命令，计算机会给予回应\n第 23课 屏幕与 2D 图形显示   PDP-1 计算机、键盘和显示器分开，屏幕显示临时值\n  阴极射线管 Cathode Ray Tube (CRT)\n  CRT 有两种绘图方式：\n​ 矢量扫描 Vector Scanning\n​ 光栅扫描 Raster Scanning\n02:14 液晶显示器 Liquid Crystal Displays (LCD)，像素 (Pixel)\n随着显示技术的发展，出现了LCD，LCD 也用光栅扫描。在屏幕上显示的清晰的点，叫\u0026quot;像素\u0026quot;\n03:32 字符生成器 Character generator，\n相比于像素，为了减少内存，人们更喜欢使用字符，计算机需要额外硬件，来从内存读取字符，转换成光栅图形 \\N 这样才能显示到屏幕上个硬件叫 \u0026ldquo;字符生成器\u0026rdquo;，基本算是第一代显卡。它内部有一小块只读存储器，简称 ROM，存着每个字符的图形，叫\u0026quot;点阵图案\u0026quot;，\n屏幕缓冲区 Screen buffer\n为了显示，\u0026ldquo;字符生成器\u0026rdquo; 会访问内存中一块特殊区域 这块区域专为图形保留，叫 屏幕缓冲区，程序想显示文字时，修改这块区域里的值就行。\n05:09 矢量命令画图\n概念非常简单：所有东西都由线组成,矢量指令可以画出线，把许多矢量指令存在硬盘上，就能画出很多由线组成的复杂图形。\n06:34 Sketchpad, 光笔 (Light pen)，位图显示和画矩形\nSketchpad ，一个交互式图形界面，用途是计算机辅助设计 (CAD)。\n光笔，就是一个有线连着电脑的触控笔，有了它们，用户可以画出很完美的线条并进行缩放等操作。\n位图显示，内存中的位对应着屏幕上显示的像素。\n想画更复杂的图形，如画矩形，我们需要四个值，起点的x y坐标，高度和宽度。\n 第 24 课 冷战和消费主义 本课概括：政府和消费者推动了计算机的发展\n早期靠政府资金，让技术发展到足够商用，然后消费者购买商用产品继续推动产品发展\n冷战导致美国往计算机领域投入大量资源 (00:00~01:43)\n范内瓦·布什 预见了计算机的潜力，提出假想机器 Memex\n帮助建立 国家科学基金会，给科学研究提供资金 (01:43~03:43)\n1950 年代消费者开始买晶体管设备，收音机大卖\n日本取得晶体管授权后，索尼做了晶体管收音机，为日本半导体行业崛起埋下种子 (03:43~04:29）\n苏联 1961 年把宇航员加加林送上太空，导致美国提出登月\nNASA 预算大大增加，用集成电路来制作登月计算机 (04:29~06:27)\n集成电路的发展实际上是由军事应用大大推进的，阿波罗登月毕竟只有 17 次\n美国造超级计算机进一步推进集成电路 (04:29~07:11)\n美国半导体行业一开始靠政府高利润合同活着，忽略消费者市场，1970年代冷战渐消，行业开始衰败\n很多公司倒闭，英特尔转型处理器 (07:11~08:23)\n第 25 课 个人计算机革命 本集概括：继续讲计算机发展史\n00:18 1970年代初成本下降，个人计算机变得可行\n​ RAM：random-access memory 随机访问存储器\n​ ROM：read-only memory 只读存储器\n01:51 Altair 8800 第一台取得商业成功的个人计算机\n02:32 比尔·盖茨 和 保罗·艾伦写 BASIC 解释器，解释器和编译器类似，区别是解释器运行时转换，而编译器提前转换\n03:45 乔布斯提议卖组装好的计算机，Apple-I 诞生\n04:40 1977年出现3款开箱即用计算机：\n\u0026ldquo;Apple-II\u0026rdquo;，\u0026ldquo;TRS-80 Model I\u0026rdquo;，\u0026ldquo;Commodore PET 2001\u0026rdquo;\n06:26 IBM 意识到个人计算机市场\nIBM PC 发布，采用开放架构，兼容的机器都叫 IBM Compatible (IBM 兼容)\n生态系统产生雪球效应：\n因为用户多，软硬件开发人员更愿意花精力在这个平台\n因为软硬件多，用户也更乐意买 \u0026ldquo;IBM 兼容\u0026rdquo; 的计算机\n08:44 苹果选封闭架构，一切都自己来，只有苹果在非 \u0026ldquo;IBM 兼容\u0026rdquo; 下保持了足够市场份额\n第 26 集：图形用户界面 (GUI) ——GUI是“事件驱动编程”，代码可以在任意时间执行以响应事件，而不像传统代码一样自上而下。\n01:10 图形界面先驱：道格拉斯·恩格尔巴特（Douglas Engelbart）——设想计算机成为未来知识性员工应对问题的工具，并发明了鼠标。\n03:20 1970年成立 帕洛阿尔托研究中心（Palo Alto Research Center）\n03:29 1973年完成 Xerox Alto(施乐奥托) 计算机——创立了桌面，窗口等计算机概念\n06:38 1981年的 Xerox Star system(施乐之星系统)\n​ 创建了文档概念\n07:45 所见即所得 WYSIWYG——施乐打印出来的东西和计算机上一样，并发明了剪切 复制 黏贴等计算机概念\n08:18 史蒂夫·乔布斯去施乐参观\n09:15 1983年推出 Apple Lisa\n09:31 1984年推出 Macintosh 成功\n10:12 1985年推出 Windows 1.0，之后出到 3.1\n10:43 1995年推出 Windows 95 提供新的图形界面，并有Mac没有的新功能，如多任务和受保护内存\n11:08 1995年微软做失败的 Microsoft Bob——类似于房子的设计\n第 27 集：3D 图形 1.线框渲染 Wireframe Rendering 有图形算法 负责把3D坐标\u0026quot;拍平\u0026quot;显示到2D屏幕上，这叫3D投影(包括正交投影和透视投影)，所有的点都从3D转成2D后，就可以用画2D线段的函数来连接这些点，这叫线框渲染，\n2.网格 Mesh 如果我们需要画比立方体复杂的图形，三角形比线段更好，在3D图形学中我们叫三角形\u0026quot;多边形\u0026quot;(Polygons)，一堆多边形的集合叫 网格，网格越密，表面越光滑，细节越多，\n3.三角形更常用因为能定义唯一的平面 4. 扫描线渲染 Scanline Rendering——填充图形的经典算法 ​ 填充的速度叫做填充速率\n​ 抗锯齿——边缘羽化，如果像素在多边形内部，就直接涂颜色，如果多边形划过像素，颜色就浅一些\n5.遮挡 Occlusion 用排序算法，从远到近排列，然后从远到近渲染，这叫画家算法\n6. 深度缓冲 Z Buffering 另一种画遮挡的方法，简而言之，Z-buffering 算法会记录场景中每个像素和摄像机的距离，在内存里存一个数字矩阵，首先，每个像素的距离被初始化为\u0026quot;无限大\u0026quot;，然后 Z-buffering 从列表里第一个多边形开始处理，也就是A，它和扫描线算法逻辑相同，但不是给像素填充颜色，而是把多边形的距离和 Z-Buffer 里的距离进行对比，它总是记录更低的值，因为没对多边形排序，所以后处理的多边形并不总会覆盖前面的。\n07:45 Z Fighting 错误\n采用深度缓冲算法，哪个图形在前将会变化\n07:51 背面剔除 Back Face Culling\n由于游戏角色的头部或地面，只能看到朝外的一面，所以为了节省处理时间，会忽略多边形背面，这很好,但有个bug是 如果进入模型内部往外看，头部和地面会消失\n08:53 表面法线 Surface Normal\n在3D图形上任取一小个区域，它面对的方向叫“表面法线”\n09:33 平面着色 Flat Shading\n基本的照明算法，缺点是使多边形边界明显，看上去不光滑\n09:43 高洛德着色 Gouraud shading, 冯氏着色 Phong Shading\n不只用一种颜色上色\n10:06 纹理映射 Texture Mapping\n纹理在图形学中指外观，纹理有多种算法来达到花哨效果，最经典的是纹理映射。\n纹理映射示意图\n11:24 图形处理单元 GPU, Graphics Processing Unit\n方便并行处理多个图形，并把图形分成一个个小块来处理。\n（28-30：介绍网络的发展和支撑他们的基础原理和技术）\n第 28 集：计算机网络 1. 局域网 Local Area Networks - LAN 计算机近距离构成的小型网络，叫局域网（LAN），以太网是经典的局域网\n2.媒体访问控制地址 Media Access Control address - MAC 用于确认局域网和WiFi传输的对象\n3.载波侦听多路访问 Carrier Sense Multiple Access - CSMA 多台电脑共享一个传输媒介，叫做载波侦听多路访问，共享媒介又称载体，如WiFi的载体是空气，以太网的载体是电线。载体传输数据的速度叫带宽，\n4.指数退避 Exponential Backoff 当多台计算机同时想要传输数据时，就会发生冲突，当计算机检测到冲突 就会在重传之前等待一小段时间，，这一段时间包括固定时间+随机时间，再次堵塞时固定时间将会指数级增加，这叫做指数退避。\n5.冲突域 Collision Domain 载体和其中的设备总称为“冲突域”，为了避免冲突，可以用交换器\n07:08 电路交换 Circuit Switching\n缺点：不灵活且数量昂贵\n6. 报文交换 Message Switching 报文的具体格式简称IP，每一个电脑都会有一个IP地址\n好处，可以用不同路由，通信更可靠也更能容错。\n坏处，当报文比较大的时候，会堵塞线路。解决方法是 将大报文分成很多小块，叫\u0026quot;数据包\u0026quot;，来进行运输，这叫“分组交换”。路由器会平衡与其他路由器之间的负载 以确保传输可以快速可靠，这叫\u0026quot;阻塞控制\u0026quot;\n消息沿着路由跳转的次数 叫\u0026quot;跳数\u0026quot;(hop count)，看到哪条线路的跳数很高，说明出了故障，这叫跳数限制。\n第 29 集：互联网 1.电脑连接互联网的过程 你所用的电脑首先要连接到局域网，家里WiFi路由器连着的所有设备，组成了局域网，局域网再连到广域网（WAN），广域网的路由器一般属于你的互联网服务提供商（ISP），再连更大的WAN，往复几次，最后连到互联网主干。\n2.IP - 互联网协议 - Internet Protocol IP负责把数据包送到正确的计算机\n3. UDP - 用户数据报协议 - User Datagram Protocol UDP负责把数据包传送到正确的程序，有端口号（哪个程序），校验和（数据是否损坏）\n4.校验和 - Checksum UDP校验和只有16位，超过这个数，弃高位。\n5.TCP - 传输控制协议 - Transmission Control Protocol 如果要控制所有数据必须到达，就用传输控制协议\nTCP的特点 1 控制发送的文件按顺序到达\n2 要求接收方确认无误后发送确认码（ACK），确认码的成功率和来回时间可以用来推测网络的拥堵程度，TCP可以根据这个调整传输率。由于这个特点，TCP对时间要求高的程序不适用\n6 DNS - 域名系统 - Domain Name System 计算机访问网站时需要两样，IP地址和端口号，但记数字很难，所以互联网通过域名系统把域名和IP地址一一对应。域名系统是树状结构\n10:47 OSI - 开放式系统互联通信参考模型 - Open System Interconnection\n第 30 集：万维网（WWW） 1.基本单位 万维网在互联网上运行，它的基本单位是页面\n2.超链接 Hyperlinks 点超链接可以去到另一个页面，文字超链接又叫超文本\n超链接工作过程中示意\n3.状态码 状态码代表所访问网页的状态\n4.URL - 统一资源定位器 - Uniform Resource Locator 网页的唯一网址\n5.HTTP - 超文本传输协议 - HyperText Transfer Protocol 6.HTML - 超文本标记语言 - HyperText Markup Language 7.万维网发展史   第一个浏览器和服务器是 Tim Berners-Lee 花了 2 个月在 CERN 写的\n  1991年万维网就此诞生\n  Jerry 和 David 的万维网指南 后来改名成 Yahoo\n  搜索引擎 JumpStation\n  （包括爬虫 索引 用法）\n 搜索引擎 Google\n改进排序方法，按照链接指向的多少来排序\n  8.网络中立性 平等地对待每个数据包\n第 31 集：计算机安全 1. 保密性, 完整性, 可用性 Secrecy, Integrity, Availability 计算机为了安全，要实现三性\n保密性：只有有权限的人，才能读取计算机系统和数据\n完整性：只有有权限的人，才能使用和修改系统和数据\n可用性：有权限的人，可以随时访问计算机系统和数据\n2.Threat Model 威胁模型 为了实现这三个目标，安全专家会从 \\N 抽象层面想象\u0026quot;敌人\u0026quot;可能是谁，这叫\u0026quot;威胁模型分析\u0026quot;，模型会对攻击者有个大致描述：\\N 能力如何，目标可能是什么，可能用什么手段，攻击手段又叫\u0026quot;攻击矢量\u0026quot;，\u0026ldquo;威胁模型分析\u0026quot;让你能为特定情境做准备，不被可能的攻击手段数量所淹没。\n很多安全问题可以总结成两个：\n你是谁？你能访问什么？\n3.身份验证 (Authentication) 的三种方式： What you know, 你知道什么 ex、用户名和密码\nWhat you have, 你有什么\nWhat you are, 你是什么\n4.访问控制 Access Control Bell LaPadula model 不能向上读取，不能向下写入\n5.安全内核 安全内核应该有一组尽可能少的操作系统软件，和尽量少的代码。\n6.独立安全检查和质量验证 最有效的验证手段\n7.隔离 Isolation, 沙盒 Sandbox 优秀的开发人员，应该计划当程序被攻破后，\\N如何限制损害，控制损害的最大程度，并且不让它危害到计算机上其他东西，这叫\u0026quot;隔离\u0026rdquo;。要实现隔离，我们可以\u0026quot;沙盒\u0026quot;程序，这好比把生气的小孩放在沙箱里，他们只能摧毁自己的沙堡，不会影响到其他孩子，方法是给每个程序独有的内存块，其他程序不能动。一台计算机可以运行多个虚拟机，如果一个程序出错，最糟糕的情况是它自己崩溃，或者搞坏它处于的虚拟机。\n第 32 集：黑客与攻击 1.社会工程学 Social Engineering 欺骗别人获得信息，或让人安装易于攻击的系统\n2.钓鱼 Phishing 3.假托 Pretexting 4.木马 Trojan Horses 5.NAND镜像 NAND Mirroring ——来避免输错密码后等待\n6.漏洞利用 Exploit 7. 缓冲区溢出 Buffer Overflow ——一种常见的漏洞利用\n9.边界检查 Bounds Checking和金丝雀 ——防止缓冲区溢出的手段，金丝雀，留出一些不用的空间，当空间变少时，说明有攻击者乱来。\n10. 代码注入 Code Injection 把代码注入到程序中，造成混乱\n11.零日漏洞 Zero Day Vulnerability 当软件制造者不知道软件有新漏洞被发现了，这个漏洞被称为“零日漏洞”\n12.计算机蠕虫 Worms 如果有足够多的电脑有漏洞，让恶意程序可以在电脑间互相传播，这种恶意程序叫做蠕虫\n13.僵尸网络 Botnet 如果黑客掌握足够多电脑，那他们可以组成“僵尸网络”\n第 33 集：加密 1. 加密 - Encryption，解密 - Decryption 01:11 凯撒加密 Caesar cipher——一种替换加密 Substitution cipher，把字母替换成其他字母\n01:59 移位加密 Permutation cipher\n列移位加密 Columnar transposition cipher\n02:37 德国 Enigma 加密机 一种进阶的替换加密，每一次的映射都不同。\n04:54 1977年\u0026quot;数据加密标准\u0026quot; - Data Encryption Standard (DES)\n05:24 2001年\u0026quot;高级加密标准\u0026quot; - Advanced Encryption Standard (AES)\n2. 密钥交换 - Key exchange 用颜色来举例\u0026quot;单向函数\u0026quot;和\u0026quot;密钥加密\u0026quot;的原理\n实例：迪菲-赫尔曼密钥交换 - Diffie-Hellman Key Exchange\n用模幂计算来得到秘钥\n3. 非对称加密 - Asymmetric encryption 以上的例子，双方用一样的秘钥加密和解密信息，叫对称解密。也可以人们用公钥加密信息，只有有私钥的人能解密，或者反过来，这叫非对称解密。最有名的非对称加密算法是RSA\n第 34 集：机器学习与人工智能 以区分飞蛾为例 1.分类 Classification 2.做分类的算法 分类器 Classifier 3.用于分类的值是特征 Feature 4.特征值+种类叫做标记数据 Labeled data 标记数据\n5. 决策边界 Decision boundaries 虚线为决策边界\n6.混淆矩阵 Confusion matrix 右下角表为混淆矩阵\n7.03:49 决策树 Decision tree 8.支持向量机 Support Vector Machines 本质上是用任意线段来切分决策空间，不一定是直线。\n9.人工神经网络 Artificial Neural Network 不用统计学的算法。模拟人类学习的过程，将数据进行加权求和修正等一系列处理。\n10.深度学习 Deep learning 得名原因：有很多的隐藏层\n只能做指定内容的内容\n11. 强AI Strong AI 通用的，和人一样智能的AI叫做强AI，目前没有人能做到。\n12.强化学习 Reinforcement Learning 学习什么管用，什么不管用，自己发现成功的策略，这叫强化学习。\n第 35 集：计算机视觉 1.颜色跟踪算法——跟踪一个像素 2. 检测垂直边缘的算法 物体的边缘有多个色素，不适合颜色跟踪算法。要识别边缘，可以判断其两边像素的颜色差异程度\n3. 核/过滤器 kernel or filter ——用来检测垂直边缘的算法的数学符号，\n5.Prewitt 算子 Prewitt Operators 水平和垂直边缘增强的核叫Prewitt 算子\n\\6. 维奥拉·琼斯 人脸检测 Viola-Jones Face Detection\n7.卷积神经网络 Convolutional Neural Networks 用一层层不同的核来识别复杂场景，用脸来举例，先识别边缘，然后形状，器官\u0026hellip;直至某一层把所有特征堆积在一起，识别出脸之后，可以进一步用其他算法定位面部标志，如眼睛和眉毛具体位置，从而判断心情等信息\n第 36 集：自然语言处理 NLP 1.过程 通过词性 Parts of speech和短语结构规则 Phrase structure rules构建分析树 Parse tree，并结合语言模型 Language Model来实现语音识别 Speech recognition\n2.实现原理： **快速傅立叶变换 Fast Fourier Transform，**把波形转换成频率\n3. 音素 Phonemes 构成单词的声音片段\n4.语音合成 Speech Synthesis 第 37 集：机器人 1.机器人发展中的例子 02:08 法国吃饭鸭 - Digesting Duck, Canard Digerateur\n02:23 土耳其行棋傀儡, 下国际象棋(假的，有人控制)\n02:43 第一台计算机控制的机器出现在1940年代晚期，叫数控机器, Computer Numerical Control(CNC)\n03:32 1960年 Unimate，第一个商业贩卖的 可编程工业机器人\n2.机器人控制的回路 04:08 负反馈回路 negative feedback loop\n05:17 比例-积分-导数控制器 Proportional–Integral–Derivative controller PID 控制器\n通过控制三个值，比例值——实际值和理想值差多少，积分值——一段时间误差的总和，前两者用来修正错误：导数值（微分值）——期望值和实际值之间的变化率，用来避免未来的错误，这也叫预期控制，来控制进程。\n3. 机器人三定律 Three Laws of Robotics ——让机器人不要伤害人类\n第38课 计算机心理学 0、计算机中用到的心理学原理 社会心理学 认知心理学 行为心理学 感知信息学\n1、易用度 指人造物体，比如软件，达到目的的效率有多高\n2、颜色强度排序和颜色排序 人类擅长给颜色强度排序，所以颜色强度很适合现实连续值；而人类不擅长给颜色排序，所以如果数据没有顺序，用不同颜色就很合适，如分类数据。\n3、分组更好记 信息分块会更好记。分块是指把信息分成更小，更有意义的块，如电话号码分块，界面设计分块。\n4、直观功能 直观功能为如何操作物体提供线索，如平板用于推，旋钮用来转，直观功能做得好，用户只需要看一眼就知道怎么搞，而不需要其他东西来说明。ex.门把手让人想拉开门，但如果门需要推开，那这就是个不好的直观功能，不如直接采用平板门来的好。\n5、认出VS回想 和直观功能相关的一个心理学概念是认出和回想，这就是选择题比填空题简单的原因。一般来说，用感觉触发记忆会容易得多，比如文字、图片和声音，所以我们用图标表示功能，如垃圾桶表示回收站。但是，让所有菜单选项好找好记，有时候意味着用的时候会慢一些。这与另一个心理学概念冲突：\u0026ldquo;专业知识”，当你用界面熟悉之后，速度会更快一些，所以 好的界面应该提供多种方法来实现目标，一个好例子是复制粘贴，可以在\u0026quot;编辑\u0026quot;的下拉菜单中找到，也可以用快捷键，两者都不耽误，鱼与熊掌兼得。\n6、让机器有一定的情商以及Facebook的研究 我们也希望电脑能有一点情商，能根据用户的状态做出合适地反应，让使用电脑更加愉快。因为情绪会影响日常活动，比如学习，沟通和决策，情感系统会用传感器，录声音，录像（你的脸）以及生物指标，比如出汗和心率，得到的数据和计算模型结合使用，模型会估算用户的情绪，给最好的回应用户。\n7、用软件修正注视位 心理学研究也表明，如果想说服，讲课，或引起注意 ，眼神注视非常重要。为此，研究人员开发了计算机视觉和图形软件 来纠正头部和眼睛，看视频的人会觉得对方在直视他们\n8、把机器人做得像人 人也喜欢像人的机器人。人机交互，简称HRI，是一个研究人类和计算机交互的领域。\n9、开放性问题 计算机该不该对人类说谎等\n 第 39 集：教育科技 1. 通过调速，暂停等技巧，加强学习效率 2.大型开放式在线课程 - Massive Open Online Courses (MOOC) 3.智能辅导系统 - Intelligent Tutoring Systems 4.判断规则 - Production rule 5.域模型 - Domain Model 判断规则和选择算法，组合在一起成为域模型\n6.贝叶斯知识追踪 Bayesian knowledge tracing 把学生的知识掌握当成隐藏变量，根据学生答题的正确度，更新学生掌握程度的估算值。具体而言，贝叶斯知识追踪有一组方程，会用这四个概率，更新学生模型，评估其掌握程度。\n学生已经学会的概率\n瞎猜的概率\n失误的概率\n做题过程中学会的概率\n7.自适应性程序 一种算法，选择适合学生的问题，让学生学。\n8. 教育数据挖掘 Educational Data Mining 看学生答题时停顿的时间，观察学生停顿和加速视频的时间段，看论坛问题，来评估学生的程度。\n第 40 集：奇点，天网，计算机的未来 1. 普适计算 Ubiquitous Computing 计算机融入生活的方方面面\n2.奇点 Singularity ——智能科技的失控性发展\n3.把工作分为4个象限，讨论自动化带来的影响 4.机器人的存在时间可能长过人类,可以长时间探索宇 ","date":"2022-01-15T18:30:19+08:00","permalink":"https://damaicao.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E9%80%9F%E6%88%90%E8%AF%BE/","title":"计算机科学速成课"},{"content":"算法 二分查找  二分查找法只适用于从有序的数列中进行查找(比如数字和字母等)，将数列排序后再进行查找 二分查找法的运行时间为对数时间o(log2n)，即查找到需要的目标位置最多只需要log2n步，假设从[0,99]的队列(100个数，即n=100)中寻到目标数30，则需要查找步数为log2100，即最多需要查找7次(2^6\u0026lt;100 \u0026lt;2^7)  int left = 0; int right = arr.length - 1; while(left \u0026lt;= right){ int mid = (left + right) / 2; if (arr[mid] == target){ return arr[mid]; } else if (arr[mid] \u0026gt; target){ right = mid - 1; } else{ left = mid + 1; } } return -1; 分治算法   分治法是一种很重要的算法。字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题\u0026hellip;.直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。这个技巧是很多高效算法的基础，如排序算法(快速排序，归并排序)，傅立叶变换(快速傅立叶变换)\u0026hellip;.\n  分治算法可以求解的一些经典问题\n 二分搜索 大整数乘法 棋盘覆盖 合并排序 快速排序 线性时间选择 最接近点对问题 循环赛日程表 汉诺塔    基本步骤\n 分解:将原问题分解为若千个规模较小，相互独立，与原问题形式相同的子问题 解决:若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题 合并:将各个子问题的解合并为原问题的解。    public static void hanoitower(int num, char a, char b, char c){ if (num == 1) { System.out.println(\u0026#34;第一个盘\u0026#34; + a + \u0026#34;-\u0026gt;\u0026#34; + c); } else{ hanoitower(num - 1, a, c, b); System.out.println(\u0026#34;第\u0026#34; + num + \u0026#34;个盘从\u0026#34; + a + \u0026#34;-\u0026gt;\u0026#34; + c); hanoitower(num - 1, b, a, c); } }   动态规划  介绍  **动态规划(Dynamic Programming)**算法的核心思想是:将大问题划分为小问题进行解决，从而一步步获取最优解的处理算法 动态规划算法与分治算法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。 与分治法不同的是，适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的。(即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解) 动态规划可以通过填表的方式来逐步推进，得到最优解.   性质  最优化原理：假设问题的最优解所包括的子问题的解也是最优的，就称该问题具有最优子结构，即满足最优化原理。 无后效性：即某阶段状态一旦确定。就不受这个状态以后决策的影响。也就是说，某状态以后的过程不会影响曾经的状态。仅仅与当前状态有关； 有重叠子问题：即子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到（该性质并非动态规划适用的必要条件，可是假设没有这条性质。动态规划算法同其它算法相比就不具备优势）。   算法的主要思想，利用动态规划来解决。每次遍历到的第i个物品，根据w[i]和v[i]来确定是否需要将该物品放入背包中。即对于给定的n个物品，设v[i]、w[i]分别为第i个物品的价值和重量，c为背包的容量。再令v[i][j]表示在前i个物品中能够装入容量为的背包中的最大价值。   KMP算法  介绍  KMP是一个解决模式串在文本串是否出现过，如果出现过，最早出现的位置的经典算法 Knuth-Morris-Pratt字符串查找算法，简称为“KMP算法”，常用于在一个文本串S内查找一个模式串P的出现位置，这个算法由Donald Knuth、Vaughan Pratt. James H. Morris三人于1977年联合发表，故取这3人的姓氏命名此算法. KMP方法算法就利用之前判断过信息，通过一个next数组，保存模式串中前后最长公共子序列的长度，每次回溯时，通过next数组找到，前面匹配过的位置，省去了大量的计算时间    贪心算法 普里姆算法 最小生成树:给定一个带权的无向连通图,如何选取一棵生成树,使树上所有边上权的总和为最小\n N个顶点，—定有N-1条边 包含全部顶点 N-1条边都在图中 求最小生成树的算法主要是普里姆算法和克鲁斯卡尔算法 普利姆(Prim)算法求最小生成树，也就是在包含n个顶点的连通图中，找出只有(n-1)条边包含所有n个顶点的连通子图，也就是所谓的极小连通子图  克鲁斯卡尔算法  克鲁斯卡尔(Kruskal)算法，是用来求加权连通图的最小生成树的算法。 基本思想:按照权值从小到天的顺序选择n-1条边，并保证这n-1条边不构成回路 具体做法:首先构造一个只含n个顶点的森林，然后依权值从小到大从连通网中选择边加入到森林中，并使森林中不产生回路，直至森林变成一棵树为止  迪杰斯算法 迪杰斯特拉(Dijkstra)算法是典型最短路径算法，用于计算一个结点到其他结点的最短路径。\n它的主要特点是以起始点为中心向外层层扩展(广度优先搜索思想)，直到扩展到终点为止。\n弗洛伊德算法  弗洛伊德算法(Floyd)计算图中各个顶点之间的最短路径 迪杰斯特拉算法用于计算图中某一个顶点到其他顶点的最短路径。 弗洛伊德算法VS迪杰斯特拉算法:  迪杰斯特拉算法通过选定的被访问顶点，求出从出发访问顶点到其他顶点的最短路径; 弗洛伊德算法中每一个顶点都是出发访问点，所以需要将每一个顶点看做被访问顶点，求出从每一个顶点到其他顶点的最短路径。    骑士周游  创建棋盘chessBoa\trd ,是一个二维数组 将当前位置设置为已经访问，然后根据当前位置，计算马儿还能走哪些位置，并放入到一个集合中(ArrayList),最多有8个位置，每走一步，就使用step+1 遍历ArrayList中存放的所有位置，看看哪个可以走通,如果走通，就继续，走不通，就回溯. 判断马儿是否完成了任务，使用step和应该走的步数比较，如果没有达到数量，则表示没有完成任务，将整个棋盘置o 注意:马儿不同的走法[(策略），会得到不同的结果，效率也会有影响(优化)  ","date":"2022-01-11T23:02:23+08:00","permalink":"https://damaicao.github.io/post/%E5%8D%81%E5%A4%A7%E7%AE%97%E6%B3%95/","title":"十大算法"},{"content":"图 为什么用图  线性表局限于一个直接前驱和一个直接后继的关系 树也只能有一个直接前驱也就是文节点 当我们需要表示多对多的关系时，这里我们就用到了图  图是一种数据结构，其中结点可以具有零个或多个相邻元素。\n两个结点之间的连接称为边。结点也可以称为顶点。\n常用概念  顶点 边 路径 无向图:顶点之间的连接没有方向\rimg\r 有向图\rimg\r 带权图  图的表示  邻接矩阵:表示图形中顶点之间相邻关系的矩阵\rimg\r 邻接表  邻接矩阵需要为每个顶点都分配n个边的空间，其实有很多边都是不存在,会造成空间的一定损失. 邻接表的实现只关心存在的边，不关心不存在的边。因此没有空间浪费，邻接表由数组+链表组成 \rimg\r    图的遍历 所谓图的遍历，即是对结点的访问。一个图有那么多个结点，如何遍历这些结点，需要特定策略\n一般有两种访问策略:(1深度优先遍历(⑵)广度优先遍历\n深度优先遍历(Depth First Search,DFS) 基本思想  深度优先遍历，从初始访问结点出发，初始访问结点可能有多个邻接结点，深度优先遍历的策略就是首先访问第一个邻接结点，然后再以这个被访问的邻接结点作为初始结点，访问它的第一个邻接结点，可以这样理解:每次都在访问完当前结点后首先访问当前结点的第一个邻接结点。 我们可以看到，这样的访问策略是优先往纵向挖掘深入，而不是对一个结点的所有邻接结点进行横向访问。 显然，深度优先搜索是一个递归的过程  步骤  访问初始结点v，并标记结点v为已访问。 查找结点v的第一个邻接结点w。 若w存在，则继续执行4，如果w不存在，则回到第1步，将从v的下一个结点继续。 若w未被访问，对w进行深度优先遍历递归（即把w当做另一个v，然后进行步骤123） 查找结点v的w邻接结点的下一个邻接结点，转到步骤3。  广度优先搜索(BFS) 类似于一个分层搜索的过程，广度优先遍历需要使用一个队列以保持访问过的结点的顺序,以便按这个顺序来访问这些结点的邻接结点\n遍历  访问初始结点v并标记结点v为已访问。 结点v入队列 当队列非空时，继续执行，否则算法结束。 出队列，取得队头结点u。 查找结点u的第一个邻接结点w。 若结点u的邻接结点w不存在，则转到步骤3;否则循环执行以下三个步骤:  若结点w尚未被访问，则访问结点w并标记为已访问。 结点w入队列 查找结点u的继w邻接结点后的下一个邻接结点w，转到步骤6。    ","date":"2022-01-11T11:19:09+08:00","permalink":"https://damaicao.github.io/post/%E5%9B%BE/","title":"图"},{"content":"哈希表(散列) 散列表(Hash table，也叫哈希表),是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。\n树 数组存储方式的分析 优点:通过下标方式访问元素，速度快。对于有序数组，还可使用二分查找提高检索速度。 缺点:如果要检索具体某个值，或者插入值(按一定顺序)会整体移动，效率较低\n链式存储方式的分析 优点:在一定程度上对数组存储方式有优化(比如:插入一个数值节点，只需要将插入节点，链接到链表中即可，删除效率也很好)。 缺点:在进行检索时，效率仍然较低，比如(检索某个值，需要从头节点开始遍历)\n树存储方式的分析 能提高数据存储，读取的效率，比如利用二叉排序树(Binary Sort Tree)，既可以保证数据的检索速度，同时也可以保证数据的插入，删除，修改的速度。\n树的常用术语(结合示意图理解)  节点 根点 交节点 子节点 叶子节点(没有子节点的节点 节点的权(节点值) 路径(从root节点找到该节点的路线) 层 子树 树的高度(最大层数 森林:多颗子树构成森林  二叉树 概念  树有很多种,每个节点最多只能有两个子节点的一种形式称为二叉树 二叉树的子节点分为左节点和右节点 如果该二叉树的所有叶子节点都在最后一层,并且结点总数=2^n-1,n为层数,则我们称为满二叉树 如果该二叉树的所有叶子节点都在最后一层或者倒数第二层,而且最后一层的叶子节点在左边连续,倒数第二层的叶子节点在右边连续,我们称为完全二叉树。  遍历  前序遍历:先输出父节点,再遍历左子树和右子树 中序遍历:先遍历左子树,再父节点,右子树 后序遍历:先遍历左子树,再遍历右子树,最后输出父节点 小结:看输出父节点的顺序,就确定是前序,中序,是后序  分析二又树的前序,中序,后序的遍历步骤\n 创建一颗二叉树 前序遍历  先输出当前节点(初始的时候是root节点 如果左子节点不为空,则递归继续前序遍历 如果右子节点不为空,则递归继续前序遍历   中序遍历  如果当前节点的左子节点不为空,则递归中序遍历 输出当前节点 如果当前节点的右子节点不为空,则递归中序遍历   后序遍历  如果当前节点的左子节点不为空,则递归后序遍历 如果当前节点的右子节点不为空,则递归后序遍历 输出当前节点    查找  使用前序,中序,后序的方式来查询指定的结点 前序查找思路  先判断当前结点的no是否等于要查找的 如果是相等,则返回当前结点 如果不等,则判断当前结点的左子节点是否为空,如果不为空,则递归前序查找 如果左递归前序查找,找到结点,则返回,否继续判断,当前的结点的右子节点是否为空,如果不空,则继续向右递归前序查找   中序查找思路  判断当前结点的左子节点是否为空,如果不为空,则递归中序查找 如果找到,则返回,如果没有找到,就和当前结点比较,如果是则返回当前结点,否则继续进行右递归的中序查找 如果右递归中序查找,找到就返回,否则返回null   后序查找思路  判断当前结点的左子节点是否为空,如果不为空,则递归后序查找 如果找到,就返回,如果没有找到,就判断当前结点的右子节点是否为空,如果不为空,则右递归进行后序查找如果找到,就返回 就和当前结点进行,比如,如果是则返回,否则返回null    删除   完成删除结点的操作\n  规定\n 如果删除的节点是叶子节点,则删除该节点 如果删除的节点是非叶子节点,则删除该子树    思路\n 首先先处理 考虑如果树是空树root,如果只有一个root结点,则等价将二叉树置空    然后进行下面步骤\n 因为我们的二叉树是单向的,所以我们是判斷当前结点的子结点是否需要删除结点而不能去判断当前这个结点是不是需要删除结点 如果当前结点的左子结点不为空,并且左子结点就是要删除结点,就将 this.left=null 并且就返回(结束递归删除 如果当前结点的右子结点不为空,并且右子结点就是要删除结点,就将 this.right=null并且就返回(结束递归删除 如果第2和第3步没有删除结点,那么我们就需要向左子树进行递归删除 如果第4步也没有删除结点,则应当向右子树进行递归删除    顺序存储二叉树 从数据存储来看,数组存储方式和树的存储方式可以相互转换,即数组可以转换成树,树也可以转换成数组\n特点\n 顺序二叉树通常只考虑完全二又树 第n个元素的左子节点为2*n+1 第n个元素的右子节点为2*n+2 第n个元素的父节点为(n-1)/2 n表示二叉树中的第几个元素  线索化二叉树  n个结点的二叉链表中含有n+1【公式2n-(n-1)=n+1】个空指针域。利用叉链表中的空指针域,存放指向该结点在某种遍历次序下的前驱和后继结点的指针(这种附加的指针称为\u0026quot;线索\u0026quot;) 这种加上了线索的二叉链表称为线索链表,相应的二叉树称为线索二叉树( Threaded BinaryTree)。根据线索性质的不同,线索二叉树可分为前序线索二叉树、中序线索二叉树和后序线索二叉树三种 一个结点的前一个结点,称为前驱结点 一个结点的后一个结点,称为后继结点  说明:当线索化二叉树后,Node节点的属性left和 right,有如下情况:\n left指向的是左子树,也可能是指向的前驱节点 right指向的是右子树,也可能是指向后继节点 \rimage-20220106155105122\r  赫夫曼树 给定n个权值作为n个叶子结点,构造一棵二又树,若该树的带权路径长度wpl达到最小,称这样的二叉树为最优二叉树,也称为哈夫曼树,还有的书翻译为霍夫曼树。\n赫夫曼树是带权路径长度最短的树,权值较大的结点离根较近\n路径和路径长度:在一棵树中,从一个结点往下可以达到的孩子或孙子结点之间的通路,称为路径。通路中分支的数目称为路径长度。若规定根结点的层数为1,则从根结点到第L层结点的路径长度为L-1\n结点的权及带权路径长度:若将树中结点赋给一个有着某种含义的数值,则这个数值称为该结点的权。\n结点的带权路径长度为:从根结点到该结点之间的路径长度与该结点的权的乘积\n树的带权路径长度:树的带权路径长度规定为所有叶子结点的带权路径长度之和,记为 WPL(weighted path length)权值越大的结点离根结点越近的二叉树才是最优二叉树。\nWPL最小的就是赫夫曼树\n赫夫曼树的步骤\n 从小到大进行排序,将每一个数据,每个数据都是一个节点,每个节点可以看成是颗最简单的二叉树 取出根节点权值最小的两颗二叉树 组成一颗新的二叉树,该新的二叉树的根节点的权值是前面两颗二叉树根节点权值的和 再将这颗新的二叉树,以根节点的权值大小再次排序,不断重复1-2-3-4的步骤,直到数列中,所有的数据都被处理,就得到一颗赫夫曼树  赫夫曼编码  赫夫曼编码也翻译为哈夫曼编码( Huffman Coding),又称霍夫曼编码,是一种编玛方式属于一种程序算法 赫夫曼编码是赫哈夫曼树在电讯通信中的经典的应用之 赫夫曼编码广泛地用于数据文件压缩。其压缩率通常在20%~90%之间 赫夫曼码是可变字长编码(ⅥC的一种。 Huffman-于1952年提出一种编码方法,称之为最佳编码 注意,这个赫夫曼树根据排序方法不同,也可能不太一样,这样对应的赫夫曼编码也不完全样,但是wpl是 样的,都是最小的最后生成的赫夫曼编码的长度是一样如:如果我们让每次生成的新的二又树总是排在权值 相同的二叉树的最后一个,则生成的二叉树为  赫夫曼解码 二叉排序树 既可以保证数据的检索速度,同时也以保证数据的插入,删除,修改的速度\n二叉排序树:BST:( Binary Sort(Search)Tree),对于二叉排序树的任何一个非叶子节点,要求左子节点的值比当前节点的值小,右子节点的值比当前节点的值大。(左\u0026lt;当前\u0026lt;右 ) 特别说明:如果有相同的值,可以将该节点放在左子节点或右子节点\n二叉排序树的删除 注意\n 只有没有子结点 1个子节点 2个子节点  平衡二叉树(AVL树) 左边BST存在的问题分析\n 左子树全部为空,从形式上看,更像一个单链表 插入速度没有影响 查询速度明显降低(因为需要次比较)不能发挥BST的优势,因为每次还需要比较左子树,其查询速度比单链表还慢 解决方案平衡二叉树(AVL)  基本介绍  平衡二叉树也叫平衡二叉搜索树( Self-balancing binary search tree)又被称为AVL树,可以保证查询效率较高 具有以下特点:它是一棵空树或它的左右两个子树的高度差的绝对值不超过1,并且左右两个子树都是一棵平衡二叉树。平衡二叉树的常用实现方法有红黑树AⅥ、替罪羊树、 Treap、伸展树等  左旋转,右旋转,双旋转\n\rimg\r\n多路查找树 多叉树  在二叉树中，每个节点有数据项，最多有两个子节点。如果允许每个节点可以有更多的数据项和更多的子节点，就是多叉树(multiway tree) 2-3-4树就是多叉树，多叉树通过重新组织节点，减少树的高度，能对二叉树进行优化。  B树 B树通过重新组织节点，降低树的高度，并且减少i/o读写次数来提升效率。\n 如图B树通过重新组织节点，隆低了树的高度 文件系统及数据库系统的设计者利用了磁盘预读原理，将一个节点的大小设为等于一个页(页得大小通常为4k)，这样每个节点只需要一次l/o就可以完全载入 将树的度M设置为1024，在600亿个元素中最多只需要4次I/o操作就可以读取到想要的元素,B树()广泛应用于文件存储系统以及数据库系统中  结点度:连接这节点的路的条数\n树的度:就是某个结点的子节点数最多的那个数值\n2-3树 最简单的B树\n特点\n 2-3树的所有叶子节点都在同一层.(只要是B树都满足这个条件) 有两个子节点的节点叫二节点，二节点要么没有子节点，要么有两个子节点. 有三个子节点的节点叫三节点，三节点要么没有子节点，要么有三个子节点.2-3树是由二节点和三节点构成的树。 二节点有两个节点且仅有一个数据项，三节点三个结点有且仅有两个数据项  插入规则\n 2-3树的所有叶子节点都在同一层.(只要是B树都满足这个条件) 有两个子节点的节点叫二节点,二节点要么没有子节点,要么有两个子节点. 有三个子节点的节点叫三节点,三节点要么没有子节点,要么有三个子节点 当按照规则插入一个数到某个节点时,不能满足上面三个要求,就需要拆，先向上拆,，如果上层满,则拆本层，拆后仍然需要满足上面3个条件。 对于三节点的子树的值大小仍然遵守(BST二叉排序树)的规则  B树,B+树和B*树 B-tree树即B树，B即Balanced，平衡的意思。有人把B-tree翻译成B-树，容易让人产生误解。会以为B-树是一种树，而B树又是另一种树。实际上，B-tree就是指的B树。\nB树说明  B树的阶:节点的最多子节点个数。比如2-3树的阶是3，2-3-4树的阶是4 B-树的搜索，从根结点开始，对结点内的关键字(有序)序列进行二分查找,如果命中则结束，否则进入查询关键字所属范围的儿子结点;重复,直到所对应的儿子指针为空，或已经是叶子结点 关键字集合分布在整颗树中，即叶子节点和非叶子节点都存放数据 搜索有可能在非叶子结点结束 其搜索性能等价于在关键字全集内做一次二分查找  \rimg\r\nB+树说明 多路搜索树\n B+树的搜索与B树也基本相同，区别是B+树只有达到叶子结点才命中〈B树可以在非叶子结点命中)，其性能也等价于在关键字全集做一次二分查找 所有关键字都出现在叶子结点的链表中（即数据只能在叶子节点【也叫稠密索引】)，且链表中的关键字(数据)恰好是有序的。 不可能在非叶子结点命中 非叶子结点相当于是叶子结点的索引(稀疏索引)叶子结点相当于是存储(关键字)数据的数据层 更适合文件索引系统 B权对和B+树各有自己的应用场景，不能说B+树完全比B树好，反之亦然.  \rimg\r\nB*树说明 B*树是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针。\n B树定义了非叶子结点关键字个数至少为(2/3)*M，即块的最低使用率为2/3，而B+树的块的最低使用率为B+树的1/2。 第1个特点我们可以看出，B*树分配新结点的概率比B+树要低，空间使用率更高\r在这里插入图片描述\r  ","date":"2022-01-02T21:32:24+08:00","permalink":"https://damaicao.github.io/post/%E6%A0%91/","title":"树"},{"content":"查找算法 介绍  顺序(线性)查找 二分查找/折半查找 插值查找 斐波那契查找  线性查找 for (int i = 0; i \u0026lt; arr.length; i++) { if (arr[i] == value) { return i; } } return -1; 二分查找 返回目标索引\n// if left \u0026gt; right == not find  if (left \u0026gt; right){ return -1; } int mid = (left + right) / 2; int midVal = arr[mid]; if (findVal \u0026gt; midVal){ return binarySearch(arr, mid+1 , right, findVal); } else if (findVal \u0026lt; midVal){ return binarySearch(arr, left, mid-1, findVal); } else{ return mid; } 返回所有目标索引\n// if left \u0026gt; right == not find  if (left \u0026gt; right){ return new ArrayList\u0026lt;Integer\u0026gt;(); } int mid = (left + right) / 2; int midVal = arr[mid]; if (findVal \u0026gt; midVal){ return binarySearch2(arr, mid+1 , right, findVal); } else if (findVal \u0026lt; midVal){ return binarySearch2(arr, left, mid-1, findVal); } else{ ArrayList\u0026lt;Integer\u0026gt; resIndexlist = new ArrayList\u0026lt;Integer\u0026gt;(); int temp = mid - 1; // 左边扫描  while (temp \u0026gt;= 0 \u0026amp;\u0026amp; arr[temp] == findVal) { resIndexlist.add(temp--); } resIndexlist.add(mid); temp = mid + 1; // 右边扫描  while (temp \u0026lt;= arr.length - 1 \u0026amp;\u0026amp; arr[temp] == findVal) { resIndexlist.add(temp++); } return resIndexlist; } 插值查找 if (left \u0026gt; right || findVal \u0026lt; arr[left] || findVal \u0026gt; arr[right]){ return -1; } int mid = left + (right - left) * (findVal - arr[left]) / (arr[right] - arr[left]); int midVal = arr[mid]; if (findVal \u0026gt; midVal) { return insertValueSearch(arr, mid + 1, right, findVal); } else if (findVal \u0026lt; midVal){ return insertValueSearch(arr, left, mid - 1, findVal); } else{ return mid; } ","date":"2022-01-02T19:16:57+08:00","permalink":"https://damaicao.github.io/post/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/","title":"查找算法"},{"content":"Java 学习路线  [Java 学习路线一条龙版 by 程序员鱼皮](liyupi/code-roadmap: 编程学习路线 (github.com))\n 💂 + 💻 = 👴🏽\n[TOC]\n大纲 \rimage-20211127235325557\r\n路线特点  最新，完整一条龙的大厂 Java 学习路线，从入门到入土 同时适用于想全面学习 / 快速求职的同学，可以根据符号来定制自己的专属学习路线 给出目标、学习建议、关键知识点、最优资源以及各类资源推荐（视频、书籍、文档、项目、工具等） 鱼皮自己是 Java 开发者，融入个人自学和从业的经历 + 思考，让路线有灵魂 划分阶段、更有计划，且在最后给出持续学习的方向、探索 Java 程序员发展的无限可能 完全开源，回馈社区，持续更新！  符号表 可以通过路线知识点前的表情字符，根据自己的实际情况选择学习：\n 🌕 所有同学必须学习！！！ 🌖 非常急着找工作，才可不学；目标大厂，必须学习！ 🌗 急着找工作的话，可不学；目标大厂，建议学习 🌘 时间充足的话，再去学 ⭐ 表示推荐资源  写在开头 首先呢，我们要了解 Java 的应用场景和就业方向，看看和自己的学习目的是否一致。\n目前，Java 由于其优秀的特性以及火爆的生态，岗位需求量大，是后台开发、安卓开发、大数据开发的主流编程语言，因此学习资源也很丰富，值得学习！\n有关更多编程语言的选择，大家可以看我的视频了解：https://www.bilibili.com/video/BV1y3411r7pX/\n阶段 0：前期准备  准备好一款在线、随时随地写代码的工具，不用在本地去安装和配置，是初学者的好帮手。  推荐网站 - 菜鸟工具：https://c.runoob.com/compile/10   准备一款记笔记的软件，学编程的过程中老师的思路、自己遇到的问题、解决问题的方法、心得感悟、遇到的好资料，都要记下来哦，好记性不如烂笔头，可以帮助你事半功倍。  推荐本地软件 Typora：https://www.typora.io/（线上可以用 xx 文档） 推荐使用 Markdown 语法编写，鱼皮教程：https://www.bilibili.com/video/BV1no4y1k7YT/   想学好编程，别背代码，要多写，把这句话刻到脑子里。 选视频和找资料的小技巧：多看评论区、多看隔壁评论区、不要看过期的视频。 如何访问 GitHub：https://mp.weixin.qq.com/s/uBFsuThsZ4kdkZgqfX12qA（上面有很多免费的编程学习资源、项目源码，程序员必备）  阶段 1：Java 入门 目标 培养兴趣、快速上手，能运行和编写简单的 Java 程序。\n学完本阶段后，可以试着用 Java 解决一些数学计算问题、编写图书管理系统等桌面端 GUI 程序，甚至是五子棋之类的小游戏。\n🌕 Java 编程基础（45 天） 知识  Java 特点（看不懂没事，别背！） 环境搭建 IDEA 开发工具  新建项目 运行调试 界面配置 插件管理   Java 基础语法  数据类型 流程控制   数组 面向对象  方法 重载 封装 继承 多态   抽象类 接口 枚举 常用类  String 日期时间   集合类 泛型 注解 异常处理 多线程 IO 流 反射  学习建议 初学一门语言时，一定要持续学习，不能中断！\n想要学好编程，一定要多敲代码！建议先跟着书上的例子敲一遍代码，然后试着自主编写代码，并完成课后练习。\n不理解代码也没关系，可以学习 Debug 后，一行一行地打断点执行，查看程序的执行过程。千万不要觉得麻烦，养成习惯后真的能节省很多重复学习的时间。\n经典面试题  为什么重写 equals 还要重写 hashcode？ == 和 equals 比较的区别 为啥有时会出现 4.0 - 3.6 = 0.40000001 这种现象？ final 关键字的作用 介绍 Java 的集合类 ArrayList 和 LinkedList 的区别  资源   视频\n ⭐ 韩顺平 - 零基础 30 天学会 Java：https://www.bilibili.com/video/BV1fh411y7R8（900 多集，顺序安排很合理，每个知识真正的打碎了，通俗、有示例、有实战、有思想）    文档\n  ⭐ 菜鸟教程：https://www.runoob.com/java/java-tutorial.html（可以在线练习）\n  廖雪峰 Java 教程：https://www.liaoxuefeng.com/wiki/1252599548343744\n  IDEA 中文教程：https://github.com/judasn/IntelliJ-IDEA-Tutorial\n  IDEA Mac 快捷键指南，地址：https://www.jianshu.com/p/454c71172c46\n  IDEA Win 常用快捷键，地址：https://www.jianshu.com/p/5de7cca0fefc\n    书籍\n 《Head First Java》    在线游戏\n Codegym：https://codegym.cc/zh（玩玩前几关培养兴趣不错，但后面收费了）    🌖 Java 8（3 天） 知识  Stream API Lambda 表达式 新日期时间 API 接口默认方法  学习建议 Java 8 是如今企业开发中最主流的 Java 稳定版本，在这个版本出现了很多实用的新特性，虽然面试考点不多，但能够提升编程效率，建议学习。\n经典面试题  java 8 有哪些新特性？ HashMap 在 jdk 1.7 和 1.8 的区别？  资源   视频\n ⭐ 宋红康 - 全网最全Java零基础入门教程：https://www.bilibili.com/video/BV1Kb411W75N（只看 Java 8 部分即可）    文档\n ⭐ 菜鸟教程：https://www.runoob.com/java/java8-new-features.html    书籍\n 《Java 8 实战》    工具\n ⭐ 在线编写运行 Java 8：https://www.tutorialspoint.com/compile_java8_online.php    其他\n Java 8 小代码片段：https://github.com/biezhi/30-seconds-of-java8    练手项目  Java 实现简单计算器：https://www.lanqiao.cn/courses/185 Eclipse 实现 Java 编辑器：https://www.lanqiao.cn/courses/287 一本糊涂账：https://how2j.cn/module/104.html Java 五子棋：https://blog.csdn.net/cnlht/article/details/8176130 Java 中国象棋：https://blog.csdn.net/cnlht/article/details/8205733 JAVA GUI 图书馆管理系统：https://github.com/uboger/LibraryManager JAVA 坦克大战小游戏：https://github.com/wangzhengyi/TankWar Swing 编写的俄罗斯方块：https://github.com/HelloClyde/Tetris-Swing 小小记账本：https://github.com/xenv/SmallAccount（适合了解数据库的同学）  尾声 学完了 Java 基础后，有些同学会感到迷茫了啊，感觉好像啥也做不出来，不知道下一步做什么，我这一身的本领该如何施展啊？\n不要慌，也不要急着去学新技术，接下来我们要多用 Java 来写代码了，巩固基础，但是写什么呢？\n当然是数据结构和算法！\n阶段 2：巩固基础 目标 想学好编程，计算机基础知识要学好。\n比如算法，是程序员的灵魂。学好算法有助于我们理解程序、开拓思路，因此也是很多公司面试时考察的关键，在找工作前，还是要刷个上百道算法题目的。\n我们这个阶段的目标是：熟练使用 Java 语言来编写程序，巩固 Java 基础。（那直接用 Java 来写算法题目，一举两得，岂不美哉？）\n此外，建议大家利用零碎时间多去了解 计算机基础知识 ，比如操作系统、计算机网络等，对你后面学习开发框架之类的知识都有帮助。\nJava 基础（30 天） 学习建议 建议大家去阅读 《Java 核心技术卷 1》，这本书堪称经典，是帮助你复习巩固 Java 的不二之选，其中图形界面章节可以选择不看。\n之后可以刷牛客的 Java 练习题，检验自己的水平，我当时刷了两遍 1000 题（每天 30 题，1 个月也就刷完了，二刷会更快！）。虽然都是选择题，但能学到很多 Java 语言的特性、避免写代码时容易犯的错误。\n如果你时间不够，只是想快速找到工作，那么本章节甚至可以完全跳过，后面慢慢弥补即可。\n资源  书籍  ⭐《Java 核心技术卷 1》   练习  ⭐ 牛客题库：https://www.nowcoder.com/intelligentTest    🌖 数据结构与算法 知识   时间 / 空间复杂度分析\n  数据结构\n 数组 字符串 队列 栈 链表 集合 哈希表 树  二叉树 多叉树 字典树      算法\n 排序 双指针 查找 分治 动态规划 递归 回溯 贪心 位运算 DFS BFS 图    学习建议 学算法一定要多思考、多练习！！！\n在复习 Java、巩固基础的过程中，每天可以坚持用 Java 做 2 - 3 道算法题目。\n不用担心看不懂，直接进入 LeetCode 学习板块 LeetBook，提供了免费的教程，文字、图解、动画讲算法、在线练习应有尽有，从 0 开始，跟着学习基础知识、跟着教程刷一些同类题目，培养算法思路。\n之后再由简单到复杂、由通过率高到低，自主刷题，多看题解，举一反三。一定要把自己做过的每道题目代码都自行保存好，定期复习。时间足够的话，也可以试着自己写写题解，在网上分享一下自己的刷题思路，找到自己坚持的动力。\n有条件的朋友也可以试着参与竞赛，没什么门槛，可以帮助你集中精神，而且周赛的题目还是挺友好的~\n经典面试题  LeetCode 精选 100 道：https://leetcode-cn.com/problem-list/2cktkvj/ LeetCode 精选算法 200 题：https://leetcode-cn.com/problem-list/qg88wci/  资源  文章  ⭐ 刷了 1000 多道算法题，一点心得：https://t.1yb.co/oT9q（鱼皮原创）   在线教程  ⭐ LeetCode LeetBook：https://leetcode-cn.com/leetbook/   在线刷题  ⭐ LeetCode：https://leetcode-cn.com/   书籍  ⭐《小灰的漫画算法》 ⭐《剑指 Offer》 《程序员代码面试指南》 图解算法数据结构：https://leetcode-cn.com/leetbook/detail/illustration-of-algorithm/ LeetCode 101（C++）：https://github.com/changgyhub/leetcode_101 LeetCode 题解（C++）：https://github.com/soulmachine/leetcode LeetCode Cookbook（Go 语言）：https://github.com/halfrost/LeetCode-Go   视频  尚硅谷 Java 数据结构与算法：https://www.bilibili.com/video/BV1E4411H73v（难度比面试的要求大一些，适合希望更全面学习的朋友） Leetcode 真题解析：https://www.bilibili.com/video/BV1a54y1b74k   工具  VisuAlgo 数据结构和算法动态可视化：https://visualgo.net/zh 数据结构可视化：https://www.cs.usfca.edu/~galles/visualization/Algorithms.html RegExr：https://www.code-nav.cn/rd/?rid=79550af2601114e9012110711798772b（学习、创建和测试正则表达式的在线可视化工具）   网站  五分钟学算法：https://www.cxyxiaowu.com/    🌘 计算机导论 知识  计算机发展历史 计算机应用领域 计算机发展方向 计算机基本组成 二进制 编程语言发展  学习建议 大学计算机专业的同学一般刚开学就会上这门课，虽说学习它并不会直接提高你的编程技能，但能够让你更了解计算机和编程，从而在一定程度上帮助你培养学习兴趣、确定学习方向。\n自学的话，不用刻意去学习计算机导论，而是可以通过看视频、阅读课外读物的方式慢慢地了解计算机的故事。\n资源  视频  《计算机科学速成课》：https://www.bilibili.com/video/BV1EW411u7th（从底层到上层的计算机知识科普，强烈推荐）   书籍  《半小时漫画计算机》    🌖 操作系统 知识  操作系统的组成 进程、线程 进程 / 线程间通讯方式 进程调度算法 进程 / 线程同步方式 进程 / 线程状态 死锁 内存管理 局部性原理  学习建议 说实话，操作系统这一块知识挺枯燥的。你说说我现在项目都不会做，你又让我看这些理论，是不是想让我头秃？\n我的建议是，可以先利用课余时间看一些网课或者有趣的课外书，对一些操作系统的概念先有个大致的印象，比如进程、线程、死锁，等后面有时间了再系统学习、等到找工作了再去背相关八股文。\n还在校园就跟着学校的进度学习就成，自学的话可以看下《清华操作系统原理》视频，有实力的小伙伴，能看懂大黑书就更好了，但如果看不懂也别担心，这并不影响你后续知识的学习。\n经典面试题  什么是死锁？死锁产生的条件？ 线程有哪几种状态？ 有哪些进程调度算法？ 什么是缓冲区溢出？  资源   视频\n 《清华操作系统原理》：https://www.bilibili.com/video/BV1uW411f72n    书籍\n 《编码》 《30天自制操作系统》 《现代操作系统》（难度较大，不推荐新手看） 《深入理解计算机系统》（难度较大，不推荐新手看） 《 自己动手写操作系统》（国产好书，网上可以下载）    大学课件\n 浙大操作系统：https://github.com/QSCTech/zju-icicles    🌖 计算机网络 知识  网络分层模型 网络传输过程 IP、端口 HTTP / HTTPS 协议 UDP / TCP 协议 ARP 地址解析协议 网络安全 DNS 域名解析  学习建议 很多学习 Java 开发的同学最后都是从事 后端开发 的工作，而计算机网络知识是后端开发的重点。\n和操作系统一样，自学网络可能会很枯燥，建议先看有趣的课外书，比如《图解 HTTP》；或者有趣的视频，比如《计算机网络微课堂》。后面要找工作面试前，再重点去背一些八股文就好了。还在学校的同学好好上课一般就没问题。\n学习基础能帮助自己今后发展更稳定，且更容易接受新知识，所以请不要相信基础无用论。\n经典面试题  计算机网络各层有哪些协议？ TCP 和 UDP 协议的区别？ TCP 为什么需要三次握手和四次挥手？ HTTP 和 HTTPS 协议的区别？  资源   视频\n 《计算机网络微课堂》：https://www.bilibili.com/video/BV1c4411d7jb    书籍\n ⭐《图解 HTTP》 《网络是怎样连接的》 ⭐《图解 TCP / IP》    大学课件\n 浙大计算机网络基础：https://github.com/QSCTech/zju-icicles    尾声 巩固基础要花至少 1 个月的时间，当你读完《Java 核心技术卷1》并且不用查询文档也能熟练地用 Java 做题时，就可以接着往下了。\n阶段 3：Java 企业开发基础 目标 面向薪资编程，学习实际后台开发工作要用的基础技术和框架，并能 独立 做出一个具有完整功能的 Java Web 项目。\n学完这个阶段后，你应该已经能独立开发出大多数常见的后台系统了，比如各种管理系统、商城系统等。\n🌕 MySQL 数据库（7 天） 企业中大部分业务数据都是用关系型数据库存储的，因此数据库是后台开发同学的必备技能，其中 MySQL 数据库是目前的主流，也是面试时的重点。\n知识  基本概念 MySQL 搭建 SQL 语句编写 约束 索引 事务 锁机制 设计数据库表 性能优化  学习建议 其中，SQL 语句编写 和 设计数据库表 这两个能力一定要有！\n比如让你做一个学生管理系统，你要能想到需要哪些表，比如学生表、班级表；每个表需要哪些字段、字段类型。\n这就要求大家多写 SQL、多根据实际的业务场景去练习设计能力。\n经典面试题  MySQL 索引的最左原则 InnoDB 和 MyIsam 引擎的区别？ 有哪些优化数据库性能的方法？ 如何定位慢查询？ MySQL 支持行锁还是表锁？分别有哪些优缺点？  资源  视频  ⭐ 老杜 - mysql入门基础 + 数据库实战：https://www.bilibili.com/video/BV1Vy4y1z7EX（较新、内容相对精炼，有习题） 尚硅谷 - MySQL基础教程：https://www.bilibili.com/video/BV1xW411u7ax（小姐姐讲课，但感觉音质一般）   在线练习  ⭐ SQL 自学网：http://xuesql.cn/ ⭐ SQL 在线运行：https://www.bejson.com/runcode/sql/   文档  SQL - 菜鸟教程：https://www.runoob.com/sql/sql-tutorial.html MySQL - 菜鸟教程：https://www.runoob.com/mysql/mysql-tutorial.html   网站  数据库大全：果创云收录的各种数据库表设计    🌕 开发框架（60 天） Java 之所以能成为主流的企业开发语言，很大一部分原因是它完善的框架生态，用好框架，不仅能够大大提升开发效率，还能提高项目的稳定性、减少维护成本。\n开发框架是后台开发工作中不可或缺的，也是面试考察的重点，一定要好好学！\n不知道 Java 能做什么的朋友们，学完开发框架，就会有答案啦。\n下面给大家推荐的都是企业中应用最多的主流开发框架，知识点比较零碎，就放在一起讲了。\n知识 🌕 Java Web   描述：Java 网页应用开发基础\n  一丢丢前端基础\n  XML\n  JSON\n  Servlet\n  Filter\n  Listener\n  JSP\n  JSTL\n  Cookie\n  Session\n  🌕 Spring 5  描述：Java 轻量级应用框架 IOC AOP 事务  🌕 SpringMVC  描述：Java 轻量级 web 开发框架 什么是 MVC？ 请求与响应 Restful API 拦截器 配置 执行过程  🌕 MyBatis  描述：数据访问框架，操作数据库进行增删改查等操作 增删改查 全局配置 动态 SQL 缓存 和其他框架的整合 逆向工程  🌗 MyBatis Plus  描述：Mybatis 的增强工具，能够简化开发、提高效率 引入 通用 CRUD 条件构造器 代码生成器 插件扩展 自定义全局操作  🌕 SpringBoot 2  描述：简化 Spring 应用的初始搭建以及开发过程，提高效率 常用注解 资源整合 高级特性 本地热部署  🌗 Spring Security  描述：Spring 的安全管理框架 用户认证 权限管理 相关技术：Shiro  🌗 Maven / Gradle  描述：项目管理工具 构建 依赖管理 插件 配置 子父工程 多模块打包构建 Nexus 私服搭建  学习建议 由于技术较多，且框架之间存在一定的联系，因此建议大家看同一系列的视频教程（尚硅谷、狂神说等等都可以），以保证学习内容的连续以及体验上的一致。\n学这些技术的时候，千万不能懒 ！一定要多记笔记，并且跟着老师写代码。原理部分不要太过纠结，先以能跟着敲出代码、写出可运行的项目为主，有些东西做出来也能帮助你更好地理解理论。\n学习顺序挺重要的，建议按我推荐的顺序学，不要一上手就学 Spring Boot。只有先学习下自己整合框架的方法，才能帮你理解 SpringBoot 解决的问题，感受到它的方便和高效。\nMaven / Gradle 当成工具用就好，面试基本不问，跟着框架教程去用就行了，急着找工作的话，先不用花太多时间去深入学。大厂面试问这个的也不多。\n经典面试题  Spring 的 IOC 和 AOP 是什么，有哪些优点？ Spring 框架用到了哪些设计模式？ 介绍 Spring Bean 的生命周期 MyBatis 如何实现延迟加载？ 介绍 MyBatis 的多级缓存机制  资源   视频（按顺序看）\n  ⭐ 尚硅谷最新版 JavaWeb 全套教程：https://www.bilibili.com/video/BV1Y7411K7zz（前端部分最好也看下）\n  ⭐ 尚硅谷 - Spring 5 框架最新版教程（idea版）：https://www.bilibili.com/video/BV1Vf4y127N5\n  ⭐ 尚硅谷 - SpringMVC 2021 最新教程：https://www.bilibili.com/video/BV1Ry4y1574R\n  ⭐ 尚硅谷 - MyBatis 实战教程全套完整版：https://www.bilibili.com/video/BV1mW411M737\n  ⭐ 尚硅谷 - MyBatisPlus 教程：https://www.bilibili.com/video/BV1Ds411E76Y\n  Maven 零基础入门教程：https://www.bilibili.com/video/BV1TW411g7hP（搞不懂 Maven 可以看看）\n  ⭐ 雷丰阳 2021 版 SpringBoot2 零基础入门：https://www.bilibili.com/video/BV19K4y1L7MT\n  尚硅谷 - SpringSecurity 框架教程：https://www.bilibili.com/video/BV15a411A7kP\n    🌘 开发规范（3 天） 开发不规范，同事两行泪。\n开发规范是团队开发中必须遵守的，有利于提高项目的开发效率、降低维护成本。\n知识  代码规范  代码风格 命名 其他规则   代码校验（CheckStyle） 提交规范  学习建议 有时间的话，简单过一遍大厂团队的代码规范手册就好了，以后做项目的时候能想起来的话就去使用，或者从书中、网上查规范文档，再去遵守。\n项目做得多了，自然会养成好的习惯，不用刻意去记（毕竟每个团队规范也不完全相同，背了也没用）。也可以直接利用开发工具自带的一些代码检查插件，帮忙养成好的编码习惯。\n资源   书籍\n ⭐ 阿里巴巴 Java 开发手册：https://developer.aliyun.com/graph/java（搜索《Java开发手册》）    视频\n 华山版《Java开发手册》独家讲解：https://developer.aliyun.com/live/1201    文档\n Google Java Style Guide：https://google.github.io/styleguide/javaguide.html（谷歌 Java 代码规范）    🌕 Git（3 天） 此前大家可能听说过 GitHub，一流的代码开源托管平台。\nGit 和它可不一样，是一个版本控制工具，可以更好地管理和共享项目代码，比如把自己的代码传到 GitHub 上、或者从远程下载。\n无论自己做项目、还是团队开发，Git 都是现在不可或缺的神器。\n知识  区分 Git 和 GitHub 工作区 分支 代码提交、推送、拉取、回退、重置 分支操作 代码合并、解决冲突 标签 cherry-pick Git Flow 相关技术：SVN（比较老）  学习建议 每个命令跟着敲一遍，有个大致的印象，会用即可。\n建议平时大家可以多把自己的代码使用 Git 命令上传到 GitHub 上，用的多了自然就熟悉了。\n经典面试题  如何解决提交冲突？ 提交不小心出现误操作，如何撤销？ 什么是 Git Flow，它有什么好处？  资源   视频\n ⭐【尚硅谷】5h打通Git全套教程丨2021最新IDEA版 https://www.bilibili.com/video/BV1vy4y1s7k6    书籍\n 猴子都能懂的 Git 入门 https://backlog.com/git-tutorial/cn/ ⭐ GitHub 漫游指南 https://github.phodal.com/    文档\n GitHub 官方文档：https://docs.github.com/cn    游戏\n Learning Git Branching：https://learngitbranching.js.org/?locale=zh_CN    🌖 Linux（10 天） 企业中的很多前后台项目都是部署在 Linux 服务器上的，因此很有必要熟悉 Linux 的操作和脚本的编写。\n后面学微服务、学架构都是在多台服务器操作，如果你不熟悉 Linux，会有点吃力。\n知识  Linux 系统安装 环境变量 文件管理 用户管理 内存管理 磁盘管理 进程管理 网络管理 软件包管理 服务管理 日志管理 Linux 内核 常用命令 常用环境搭建 Shell 脚本编程 VIM 的使用  学习建议 多动手实践，建议自己购买一台云服务器，并且在本地搭建 Linux 虚拟机环境。\n一定要自己从 0 开始手敲命令安装软件、部署服务，熟悉整个项目的上线流程。\n每个命令至少要跟着敲一遍，了解它们的作用，并通过自然地练习，熟悉常用的 Linux 命令。\n记不住没关系，用文档查就行了。\n先会用，再理解。一般面试问的 Linux 题目也不会很难，面试前去背一下八股文就没什么问题，感兴趣的话可以去看看 Linux 内核设计。\n经典面试题  如何查看某个进程的运行状态？ 如何在 Linux 上查看 2 G 的大文件？ Linux 软链接和硬链接的区别  资源   视频\n ⭐ 2021 韩顺平 一周学会Linux https://www.bilibili.com/video/BV1Sv411r7vd（基于 CentOS 7.6 版本较新）    书籍\n 《鸟哥的 Linux 私房菜 —— 基础篇》http://cn.linux.vbird.org/linux_basic/linux_basic.php（经典）    文档\n Linux 工具快速教程：https://linuxtools-rst.readthedocs.io（基础、工具进阶、工具参考）    实战\n ⭐ 蓝桥云课 Linux 基础入门：https://www.lanqiao.cn/courses/1 腾讯云动手实验室：https://cloud.tencent.com/developer/labs 阿里云体验实验室：https://developer.aliyun.com/adc/labs/ 阿里云知行实验室：https://start.aliyun.com/ 华为云沙箱实验室：https://lab.huaweicloud.com/    社区\n Linux 中国：https://linux.cn/    工具\n ⭐ Linux 命令搜索：https://wangchujiang.com/linux-command Linux 命令大全手册：https://www.linuxcool.com/ Linux 命令示例：http://linux-commands-examples.com/ 宝塔 Linux 面板：https://www.bt.cn/    🌘 前端基础（14 天） 虽然 Java 程序员面试时基本不会出现前端相关问题，但是在企业中，往往需要前后端程序员配合完成工作。会一些前端，不仅可以提高你们的协作效率，还能提高自己对整个项目的了解和掌控力，甚至能独立开发出一个完整项目！这点也是能给面试加分的。\n知识  HTML CSS JavaScript  Ajax   Vue  学习建议 不需要学习太多的前端技术，熟悉下基础的前端三件套，了解前端是如何向后端发送请求来做数据交互的一般就够了。有时间的话可以学下 Vue ，是比较容易上手的主流前端开发框架，Vue + SpringBoot 还是很香的。\n资源 参见鱼皮原创的前端学习路线：https://mp.weixin.qq.com/s/HbzLEt6NOP9Is9F3GOnbUQ\n练手项目  更多请见本路线阶段 5：[项目源码（50 套）](###项目源码（50 套）) 。\n  HotelSystem：https://github.com/misterchaos/HotelSystem（酒店管理系统 Java,tomcat,mysql,servlet,jsp实现，没有使用任何框架） 超市管理系统：https://github.com/zhanglei-workspace/shopping-management-system Mall4j：https://github.com/gz-yami/mall4j（Spring Boot 电商系统） newbee-mall：https://github.com/newbee-ltd/newbee-mall（基于 Spring Boot 2.X 的全栈电商系统） litemall：https://github.com/linlinjava/litemall（小商城系统，Spring Boot 后端 + Vue 管理员前端 + 微信小程序用户前端 + Vue 用户移动端） forum-java：https://github.com/Qbian61/forum-java（一款用 Java Spring Boot 实现的现代化社区系统）  尾声 学完这个阶段的知识后，一定要再串起来回忆一遍，必须自己独立开发一个 Java Web 项目（量级可以不大，但你学过的技术尽可能地用上），能发布到 Linux 服务器上让其他小伙伴访问就更好了~\n如果你只是对 Java 感兴趣、或者只是想试着自己开发后台，并不是想靠 Java 找工作的话，学到这里就可以了。可以把更多时间投入到你主方向的学习中。\n但如果你是想找 Java 方向的工作，尤其是想进大厂的话，一定要继续努力，用心学习下个阶段的企业开发进阶知识。\n阶段 4：Java 企业开发进阶 目标 学习更多企业级开发技术和编程思想，能够结合多种技术，独立开发出架构合理的完整系统，解决实际问题 。\n要了解为什么需要这个技术？什么时候用这个技术？某个需求该用哪些技术？\n当然，这个阶段的内容有些过于丰富，不是所有的东西都要学，大家可以根据自己的实际情况（时间），有选择地学习。\n🌘 软件工程 软件开发和管理的一些概念、原则、技术、方法、工具和经验。\n知识  软件的本质 软件特性 软件过程 软件开发原则  开闭原则 里氏替换原则 依赖倒置原则 单一职责原则 接口隔离原则 迪米特法则   软件过程模型 敏捷开发 软件开发模型 需求建模 软件设计 UML 体系结构设计 设计模式 软件质量管理 评审 软件质量保证 软件测试  单元测试 集成测试 系统测试 压力测试 部署测试   软件配置管理 软件项目管理 软件项目估算 项目进度安排 风险管理 软件过程改进  成熟度模型    学习建议 大学软件专业的必修课，偏理论，能学到很多企业软件开发的方法，也是对软件开发同学综合能力的提升，有时间的话可以了解下。但对想要快速找工作的同学来说，忽略即可，面试基本不会问。\n资源   书籍\n 《软件工程：实践者的研究方法》：https://book.douban.com/subject/6047742/（经典大黑书，讲的非常全面，但同样完整读下来还是有些难度的） 《软件开发的 201 个原则》：https://book.douban.com/subject/35628886/（工具书，看一遍挺好的）    视频\n 清华大学软件工程：https://www.bilibili.com/video/BV1eE411V7Cr 北京大学软件工程：https://www.bilibili.com/video/BV1Vt411V72G 大连工业大学软件工程：https://www.bilibili.com/video/BV1Ns41177VM    大学课件\n 浙大计算机软件工程：https://github.com/QSCTech/zju-icicles    🌖 设计模式（21 天） 设计模式是软件开发中解决一类问题的通用方法。\n使用设计模式能让你写出更优雅、可维护的代码，也正因如此，很多框架源码都用到了设计模式，你不学很难看懂。\n知识   创建型模式：对象实例化的模式，创建型模式用于解耦对象的实例化过程\n 单例模式 工厂方法模式 抽象工厂 建造者模式 原型模式    结构型模式：把类或对象结合在一起形成一个更大的结构\n 适配器模式 组合模式 装饰器模式 代理模式 享元模式 外观模式 桥接模式    行为型模式：类和对象如何交互，及划分责任和算法\n 迭代器模式 模板方法模式 策略模式 命令模式 状态模式 责任链模式 备忘录模式 观察者模式 访问者模式 中介者模式 解释器模式    学习建议 先理解概念，了解每个设计模式的特点和应用场景，再多加练习，运用到实际项目。\n经典面试题  单例模式有哪些实现方式？有哪些优缺点？请手写其中一种 你用过哪些设计模式，为什么用它？  资源   书籍\n ⭐《图解设计模式》（强烈推荐这本书，正是用 Java 语言实现，图多、有示例代码、有习题和答案，很不错） 《Head First 设计模式》 《大话设计模式》 《设计模式：可复用面向对象软件的基础》（大黑书，有能力的话也可以去读）    视频\n 尚硅谷图解 Java 设计模式：https://www.bilibili.com/video/BV1G4411c7N4    文档\n 菜鸟教程：https://www.runoob.com/design-pattern/design-pattern-tutorial.html 图说设计模式：https://design-patterns.readthedocs.io/zh_CN/latest/    🌕 缓存（14 天） 缓存是高并发系统不可或缺的技术，可以提高系统的性能和并发，因此是后台开发必学的知识点，也是面试重点。\n知识  什么是缓存？ 本地缓存  Caffeine 库   多级缓存 Redis 分布式缓存  数据类型 常用操作 Java 操作 Redis  Spring Boot Redis Template Redisson   主从模型搭建 哨兵集群搭建 日志持久化   缓存（Redis）应用场景  数据共享 单点登录 计数器 限流 点赞 实时排行榜 分布式锁   缓存常见问题  缓存雪崩 缓存击穿 缓存穿透 缓存更新一致性   相关技术：Memcached、Ehcache  学习建议 学会如何简单地使用缓存并不难，和数据库类似，无非就是调用 API 对数据进行增删改查。\n因此，建议先能够独立使用它，了解缓存的应用场景；再学习如何在 Java 中操作缓存中间件，并尝试和项目相结合，提高系统的性能。\n跟着视频教程实操一遍即可，可以等到面试前再去深入了解原理和高级特性。\n经典面试题  Redis 为什么快？ Redis 有哪些常用的数据结构？ Redis RDB 和 AOF 持久化的区别，如何选择？ 如何解决缓存击穿、缓存穿透、雪崩问题？ 如何用 Redis 实现点赞功能，怎么设计 Key / Value？  资源  视频  ⭐ 尚硅谷 - 2021 最新 Redis 6 入门到精通教程：https://www.bilibili.com/video/BV1Rv41177Af（基于 Redis 6 的，推荐）   文档  Redis 命令参考：http://redisdoc.com/ Redis 面试题整理：https://github.com/lokles/Web-Development-Interview-With-Java/blob/main/Redis%E9%97%AE%E9%A2%98.md   书籍  《Redis 实战》（经典）   工具  ⭐ Redis 在线练习：https://try.redis.io/（强烈推荐）    🌖 消息队列（14 天） 消息队列是用于传输和保存消息的容器，也是大型分布式系统中常用的技术，主要解决应用耦合、异步消息、流量削锋等问题。后台开发必学，也是面试重点。\n知识  消息队列的作用 RabbitMQ 消息队列  生产消费模型 交换机模型 死信队列 延迟队列 消息持久化 Java 操作 集群搭建   相关技术：Kafka、ActiveMQ、TubeMQ、RocketMQ  学习建议 和缓存一样，学会如何使用消息队列并不难，无非就是调用 API 去生产、转发和消费消息。\n因此，建议先能够独立使用它，了解消息队列的应用场景；再学习如何在 Java 中操作消息队列中间件，并尝试和项目相结合，感受消息队列带来的好处。\n这里我建议初学者先学习 RabbitMQ，比 Kafka 要好理解一些。跟着视频教程实操一遍即可，可以等到面试前再去深入了解原理和高级特性。\n经典面试题  使用消息队列有哪些优缺点？ 如何保证消息消费的幂等性？ 消息队列有哪些路由模型？ 你是否用过消息队列，解决过什么问题？  资源  视频  ⭐ 尚硅谷 - 2021 最新 RabbitMQ 教程：https://www.bilibili.com/video/BV1cb4y1o7zz（很新很全面）   文档  RabbitMQ 中文文档：http://rabbitmq.mr-ping.com/   书籍  《RabbitMQ 实战：高效部署分布式消息队列》（经典）   工具  ⭐ RabbitMQ 在线模拟器：http://tryrabbitmq.com/    🌖 Nginx（14 天） Nginx 是主流的、开源的、高性能的 HTTP 和反向代理 web 服务器，可以用于挂载网站、请求转发、负载均衡、网关路由等。前后端开发同学都需要学习，在后端开发的面试中有时会考到。\n知识  Nginx 作用 正向代理 反向代理（负载均衡） 常用命令 配置 动静分离（网站部署） 集群搭建 相关技术：HAProxy、Apache  学习建议 Nginx 的基本使用非常简单，甚至不需要看任何的视频，跟着一篇文章就能够用它来提供网站访问能力、实现反向代理。\n但是在企业中，Nginx 的使用往往没那么简单，作为负载均衡、请求转发的重要组件，往往需要针对实际场景去写一些特定的配置。因此建议有时间的话，实践下 Nginx 的配置方法，了解 Nginx 基本的设计思想，对今后自己设计系统时也有帮助。\n经典面试题  Nginx 有哪些作用？ Nginx 为什么支持高并发？ Nginx 有哪些负载均衡策略？ 什么是 Nginx 惊群问题，如何解决它？  资源  视频  ⭐ 尚硅谷 - Nginx 教程由浅入深：https://www.bilibili.com/video/BV1zJ411w7SV（讲的比较全面） ⭐ Nginx 鱼皮 - 手把手带你从0搭建个人网站：https://www.bilibili.com/video/BV1rU4y1J785/ （简单演示 Nginx 部署网站）   文档  Nginx 中文文档：https://www.nginx.cn/doc/index.html   工具  Nginx 配置在线生成：https://www.digitalocean.com/community/tools/nginx?global.app.lang=zhCN    🌗 Netty 网络编程（21 天） 开源的 Java 网络编程框架，用于开发高性能（事件驱动、异步非阻塞）、高可靠的网络服务器和客户端程序。\n很多网络框架和服务器程序都用到了 Netty 作为底层，学好 Netty 不仅可以让我们自己实现高性能服务器，也能更好地理解其他的框架应用、阅读源码。\n知识  IO 模型（BIO / NIO） Channel Buffer Seletor Netty 模型 WebSocket 编程（动手做个聊天室） 相关技术：Vertx（中文文档：http://vertxchina.github.io/vertx-translation-chinese/，比 Netty 简单多了，实在看不懂 Netty 也可以学习下这个）  学习建议 不同于之前学的 SSM 框架，Netty 还是需要一定学习成本的，一方面是国内资源太缺乏，另一方面很多重要的概念（比如 NIO）还是要多动手写代码调试才能理解。\n还是建议先从视频入门，并且不建议在 Netty 上花太多时间，面试的时候一般也就考察一些 Netty 背后的思想（比如 NIO）而非框架本身的语法细节。\n经典面试题  Netty 有哪些优点？ 什么是 NIO？ 介绍 Netty 的零拷贝机制  资源   视频\n  ⭐ 尚硅谷Netty教程：https://www.bilibili.com/video/BV1DJ411m7NR\n  Netty 技术演讲（中文字幕版）：https://www.youtube.com/watch?v=I8yy2Cy7dDI\n    文档\n Netty 4 用户指南：https://www.w3cschool.cn/netty_4_user_guide/    书籍\n 《Netty 实战》    🌖 微服务（60 天） 随着互联网的发展，项目越来越复杂，单机且庞大的巨石项目已无法满足开发、运维、并发、可靠性等需求。\n因此，后台架构不断演进，可以将庞大的项目拆分成一个个职责明确、功能独立的细小模块，模块可以部署在多台服务器上，相互配合协作，提供完整的系统能力。\n换言之，想做大型项目，这块儿一定要好好学！\n知识 Dubbo  架构演进 RPC Zookeeper 服务提供者 服务消费者 项目搭建 相关技术：DubboX（对 Dubbo 的扩展）  🌖 微服务  微服务概念 Spring Cloud 框架  子父工程 服务注册与发现 注册中心 Eureka、Zookeeper、Consul Ribbon 负载均衡 Feign 服务调用 Hystrix 服务限流、降级、熔断 Resilience4j 服务容错 Gateway（Zuul）微服务网关 Config 分布式配置中心 分布式服务总线 Sleuth + Zipkin 分布式链路追踪   Spring Cloud Alibaba  Nacos 注册、配置中心 OpenFeign 服务调用 Sentinel 流控 Seata 分布式事务    接口管理  Swagger 接口文档 Postman 接口测试 相关技术：YApi、ShowDoc  学习建议 时间不急的话，建议先从 Dubbo 学起，对分布式、RPC、微服务有些基本的了解，再去食用 Spring Cloud 全家桶会更香。学完 Spring Cloud 全家桶后，再去学 Spring Cloud Alibaba 就很简单了。\n这部分内容的学习，原理 + 实践都很重要，也不要被各种高大上的词汇唬住了，都是上层（应用层）的东西，基本没有什么算法，跟着视频教程学，其实还是很好理解的。\n分布式相关知识非常多，但这里不用刻意去背，先通过视频教程实战使用一些微服务框架，也能对其中的概念有基本的了解。\n大厂面试的时候很少问 Spring Cloud 框架的细节，更多的是微服务以及各组件的一些思想，比如网关的好处、消息总线的好处等。\n经典面试题  什么是微服务，有哪些优缺点？ 什么是注册中心，能解决什么问题？  资源   视频\n  ⭐ 尚硅谷 Dubbo 教程：https://www.bilibili.com/video/BV1ns411c7jV\n  ⭐ 尚硅谷 SpringCloud（H版\u0026amp;alibaba）框架开发教程（微服务分布式架构）：https://www.bilibili.com/video/BV18E411x7eT（把国外的 Spring Cloud 和国内的 Spring Cloud Alibaba 结合在一起对比着去讲，主流技术栈、知识点都讲到了，真心不错！）\n    文档\n Apache Dubbo 官方文档：https://dubbo.apache.org/zh/ Spring Cloud Alibaba 官方文档：https://github.com/alibaba/spring-cloud-alibaba/blob/master/README-zh.md ⭐ Swagger 教学文档：https://doc.xiaominfo.com/（跟着快速开始直接用就好了）    🌖 容器（7 天） 将应用和环境进行封装，相互隔离、独立部署、便于移植，提高安全性、提高开发和维护效率。\n便于实现微服务、持续集成和交付。\n知识  🌖 Docker  容器概念 镜像 部署服务 Dockerfile Docker Compose Docker Machine Docker Swarm 多阶段构建   🌘 K8S（Kubernetes）  K8S 架构 工作负载  资源类型 Pod Pod 生命周期 Pod 安全策略   K8S 组件 K8S 对象 部署应用 服务  Ingress   Kubectl 命令行 集群管理   相关技术：Apache Mesos、Mesosphere  学习建议 业务上云是趋势，但是对于开发同学来说，会用 Docker / K8S 部署项目和服务就行。实际工作中，企业一般都有现成的平台直接用，面试考察的也不多，不用花太多时间。\n经典面试题  什么是容器？ 使用 Docker 有哪些好处？ 如何快速启动多个 Docker 节点？  资源   视频\n ⭐【狂神说】Docker 最新超详细版教程通俗易懂：https://www.bilibili.com/video/BV1og4y1q7M4 K8S 视频教程：https://www.bilibili.com/video/BV1K5411N7j8    书籍\n 《深入浅出 Docker》：https://www.zhihu.com/pub/reader/119632192    文档\n Docker — 从入门到实践：https://vuepress.mirror.docker-practice.com/ 菜鸟教程 Docker：https://www.runoob.com/docker/docker-tutorial.html 国外 Docker 官方文档：https://docs.docker.com/get-started/    网站\n Docker 中文社区：https://www.docker.org.cn/（强烈推荐，有很多 Docker 技术文章和学习笔记） Docker Blog：https://www.docker.com/blog/（国外 Docker 技术博客）    镜像源\n Docker Hub：https://hub.docker.com 腾讯软件源：http://mirrors.tencent.com/#/index 阿里云 Docker 仓库：https://cr.console.aliyun.com/    🌗 CI / CD（3 天） 持续集成 / 持续交付，贯穿整个研发到项目上线的过程，提高效率。\n大公司一般都有自己的 CI / CD 平台。\n知识  什么是 CI / CD CI / CD 有什么好处 使用任一 CI / CD 平台 相关技术：Jenkins、GitLab、微信云托管  学习建议 了解它是什么，并且实战使用任一 CI / CD 平台，感受它和传统开发运维到底有什么不同，就足够了。其实很简单，不要花太多时间。\n真正要自己去搭建的时候，跟着官方文档来就行。\n资源   视频\n ⭐【狂神说】CI/CD到底是什么？十分钟理解企业级DevOps：https://www.bilibili.com/video/BV1zf4y127vu（讲的非常棒！带你快速理解 CI / CD 的作用和部分原理） 尚硅谷 - Jenkins 持续集成工具教程：https://www.bilibili.com/video/BV1GW411w7pn（实在要用到 Jenkins 再去学）    文档\n Jenkins 官方文档：https://www.jenkins.io/zh/ （有很多案例，要用的时候查一下就行了）    实战平台\n ⭐ 微信云托管：https://cloud.weixin.qq.com/cloudrun（直播演示过，鱼皮后面会给大家出视频教程） 前端托管 Webify：https://cloud.tencent.com/product/webify（鱼皮给大家出过视频教程的 https://www.bilibili.com/video/BV11V411p7vf/）    练手项目  更多请见本路线阶段 5：[项目源码（50 套）](###项目源码（50 套）) 。\n   mall-learning：https://github.com/macrozheng/mall-learningmall（学习教程，架构、业务、技术要点全方位解析）\n  miaosha：https://github.com/qiurunze123/miaosha （秒杀系统设计与实现）\n  Mall：https://github.com/macrozheng/mall（包括前台商城系统及后台管理系统，基于 SpringBoot+MyBatis 实现）\n  Spring-Cloud-Admin：https://github.com/wxiaoqi/Spring-Cloud-AdminCloud-Admin（基于 Spring Cloud 微服务化开发平台，具有统一授权、认证的后台管理系统）\n  paascloud-master：https://github.com/paascloud/paascloud-master（基于 spring cloud + vue + oAuth2.0，前后端分离商城系统）\n  mall-swarm：https://github.com/macrozheng/mall-swarm（一套微服务商城系统，采用了 Spring Cloud Greenwich、Spring Boot 2、MyBatis、Docker、Elasticsearch 等核心技术，同时提供了基于 Vue 的管理后台方便快速搭建系统）\n  SecKill：https://github.com/hfbin/Seckill（基于 SpringBoot+Mybatis+Redis+RabbitMQ 秒杀系统）\n  jeecg-boot：https://github.com/zhangdaiscott/jeecg-boot（低代码开发平台）\n  PassJava-Platform：https://github.com/Jackson0714/PassJava-Platform（一款面试刷题的 Spring Cloud 开源系统）\n  尾声 看到这里，相信你已经感叹：编程语言一辈子学不完了！\n但是，不用担心，通过对这么多知识点的学习，相信你已经有了一定的积累，也不知不觉地锻炼了自主学习能力、资源检索能力、代码阅读能力、问题解决能力，之后的学习会越来越轻松。\n接下来，可以试着用你学到的技术来解决实际的问题，自主从 0 开始做一些项目，保持编程手感。\n阶段 5：项目实战 目标 综合所学技术从 0 到 1 开发和上线一个全面、有特色的、可以写进简历的个人项目。\n学习建议 其实在之前的框架学习视频中应该就做过几个项目了，但相对不够完整和体系化。\n有想法的同学可以做任何自己想做的项目，推荐参加一些作品类竞赛，练手、拿奖、收获项目经历一举三得。\n暂时没想法的朋友，建议先跟着专门带做项目的视频教程做 1 - 2 套 Java 完整项目，一定要从 0 到 1 自己手写！\n有能力的朋友也可以试着用 GitHub 上的源码来学习啦~\n做一个完整的项目的确很不容易，建议大家根据自己的 时间、兴趣 选择 较新的、有配套源码的 教程，保持耐心。\n如何选择编程学习资源，可以看下我的原创文章：https://mp.weixin.qq.com/s/mlMql9RJCd7THt6rpGb8UA\n下面推荐一些优质的、较新的项目实战视频教程 + 50 套项目源码。\n视频教程   尚硅谷 - 谷粒学院 - 微服务 + 全栈 - 在线教育实战项目：https://www.bilibili.com/video/BV1dQ4y1A75e（全栈项目，前后端讲得都很全面）\n  尚硅谷 - 尚筹网 - Java项目实战开发教程 - SSM 框架 + 微服务架构：https://www.bilibili.com/video/BV1bE411T7oZ（500 多集，包含完整的用户权限管理，功能丰富、讲得很细致全面）\n  黑马 - 24 小时搞定 Java 毕设电商项目：https://www.bilibili.com/video/BV13f4y1r7fS\n  黑马程序员 Java 项目《传智健康》，超完整的企业级医疗行业项目：https://www.bilibili.com/video/BV1Bo4y117zV\n  黑马程序员 Java 项目《万信金融》企业级开发实战，互联网金融行业解决方案：https://www.bilibili.com/video/BV1Ub4y1f7rk\n  黑马程序员 Java 项目 SaaS 移动办公完整版《iHRM 人力资源管理系统》，跨行业 SaaS 办公整合性解决方案：https://www.bilibili.com/video/BV18A411L7UX\n  黑马程序员 Java 大型分布式微服务闪聚支付项目，Java 移动支付全生态系统：https://www.bilibili.com/video/BV17v411V79c\n  黑马程序员 Java 项目《好客租房》：https://www.bilibili.com/video/BV1sZ4y1F7PD\n  常用类库 工具  Guava：谷歌开发的 Java 工具库（https://github.com/google/guava） Apache Commons：各类工具库，比如 commons-lang、commons-io、commons-collections 等（https://github.com/apache/commons-lang） Hutool：Java 工具集库（https://github.com/looly/hutool） Lombok：Java 增强库（https://github.com/projectlombok/lombok） Apache HttpComponents Client：HTTP 客户端库（https://github.com/apache/httpcomponents-client） OkHttp：适用于 JVM、Android 等平台的 Http 客户端（https://github.com/square/okhttp） Gson：谷歌的 JSON 处理库（https://github.com/google/gson） Jcommander：Java 命令行参数解析框架（https://github.com/cbeust/jcommander） Apache PDFBox：PDF 操作库（https://github.com/apache/pdfbox） EasyExcel：阿里的 Excel 处理库（https://github.com/alibaba/easyexcel） Apache POI：表格文件处理库（https://github.com/apache/poi）  测试  JUnit：Java 测试框架（https://github.com/junit-team/junit4） Mockito：Java 单元测试 Mock 框架（https://github.com/mockito/mockito） Selenium：浏览器自动化框架（https://github.com/SeleniumHQ/selenium） htmlunit：Java 模拟浏览器（https://github.com/HtmlUnit/htmlunit） TestNG：Java 测试框架（https://github.com/cbeust/testng） Jacoco：Java 代码覆盖度库（https://github.com/jacoco/jacoco）  其他  cglib：字节码生成库（https://github.com/cglib/cglib） Arthas：Java 诊断工具（https://github.com/alibaba/arthas） config：针对 JVM 的配置库（https://github.com/lightbend/config） Quasar：Java 纤程库（https://github.com/puniverse/quasar） drools：Java 规则引擎（https://github.com/kiegroup/drools） Caffeine：Java 高性能缓存库（https://github.com/ben-manes/caffeine） Disruptor：高性能线程间消息传递库（https://github.com/LMAX-Exchange/disruptor） Knife4j：Swagger 文档增强（https://doc.xiaominfo.com/） Thumbnailator：Java 缩略图生成库（https://github.com/coobird/thumbnailator） Logback：Java 日志库（https://github.com/qos-ch/logback） Apache Camel：消息传输集成框架（https://github.com/apache/camel） Quartz：定时任务调度库（https://github.com/quartz-scheduler/quartz） Apache Mahout：机器学习库（https://github.com/apache/mahout） Apache OpenNLP：NLP 工具库（https://github.com/apache/opennlp） RxJava：JVM 反应式编程框架（https://github.com/ReactiveX/RxJava） JProfiler：性能分析库（https://www.ej-technologies.com/products/jprofiler/overview.html） jsoup：HTML 文档解析库（https://jsoup.org/） webmagic：Java 爬虫框架（https://github.com/code4craft/webmagic/）  IDEA 插件 综合实用性、易用性、流行度、维护频率，精选了以下插件，简单分类为天地二品。\n精选地品插件 简单好用、增强功能\n  Background Image Plus +\n 描述：给编辑器设置背景图片（小姐姐图片） 官网：https://plugins.jetbrains.com/plugin/11247-background-image-plus-    Chinese Language Pack\n 描述：中文支持 官网：https://plugins.jetbrains.com/plugin/13710-chinese-simplified-language-pack\u0026mdash;-    Translation\n 描述：翻译插件，鼠标选中文本，点击右键即可自动翻译成多国语言。 官网：https://plugins.jetbrains.com/plugin/8579-translation/    Key Promoter X\n 描述：快捷键提示插件。当你执行鼠标操作时，如果该操作可被快捷键代替，会给出提示，帮助你自然形成使用快捷键的习惯，告别死记硬背。 官网：https://plugins.jetbrains.com/plugin/9792-key-promoter-x/    Rainbow Brackets\n 描述：给括号添加彩虹色，使开发者通过颜色区分括号嵌套层级，便于阅读 官网：https://plugins.jetbrains.com/plugin/10080-rainbow-brackets/    CodeGlance\n 描述：在编辑器右侧生成代码小地图，可以拖拽小地图光标快速定位代码，阅读行数很多的代码文件时非常实用。 官网：https://plugins.jetbrains.com/plugin/7275-codeglance/    WakaTime\n 描述：代码统计和跟踪插件 官网：https://plugins.jetbrains.com/plugin/7425-wakatime    Statistic\n 描述：代码统计 官网：https://plugins.jetbrains.com/plugin/4509-statistic    精选天品插件 提高开发效率和代码质量\n  String Manipulation\n 描述：字符串快捷处理 官网：https://plugins.jetbrains.com/plugin/2162-string-manipulation    Tabnine AI Code Completion\n 描述：使用 AI 去自动提示和补全代码，比 IDEA 自带的代码补全更加智能化 官网：https://plugins.jetbrains.com/plugin/12798-tabnine-ai-code-completion-js-java-python-ts-rust-go-php\u0026ndash;more    GsonFormatPlus\n 描述：根据 json 生成对象 官网：https://plugins.jetbrains.com/plugin/14949-gsonformatplus    JUnitGenerator V2.0\n 描述：自动生成单元测试 官网：https://plugins.jetbrains.com/plugin/3064-junitgenerator-v2-0    RestfulTool\n 描述：辅助 web 开发的工具集 官网：https://plugins.jetbrains.com/plugin/14280-restfultool    SequenceDiagram\n 描述：自动生成方法调用时序图 官网：https://plugins.jetbrains.com/plugin/8286-sequencediagram    CheckStyle-IDEA\n 描述：自动检查 Java 代码规范 官网：https://plugins.jetbrains.com/plugin/1065-checkstyle-idea    Alibaba Java Coding Guidelines\n 描述：代码规范检查插件 官网：https://plugins.jetbrains.com/plugin/10046-alibaba-java-coding-guidelines    SonarLint\n 描述：帮助你发现和修复代码的错误和漏洞 官网：https://plugins.jetbrains.com/plugin/7973-sonarlint    MybatisX\n 描述：MyBatis 增强插件，支持自动生成 entity、mapper、service 等常用操作的代码，优化体验 官网：https://plugins.jetbrains.com/plugin/10119-mybatisx    美化类   Extra Icons\n 描述：图标美化插件，支持更多文件类型 官网：https://plugins.jetbrains.com/plugin/11058-extra-icons    Chinese Language Pack\n 描述：中文支持 官网：https://plugins.jetbrains.com/plugin/13710-chinese-simplified-language-pack\u0026mdash;-    Grep Console\n 描述：自定义设置控制台输出颜色 官网：https://plugins.jetbrains.com/idea/plugin/7125-grep-console    Material Theme UI\n 描述：美观的主题 官网：https://plugins.jetbrains.com/plugin/8006-material-theme-ui    Nyan Progress Bar\n 描述：进度条美化 官网：https://plugins.jetbrains.com/plugin/8575-nyan-progress-bar    activate-power-mode\n 描述：打字特效 官网：https://plugins.jetbrains.com/plugin/8330-activate-power-mode    Power Mode II\n 描述：打字特效插件升级版 官网：https://plugins.jetbrains.com/plugin/8251-power-mode-ii    Rainbow Brackets\n 描述：给括号添加彩虹色，使开发者通过颜色区分括号嵌套层级，便于阅读 官网：https://plugins.jetbrains.com/plugin/10080-rainbow-brackets/    Background Image Plus +\n 描述：给编辑器设置背景图片 官网：https://plugins.jetbrains.com/plugin/11247-background-image-plus-    代码生成类   Codota AI Autocomplete for Java and JavaScript\n 描述：使用 AI 去自动提示和补全代码，比 IDEA 自带的代码补全更加智能化 官网：https://plugins.jetbrains.com/plugin/7638-codota-ai-autocomplete-for-java-and-javascript    Tabnine AI Code Completion\n 描述：使用 AI 来自动提示和补全代码，比 IDEA 自带的代码补全更加智能化 官网：https://plugins.jetbrains.com/plugin/12798-tabnine-ai-code-completion-js-java-python-ts-rust-go-php\u0026ndash;more    UUID Generator\n 描述：生成随机的 UUID 官网：https://plugins.jetbrains.com/plugin/8320-uuid-generator    Randomness\n 描述：生成随机值 官网：https://plugins.jetbrains.com/plugin/9836-randomness    .ignore\n 描述：生成不同语言的版本控制忽略文件 官网：https://plugins.jetbrains.com/plugin/7495\u0026ndash;ignore    Auto filling Java call arguments\n 描述：通过快捷键自动补全函数的调用参数 官网：https://plugins.jetbrains.com/plugin/8638-auto-filling-java-call-arguments/    GenerateAllSetter\n 描述：快速生成调用对象 setter 方法的代码 官网：https://plugins.jetbrains.com/plugin/9360-generateallsetter    GenerateSerialVersionUID\n 描述：一键为实现 Serializable 接口的类生成 SerialVersionUID 官网：https://plugins.jetbrains.com/plugin/185-generateserialversionuid/    GsonFormatPlus\n 描述：根据 json 生成对象 官网：https://plugins.jetbrains.com/plugin/14949-gsonformatplus    Lombok\n  描述：配合 Lombok 依赖及注解使用，能够大大减少 Java 对象的代码量。IDEA 已自带，无需安装。\n  官网：https://plugins.jetbrains.com/plugin/6317-lombok/\n    Easy Code\n 描述：根据数据库表生成 Java entity、dao、mapper、service、controller 等代码 官网：https://plugins.jetbrains.com/plugin/10954-easy-code    Easy Javadoc\n 描述：快速生成 Javadoc 文档 官网：https://plugins.jetbrains.com/plugin/12977-easy-javadoc    JavaDoc\n 描述：生成 Javadoc 文档 官网：https://plugins.jetbrains.com/plugin/7157-javadoc    Json2Pojo\n 描述：根据 JSON 生成 POJO，根据 POJO 生成 JSON 官网：https://plugins.jetbrains.com/plugin/8533-json2pojo    JUnitGenerator V2.0\n 描述：自动生成单元测试 官网：https://plugins.jetbrains.com/plugin/3064-junitgenerator-v2-0    Jindent - Source Code Formatter\n 描述：根据自定义模板来生成 javadoc 注释 官网：https://plugins.jetbrains.com/plugin/8309-jindent\u0026ndash;source-code-formatter    MybatisX\n 描述：MyBatis 增强插件，支持自动生成 entity、mapper、service 等常用操作的代码，优化体验 官网：https://plugins.jetbrains.com/plugin/10119-mybatisx    MyBatisCodeHelperPro\n 描述：MyBatis 增强插件，支持自动生成 entity、mapper、service 等常用操作的代码（收费） 官网：https://plugins.jetbrains.com/plugin/9837-mybatiscodehelperpro    功能提效类 源码阅读  Call Graph  描述：生成调用关系图，便于查看源码 官网：https://plugins.jetbrains.com/plugin/12304-call-graph   Jump to Line  描述：支持跳转到任意行进行调试 官网：https://plugins.jetbrains.com/plugin/14877-jump-to-line   SequenceDiagram  描述：自动生成方法调用时序图 官网：https://plugins.jetbrains.com/plugin/8286-sequencediagram   jclasslib Bytecode Viewer  描述：字节码查看器 官网：https://plugins.jetbrains.com/plugin/9248-jclasslib-bytecode-viewer   BrowseWordAtCaret  描述： 快速在相同单词间进行跳转 官网：https://plugins.jetbrains.com/plugin/201-browsewordatcaret   CodeGlance  描述：在编辑器右侧生成代码小地图，可以拖拽小地图光标快速定位代码，阅读行数很多的代码文件时非常实用。 官网：https://plugins.jetbrains.com/plugin/7275-codeglance/    代码规范  CheckStyle-IDEA  描述：自动检查 Java 代码规范 官网：https://plugins.jetbrains.com/plugin/1065-checkstyle-idea   Alibaba Java Coding Guidelines  描述：代码规范检查插件 官网：https://plugins.jetbrains.com/plugin/10046-alibaba-java-coding-guidelines   SonarLint  描述：帮助你发现和修复代码的错误和漏洞 官网：https://plugins.jetbrains.com/plugin/7973-sonarlint   FindBugs-IDEA  描述：帮你找出代码中潜藏的 Bug 官网：https://plugins.jetbrains.com/plugin/3847-findbugs-idea   MetricsReloaded  描述：代码复杂度分析 官网：https://plugins.jetbrains.com/plugin/93?pr=idea    格式处理   CamelCase\n 描述：快速字符串格式转换工具，如驼峰式 官网：https://plugins.jetbrains.com/plugin/7160-camelcase    Json Parser\n 描述：验证和格式化 Json 字符串的工具 官网：https://plugins.jetbrains.com/plugin/10650-json-parser    Properties to YAML Converter\n 描述：把 Properties 文件的格式转为 YAML 格式 官网：https://plugins.jetbrains.com/plugin/8000-properties-to-yaml-converter    String Manipulation\n 描述：字符串快捷处理 官网：https://plugins.jetbrains.com/plugin/2162-string-manipulation    代码统计  WakaTime  描述：代码统计和跟踪插件 官网：https://plugins.jetbrains.com/plugin/7425-wakatime   Statistic  描述：代码统计 官网：https://plugins.jetbrains.com/plugin/4509-statistic    代码检索  OnlineSearch  描述：选择文本后支持不同搜索引擎进行搜索 官网：https://plugins.jetbrains.com/plugin/8298-onlinesearch/   CodeSearch  描述：快捷地打开搜索引擎进行搜索 官网：https://plugins.jetbrains.com/plugin/12578-codesearch    其他   Leetcode Editor\n 描述：在 IDEA 里刷算法题 官网：https://plugins.jetbrains.com/plugin/12132-leetcode-editor    File Watchers\n 描述：监听文件，当其发生变化时自动执行命令 官网：https://plugins.jetbrains.com/plugin/7177-file-watchers    PlantUML integration\n 描述：UML 建模工具，只需简单的代码就能画出复杂的 UML 类图 官网：https://plugins.jetbrains.com/plugin/7017-plantuml-integration    Bytecode Editor\n 描述：字节码编辑工具 官网：https://plugins.jetbrains.com/plugin/8461-bytecode-editor    Alibaba Cloud Toolkit\n 描述：阿里云工具集 官网：https://plugins.jetbrains.com/plugin/11386-alibaba-cloud-toolkit    Tencent Cloud Toolkit\n 描述：腾讯云工具集 官网：https://plugins.jetbrains.com/plugin/15653-tencent-cloud-toolkit    EduTools\n 描述：面向教育者，允许创建、分享和加入练习 官网：https://plugins.jetbrains.com/plugin/10081-edutools    IDE Features Trainer\n 描述：IntelliJ IDEA 官方出的学习辅助插件 官网：https://plugins.jetbrains.com/plugin/8554-ide-features-trainer    JRebel Plugin\n 描述：项目热更新，提高效率（可惜要收费） 官网：https://plugins.jetbrains.com/plugin/4441-jrebel-and-xrebel-for-intellij    Key Promoter X\n 描述：快捷键提示插件。当你执行鼠标操作时，如果该操作可被快捷键代替，会给出提示，帮助你自然形成使用快捷键的习惯，告别死记硬背。 官网：https://plugins.jetbrains.com/plugin/9792-key-promoter-x/    Translation\n 描述：翻译插件，鼠标选中文本，点击右键即可自动翻译成多国语言。 官网：https://plugins.jetbrains.com/plugin/8579-translation/    idea_seat\n 描述：自动提醒，防止你久坐不动 官网：https://github.com/s-unscrupulous/idea_seat    RestfulTool\n 描述：辅助 web 开发的工具集 官网：https://plugins.jetbrains.com/plugin/14280-restfultool    Multirun\n 描述：同时启动多应用 官网：https://plugins.jetbrains.com/plugin/7248-multirun    扩展增强类  Free Mybatis Plugin  描述：MyBatis 增强插件，支持 mapper =\u0026gt; xml 的跳转、代码生成等功能 官网：https://plugins.jetbrains.com/plugin/8321-free-mybatis-plugin   MyBatis Log Plugin  描述：MyBatis SQL 提取和格式化输出 官网：https://plugins.jetbrains.com/plugin/10065-mybatis-log-plugin   Maven Helper  描述：Maven 辅助插件 官网：https://plugins.jetbrains.com/plugin/7179-maven-helper   Gradle View  描述：Gradle 项目管理工具的扩展 官网：https://plugins.jetbrains.com/plugin/7150-gradle-view   Arthas Idea  描述： Arthas 命令生成插件。Arthas 是阿里开源的 Java 在线诊断工具，该插件可以自动生成 Arthas 在线 Java 代码诊断命令，不用再到官网翻文档拼命令啦！ 官网：https://plugins.jetbrains.com/plugin/13581-arthas-idea/   GitToolBox  描述： Git 增强插件。在自带的 Git 功能之上，新增了查看 Git 状态、自动拉取代码、提交通知等功能。最好用的是可以查看到每一行代码的最近一次提交信息。 官网：https://plugins.jetbrains.com/plugin/7499-gittoolbox/   BashSupport  描述：支持 Bash 脚本文件的高亮和提示等 官网：https://plugins.jetbrains.com/plugin/4230-bashsupport   Git Flow Integration  描述：Git Flow 的图形界面操作 官网：https://plugins.jetbrains.com/plugin/7315-git-flow-integration   Gitee  描述：开源中国的码云插件 官网：https://plugins.jetbrains.com/plugin/8383-gitee   Drools  描述：规则引擎的扩展 官网：https://plugins.jetbrains.com/plugin/16871-drools   EnvFile  描述：对多环境配置文件的支持 官网：https://plugins.jetbrains.com/plugin/7861-envfile   Kubernetes  描述：容器管理的扩展 官网：https://plugins.jetbrains.com/plugin/10485-kubernetes   Vue.js  描述：Vue.js 前端框架的扩展 官网：https://plugins.jetbrains.com/plugin/9442-vue-js   Scala  描述：Scala 语言的扩展 官网：https://plugins.jetbrains.com/plugin/1347-scala   Zookeeper  描述：Zookeeper 中间件的扩展 官网：https://plugins.jetbrains.com/plugin/7364-zookeeper   Jms messenger  描述：对 Java 消息服务的扩展 官网：https://plugins.jetbrains.com/plugin/10949-jms-messenger   MapStruct Support  描述：对 MapStruct 对象转换的支持 官网：https://plugins.jetbrains.com/plugin/10036-mapstruct-support   Big Data Tools  描述：提供了 HDFS 等大数据框架的工具集 官网：https://plugins.jetbrains.com/plugin/12494-big-data-tools   CSV  描述：支持 CSV 文件的高亮和提示等 官网：https://plugins.jetbrains.com/plugin/10037-csv   Ideolog  描述：识别和格式化 log 日志文件 官网：https://plugins.jetbrains.com/plugin/9746-ideolog   Toml  描述：支持 toml 文件的高亮和提示等 官网：https://plugins.jetbrains.com/plugin/8195-toml   .env files support  描述：支持 .env 文件的高亮和提示等 官网：https://plugins.jetbrains.com/plugin/9525\u0026ndash;env-files-support    常用软件 以下部分软件可在【公众号：程序员鱼皮】回复【软件】获取~\n开发相关  JetBrains IDEA：Java 集成开发环境，凭学生邮箱可申请免费使用（https://www.jetbrains.com/idea/） Reset Jetbrains：你懂的 Visual Studio Code：插件化代码编辑器（https://code.visualstudio.com/） Sublime Text：轻量代码编辑器（https://www.sublimetext.com/） Navicat：数据库管理软件（https://www.navicat.com.cn/） JMeter：Java 性能测试工具（https://jmeter.apache.org/） JVisual VM：Java 运行状态可视化工具（https://visualvm.github.io/） XShell：SSH 连接软件（https://www.netsarang.com/zh/xshell/） XFtp：FTP 连接软件（https://www.netsarang.com/zh/xftp/） Redis Desktop Manager：Redis 可视化管理工具（https://github.com/uglide/RedisDesktopManager） Postman：接口测试工具（https://www.postman.com/） VMware：虚拟机软件（https://www.vmware.com/） Chocolatey：Windows 软件包管理器（https://chocolatey.org/） Typora：写文档软件（https://typora.io/）  效率  Ditto：强大的剪切板（https://ditto-cp.sourceforge.io/） uTools：插件化的效率工具（https://u.tools/） XMind：思维导图软件（https://www.xmind.cn/） Qdir：Windows 多窗口管理器（https://q-dir.en.softonic.com/）  项目源码（50 套） 电商秒杀   天猫整站 J2EE：https://how2j.cn/module/115.htm\n  天猫整站 SSM：https://how2j.cn/module/134.html\n  天猫整站 Springboot：https://how2j.cn/module/156.html\n  mall-learning：https://github.com/macrozheng/mall-learningmall（学习教程，架构、业务、技术要点全方位解析）\n  SpringBoot 电商商城系统 Mall4j：https://github.com/gz-yami/mall4j\n  SpringBoot 完整电商系统 Mall：https://github.com/macrozheng/mall（包括前台商城系统及后台管理系统，基于 SpringBoot+MyBatis 实现）\n  newbee-mall：https://github.com/newbee-ltd/newbee-mall （一套电商系统，包括 newbee-mall 商城系统及 newbee-mall-admin 商城后台管理系统，基于 Spring Boot 2.X 及相关技术栈开发）\n  paascloud-master：https://github.com/paascloud/paascloud-master（基于 spring cloud + vue + oAuth2.0，前后端分离商城系统）\n  mall-swarm：https://github.com/macrozheng/mall-swarm（一套微服务商城系统，采用了 Spring Cloud Greenwich、Spring Boot 2、MyBatis、Docker、Elasticsearch 等核心技术，同时提供了基于 Vue 的管理后台方便快速搭建系统）\n  onemall：https://github.com/YunaiV/onemall（mall 商城，基于微服务的思想，构建在 B2C 电商场景下的项目实战。核心技术栈，是 Spring Boot + Dubbo 。未来，会重构成 Spring Cloud Alibaba）\n  litemall：https://github.com/linlinjava/litemall（又一个小商城，litemall = Spring Boot 后端 + Vue 管理员前端 + 微信小程序用户前端 + Vue 用户移动端）\n  xmall：https://github.com/Exrick/xmall （基于SOA架构的分布式电商购物商城 前后端分离 前台商城:Vue全家桶 后台管理系统）\n  miaosha：https://github.com/qiurunze123/miaosha （秒杀系统设计与实现）\n  SecKill：https://github.com/hfbin/Seckill（基于 SpringBoot+Mybatis+Redis+RabbitMQ 秒杀系统）\n  博客论坛   Mblog：开源 Java 博客系统\n  halo：一个优秀的开源博客发布应用\n  forum-java：一款用 Java（spring boot） 实现的现代化社区（论坛/问答/BBS/社交网络/博客）系统平台\n  vhr：微人事是一个前后端分离的人力资源管理系统，项目采用 SpringBoot+Vue 开发。\n  favorites-web:云收藏 Spring Boot 2.X 开源项目。云收藏是一个使用 Spring Boot 构建的开源网站，可以让用户在线随时随地收藏的一个网站，在网站上分类整理收藏的网站或者文章。\n  community：码问，开源论坛、问答系统，现有功能提问、回复、通知、最新、最热、消除零回复功能。技术栈 Spring、Spring Boot、MyBatis、MySQL/H2、Bootstrap\n  NiterForum：尼特社区-NiterForum-一个论坛/社区程序。后端Springboot/MyBatis/Maven/MySQL，前端Thymeleaf/Layui。可供初学者，学习、交流使用。\n  VBlog：V部落，Vue+SpringBoot实现的多用户博客管理平台!\n  NiceFish：SpringBoot/SpringCloud 前后端分离项目\n  My-Blog： My Blog 是由 SpringBoot + Mybatis + Thymeleaf 等技术实现的 Java 博客系统，页面美观、功能齐全、部署简单及完善的代码，一定会给使用者无与伦比的体验。\n  My-Blog-layui：layui 版本的 My-Blog : A simple \u0026amp; beautiful blogging system implemented with spring-boot \u0026amp; layui \u0026amp; thymeleaf \u0026amp; mybatis My Blog 是由 SpringBoot + Layui + Mybatis + Thymeleaf 等技术实现的 Java 博客系统，页面美观、功能齐全、部署简单及完善的代码，一定会给使用者无与伦比的体验\n  symphony：Java 实现的现代化社区\n  管理系统   Spring-Cloud-Admin：Cloud-Admin 是国内首个基于 Spring Cloud 微服务化开发平台，具有统一授权、认证后台管理系统，其中包含具备用户管理、资源权限管理、网关 API 管理等多个模块，支持多业务系统并行开发，可以作为后端服务的开发脚手架。代码简洁，架构清晰，适合学习和直接项目中使用。核心技术采用 Spring Boot2 以及 Spring Cloud Gateway 相关核心组件，前端采用 vue-element-admin 组件。\n  bootshiro：基于 springboot+shiro+jwt 的资源无状态认证权限管理系统后端\n  悟空CRM：基于jfinal+vue+ElementUI的前后端分离CRM系统\n  EL-ADMIN：基于 SpringBoot 的后台管理系统\n  pig：基于 Spring Boot 2.2、 Spring Cloud Hoxton \u0026amp; Alibaba、 OAuth2 的 RBAC 权限管理系统。\n  FEBS-Shiro：Spring Boot 2.1.3，Shiro1.4.0 \u0026amp; Layui 2.5.4 权限管理系统。\n  Spring Boot-Shiro-Vue：基于Spring Boot-Shiro-Vue 的权限管理\n  studentmanager：基于springboot+mybatis学生管理系统\n  jshERP：华夏ERP基于SpringBoot框架和SaaS模式，立志为中小企业提供开源好用的ERP软件，目前专注进销存+财务功能。主要模块有零售管理、采购管理、销售管理、仓库管理、财务管理、报表查询、系统管理等。支持预付款、收入支出、仓库调拨、组装拆卸、订单等特色功能。拥有库存状况、出入库统计等报表。同时对角色和权限进行了细致全面控制，精确到每个按钮和菜单。\n  HotelSystem：酒店管理系统 Java,tomcat,mysql,servlet,jsp实现，没有使用任何框架\n  开发平台  open-capacity-platform：微服务能力开发平台 jeecg-boot：JeecgBoot是一款基于BPM的低代码平台！前后端分离架构 SpringBoot 2.x，SpringCloud，Ant Design\u0026amp;Vue，Mybatis-plus，Shiro，JWT，支持微服务。强大的代码生成器让前后端代码一键生成，实现低代码开发！  其他   学之思在线考试系统：一款 java + vue 的前后端分离的考试系统\n  PassJava-Platform：一款面试刷题的 Spring Cloud 开源系统\n  kkFileView：使用spring boot打造文件文档在线预览项目\n  dynamic-datasource：一个基于springboot的快速集成多数据源的启动器\n  moti-cloud：莫提网盘，基于 SpringBoot+MyBatis+ThymeLeaf+BootStrap，适合初学者\n  threadandjuc：three-high-import 高可用\\高可靠\\高性能，三高多线程导入系统（该项目意义为理论贯通)\n  proxyee-down：http下载工具，基于http代理，支持多连接分块下载\n  hosp_order：医院预约挂号系统，基于 SSM 框架\n  趋势投资 SpringCloud\n  DiyTomcat\n  阶段 6：Java 高级 目标 不满足于能做，而是通过更 深入 和 广泛 的学习，实现高质量的代码和更优秀的架构，培养解决问题的能力。\n已经到了这个阶段，建议除了看完成的教程外，平时多自主搜索信息去学习，积少成多。比如遇到了一个不了解的名词，可以去网上搜一下，感兴趣的话再进行下一步的学习。\n🌖 并发编程（21 天） 对 Java 后端开发程序员来说，懂得如何利用有限的系统资源来提高系统的性能是很重要的，也是大厂面试考察的重点，因此并发编程（尤其是 Java 并发包的使用）这块的知识很重要。\n把它放到高级，是因为在学并发编程前，需要有一定的编程经验、了解一定的操作系统知识。\n知识  线程和进程 线程状态 并行和并发 同步和异步 Synchronized Volatile 关键字 Lock 锁 死锁 可重入锁 线程安全 线程池 JUC 的使用 AQS Fork Join CAS  学习建议 并发编程入门不难，依然是 先学会使用 基础的 Java 并发包， 再通过大量地实践和测试，了解一些原理，才能真正掌握何时使用、如何更合理地使用并发编程。而不是张口闭口多线程，上天入地高并发。\n经典面试题  volatile 关键字的作用 使用线程池有哪些好处？ 线程池参数如何设置？ 什么是线程安全问题，如何解决？ 介绍 synchronized 的锁升级机制 CopyOnWriteArrayList 适用于哪种场景？  资源   视频\n ⭐【尚硅谷】大厂必备技术之JUC并发编程2021最新版：https://www.bilibili.com/video/BV1Kw411Z7dF（特点是短、精、新） 黑马程序员全面深入学习Java并发编程：https://www.bilibili.com/video/BV16J411h7Rd（讲的很细、全面深入）    书籍\n ⭐《Java并发编程实战》（国外的经典） ⭐《Java 并发编程艺术》（国人写的，理论思想内容较多，有时间建议反复看）    项目\n ⭐ Java 并发知识点总结：https://github.com/CL0610/Java-concurrency    🌖 JVM（30 天） 想要深入理解 Java，探秘 Java 跨平台的奥秘，一定要了解 Java 底层的虚拟机技术。\n了解虚拟机、掌握虚拟机性能调优方法，有助于你写出更高性能、资源占用更小的优质程序。\n在学习 JVM 的过程中，也能学到很多精妙的设计，开拓思路。\n知识  JVM 内存结构 JVM 生命周期 主流虚拟机 Java 代码执行流程 类加载  类加载器 类加载过程 双亲委派机制   垃圾回收  垃圾回收器 垃圾回收策略 垃圾回收算法 StopTheWorld   字节码 内存分配和回收 JVM 性能调优  性能分析方法 常用工具 参数设置   Java 探针 线上故障分析  学习建议 JVM 的知识略显枯燥，建议先看视频，有实操的地方一定要实操！自己多去分析。\n第一遍不理解没有关系，可以再看书来巩固，想要真正学好，《深入理解 Java 虚拟机（第三版）》一定要读。\n如果只是为了通过面试可以直接看更精简的视频，比如狂神的。\n经典面试题  介绍 JVM 的内存模型？ JVM 内存为什么要分代？ 介绍一次完整的 GC 流程 介绍双亲委派模型，为什么需要它？  资源  视频  ⭐ 尚硅谷宋红康 - JVM 全套教程详解：https://www.bilibili.com/video/BV1PJ411n7xZ（讲得相当全面！附有实操） 【狂神说Java】JVM快速入门篇：https://www.bilibili.com/video/BV1iJ411d7jS（讲得有点浅，但都是面试重点，时间紧的小伙伴可以直接看这个）   书籍  ⭐《深入理解 Java 虚拟机（第三版）》（有理论有实践，内容丰富，不可多得的 JVM 学习神书，就是有点废头发）   项目  ⭐ Java 虚拟机底层原理知识总结：https://github.com/doocs/jvm   实战  阿里云 JVM 实战：https://developer.aliyun.com/graph/java/point/64   工具  Arthas 开源 Java 诊断工具：https://github.com/alibaba/arthas    架构设计 🌖 分布式  分布式理论  CAP BASE   分布式缓存  Redis Memcached Etcd   一致性算法  Raft Paxos 一致性哈希   分布式事务  解决方案  2PC 3PC TCC 本地消息表 MQ 事务消息 最大努力通知   LCN 分布式事务框架：https://github.com/codingapi/tx-lcn   分布式 id 生成  Leaf 分布式 id 生成服务：https://github.com/Meituan-Dianping/Leaf   分布式任务调度  XXL-JOB 调度平台：https://www.xuxueli.com/xxl-job/ elastic-job：https://gitee.com/elasticjob/elastic-job   分布式服务调用  trpc   分布式存储  HDFS Ceph   分布式数据库  TiDB OceanBase   分布式文件系统  HDFS   分布式协调  Zookeeper   分布式监控  Prometheus Zabbix   分布式消息队列  RabbitMQ Kafka Apache Pulsar   分布式日志收集  Elastic Stack Loki   分布式搜索引擎  Elasticsearch   分布式链路追踪  Apache SkyWalking   分布式配置中心  Apollo Nacos    🌗 高可用  限流 降级熔断 冷备 双机热备 同城双活 异地双活 异地多活 容灾备份  🌗 高并发  数据库  分库分表  MyCat 中间件 Apache ShardingSphere 中间件   读写分离   缓存  缓存雪崩 缓存击穿 缓存穿透   负载均衡  负载均衡算法 软硬件负载均衡（2、3、4、7 层）    🌘 服务网格 服务网格用来描述组成应用程序的微服务网络以及它们之间的交互。服务网格的规模和复杂性不断的增长，它将会变得越来越难以理解和管理，常见的需求包括服务发现、负载均衡、故障恢复、度量和监控等。\n知识  Istio  流量管理 安全性 可观测性   Envoy（开源的边缘和服务代理）  资源  资料大全：https://www.servicemesher.com/awesome-servicemesh/ istio 官方文档：https://preliminary.istio.io/latest/zh istio 视频教程：https://www.bilibili.com/video/BV1Lf4y1x7j8 在线体验 istio：https://katacoda.com/courses/istio/  🌘 DDD 领域驱动设计 将数据、业务流程抽象成容易理解的领域模型，通过用代码实现领域模型，来组成完整的业务系统。\n知识  DDD 的优势 DDD 的适用场景 DDD 核心概念  领域模型分类：失血、贫血、充血、涨血 子域划分：核心域、通用域、支撑域 限界上下文 实体和值对象 聚合设计 领域事件   DDD 实践  资源  DDD 入门：https://juejin.cn/post/7004002483601145863 DDD 编码实践：https://juejin.cn/post/6844903903104860174 DDD 实践教程：https://www.bilibili.com/video/BV1Y341167Xp  🌘 其他  Sidecar Serverless 云原生  学习建议 架构设计的学习没有顶点，多看文章，思考每种设计的优缺点和适用场景，有机会的话在企业中实践即可。\n还在学校、或者初入这行的同学切记，千万不要一味地去背诵架构设计的八股文。你可以背，但是这一块的知识只有结合具体的项目才有意义，所以要多做项目去实践设计的合理性，而不是什么设计都咔咔往系统里去怼。比如面试问到分布式事务，能结合自己项目中用分布式事务解决问题的经验去回答最好。\n🌘 其他技术  热数据探测技术：京东 HotKey 数据库流水订阅：阿里 Canal 监控告警 应用安全 故障演练 流量回放  阶段 7：Java 求职 目标 找到好工作\n建议  尽早做规划，可以通过大厂招聘官网的岗位描述来了解岗位的要求 雕琢一份优秀的简历，推荐阅读：https://mp.weixin.qq.com/s/wfabzdpOPdq89faFFpZ4NA 多读面经，坚持刷算法 多参与面试，持续复盘总结  资源 校招岗位  ⭐ 牛客求职校招版：https://www.nowcoder.com/recommend/campus 阿里 Java 开发：https://campus.alibaba.com/position.htm?refno=12699 腾讯后台开发：https://join.qq.com/post_detail.html?pid=1\u0026amp;id=101\u0026amp;tid=2 腾讯全栈开发：https://join.qq.com/post_detail.html?pid=1\u0026amp;id=137\u0026amp;tid=2 腾讯运营开发：https://join.qq.com/post_detail.html?pid=1\u0026amp;id=105\u0026amp;tid=2 美团后端开发：https://campus.meituan.com/jobs?jobFamily=1\u0026amp;jobId=4005\u0026amp;jobType=1\u0026amp;pageNo=2 华为软件开发：https://career.huawei.com/reccampportal/portal5/campus-recruitment-detail.html?jobId=176044  社招岗位  ⭐ 牛客求职社招版：https://www.nowcoder.com/recommend/fulltime 阿里社招：https://job.alibaba.com/zhaopin/positionList.htm 腾讯社招：https://careers.tencent.com/search.html  实习  ⭐ 牛客实习广场：https://nowpick.nowcoder.com/w/intern/center 实习僧：https://www.shixiseng.com/  内推  牛客内推：https://www.nowcoder.com/discuss/referral/index  鱼皮经历  从 0 开始的编程学习进大厂经历  ⭐ 我学计算机的四年，共勉：https://mp.weixin.qq.com/s/Nc7Ee2UyrPg6hGseQUCzeg   实习经历   ⭐ 我的第一份实习：https://mp.weixin.qq.com/s/SwGiRzyTkCOOCUXfXPR1Pw\n  ⭐ 我的第二份实习，字节跳动：https://mp.weixin.qq.com/s/3q-YIfuZBjPjSnamNwOraw\n    知识总结  ⭐ 牛客 Java 面试宝典：https://www.nowcoder.com/tutorial/94 ⭐ JavaGuide：https://snailclimb.gitee.io/javaguide/#/ ⭐ CS-Notes：http://www.cyc2018.xyz/ 阿里 Java 技术图谱：https://developer.aliyun.com/graph/java  面经   ⭐ 牛客面经：https://www.nowcoder.com/discuss/experience?tagId=639\n  秋招总结\u0026amp;Java心得（双非硕士，已拿11+5家Offer）：https://www.nowcoder.com/discuss/327041\n  被疫情逼得gap year的完全菜鸡的春招之路。：https://www.nowcoder.com/discuss/427812\n  谨以此文纪念2019年春招：https://www.nowcoder.com/discuss/181212\n  2019秋招经验谈：https://www.nowcoder.com/discuss/122463\n  秋招心得：https://www.nowcoder.com/discuss/317888\n  非科班本科菜鸡投的337家(Java后台)：https://www.nowcoder.com/discuss/133333\n  2018 这一年：https://www.nowcoder.com/discuss/137593\n  双非的秋招，感谢牛客：https://www.nowcoder.com/discuss/142181\n  二本本科Java上岸(滴滴京东58)2019秋招心得+面经：https://www.nowcoder.com/discuss/333912\n  碎碎念流水账特别长 of 自己的 Java 秋招：https://www.nowcoder.com/discuss/354154\n  秋招之路：个人历程以及面经总结：https://www.nowcoder.com/discuss/344311\n  【秋招面经总结】菜逼的坎坷之路（JAVA后台研发）：https://www.nowcoder.com/discuss/352030\n  阿里11面+EMC+网易+美团面经：https://www.nowcoder.com/discuss/105302\n  2018秋招阿里巴巴java笔试试题：https://www.nowcoder.com/discuss/67379\n  我的秋招经验分享（已拿BAT头条网易）：https://www.nowcoder.com/discuss/117071\n  20届的阿里 头条 网易 滴滴 百度 小米等Java面经：https://www.nowcoder.com/discuss/68289\n  拿了5个offer，回馈牛友发一波面经（长文详细）：https://www.nowcoder.com/discuss/79051\n  【总结】零基础学习一年拿到BAT三家offer：https://www.nowcoder.com/discuss/188241\n  本科生秋招经验总结帖：https://www.nowcoder.com/discuss/296586\n  双非渣硕校招总结+Java面经（网易阿里百度等）：https://www.nowcoder.com/discuss/134850\n  2018秋招笔试科大讯飞java笔试试题：https://www.nowcoder.com/discuss/67684\n  头条后台研发面经（共三面）：https://www.nowcoder.com/discuss/94233\n  一点点小经验和几家Java面经：https://www.nowcoder.com/discuss/138434\n  感谢牛客网！发一波面经！阿里、网易游戏、京东等offer。：https://www.nowcoder.com/discuss/101712\n  非科班水硕的春招实习总结- Java 后台开发：https://www.nowcoder.com/discuss/186528\n  十面阿里，七面头条，六个Offer，春招结束：https://www.nowcoder.com/discuss/80156\n  成功上岸，最后一波回馈：https://www.nowcoder.com/discuss/176434\n  【Java后台开发面经】阿里|网易|头条|腾讯|华为：https://www.nowcoder.com/discuss/108655\n  三跨学生的面经（头条、拼多多、华为、vivo）：https://www.nowcoder.com/discuss/195640\n  面试题解  ⭐ 2021 最新 Java 笔试、面试题合集：https://pan.baidu.com/s/1DE4HAu-DS80n7VOaGpU_KQ（密码：lkw1） 牛客网 Java开发校招面试考点汇总（附面试题和答案）：https://www.nowcoder.com/discuss/161991 50w字+的技术类校招面试题汇总（附答案+考点）：https://www.nowcoder.com/discuss/164726 硬件，软件（后端开发，算法，数据分析等）历年企业笔试真题汇总：https://www.nowcoder.com/discuss/212783  视频   ⭐ 尚硅谷 2021 逆袭版 Java 面试题第三季：https://www.bilibili.com/video/BV1Hy4y1B78T\n  ⭐ 阿里大佬透彻讲解 Java 面试 500 道必考题：https://www.bilibili.com/video/BV1yU4y1J7Bb\n  阶段 8：持续学习 目标 持续追求技术的深度和广度，培养自己的 核心竞争力 和 不可替代性 ，学无止境！\n学习建议 自主学习，自主搜索教程，多看书，多阅读技术博客，多实践。\n学习方向 框架源码  Spring SpringBoot SpringMVC MyBatis Netty Dubbo SpringCloud  计算机原理  《算法导论》：https://www.bilibili.com/video/av48922404 《现代操作系统》：https://www.bilibili.com/video/av9555596 《深入理解计算机系统》：https://www.bilibili.com/video/av31289365 《编译原理》： https://www.bilibili.com/video/av17649289 《计算机网络：自顶向下方法》：https://www.bilibili.com/video/BV1JV411t7ow 《计算机程序的构造和解释》：https://www.bilibili.com/video/av8515129 《数据库系统概论》：https://www.bilibili.com/video/BV1G54y1d7ZK  数据库 / 中间件 / 分布式  数据库  MySQL PostgreSQL   缓存  Redis   队列  Apache Kafka Apache Pulsar   搜索引擎  Elastic Stack  Elasticsearch logstash kibana beats     容器  Docker K8S    解决方案  广告系统 电商系统 搜索系统 支付转账 游戏后台 即时通讯 社交系统 CMS 系统 ERP 系统 OA 系统 代码生成 权限管理 秒杀活动  架构设计 同阶段 6 架构设计部分\n大数据  5V 特点 Hadoop HDFS MapReduce Spark Flink Storm Hive HBase Druid Kylin Pig Mahout  前沿技术  云原生：https://www.jianshu.com/p/a37baa7c3eff  Quasar Framework：http://www.quasarchs.com/   服务网格：https://www.redhat.com/zh/topics/microservices/what-is-a-service-mesh  istio：https://github.com/istio/istio   GraalVM：https://juejin.cn/post/6850418120570437646（高性能的通用虚拟机）  官网：https://www.graalvm.org/   ZGC：https://juejin.cn/post/6859276583656980493（新一代垃圾回收器）  官网：http://openjdk.java.net/projects/zgc/    自学 Java 专题资源  ⭐ GitHub Java 专区：https://github.com/topics/java ⭐ GitHub Java 合集：https://github.com/akullpp/awesome-java StackOverflow：https://stackoverflow.com/questions/tagged/java（解决问题必备） ⭐ 掘金 Java 专区：https://juejin.cn/tag/Java 美团技术团队：https://tech.meituan.com/ 阿里技术团队：https://102.alibaba.com/tech/list/ 有赞技术团队：https://tech.youzan.com/tag/back-end/  附录 程序员重要能力 想成为大佬，就是要通过学习和积累，提升自己的各方面能力，比较抽象，共勉！\n  团队协作能力\n  高效沟通能力\n  需求分析能力\n  架构设计能力\n  抽象复用能力\n  独立创造能力\n  问题解决能力\n  归纳总结能力\n  自主学习能力\n  工具利用能力\n  高效编码能力\n  信息检索能力\n  开源建设能力\n  源码阅读能力\n  自测审查能力\n  文档编写能力\n  知识表达能力\n  绘图描述能力\n  兴趣驱动（长期学习能力）\n  保持好奇心\n  其他（狗头）\n  复制粘贴能力\n  打架能力\n  PPT 制作能力\n    编程误区  我不适合学编程？❌（兴趣比天赋更重要，不要怀疑自己） 忽视基础，急于求成 ❌（勿以浮沙筑高台） 数学、英语差，就学不好编程 ❌（开发工作基本不用高等数学，英语可以使用翻译软件、工作中提升） 编程时，刻意记忆代码 ❌（知道每行代码的意义，能看文档写出来就行） 每行代码都要追求完美 ❌（何为完美？每个人的定义不同） 用百度搜索、复制粘贴的都是菜鸡程序员 ❌（艹） 我做的项目太小了，就不整理了 ❌（自己的每个项目都要整理，可以记录自己的成长） 跟别人交流很麻烦，我更愿意自己写代码 ❌（1 + 1 \u0026gt; 2，切勿闭门造车，不过也要找到合适的同学去交流） 做别人做过的项目没有意义 ❌（连别人做过的项目都做不出，还想造新轮子？） 遇到 Bug，想办法绕过而不是寻找解决方案 ❌（Bug 最能使人成长） 遇到问题，第一时间去问别人而非自己解决 ❌（建议阅读《提问的智慧》） 花了很多时间、看了很多书，就能学好编程 ❌（编程最忌讳纸上谈兵） 只向前学习，不整理学过的知识 ❌（建议每学完一个知识，都去回想、总结、写心得，这个时间的花费是值得的） 单元测试不重要 ❌（一棍打死） 写文档不重要 ❌（一棍打死） 和我无关的工作，就不需要了解 ❌（了解团队、同行是很重要的，全局视野） 收藏的资源从来不看，就不收藏了 ❌（万一以后用到了呢？） 不去考虑需求的价值，而是一味寻求解决方案 ❌（不要成为需求机器，要有自己的独立思考）  高效法则  不要过分追求完美，完成比完美更重要。 有现成的代码，就不要自己写，避免重复劳动（学习除外）。 学会使用软件及快捷键来提升自己的编码效率。 做项目前，要先想清楚怎么做，做好充分的预研和设计。这样不仅便于后续的程序扩展，也能避免无意义的返工。 将大的目标进行拆解，做好计划，分清主次。不要因为觉得目标遥不可及而拖延，也不要盲目乐观而松懈。 养成好的作息习惯，找到自己适合工作的黄金时间。 记性不好，就多记录、多总结、定期复习。哪怕实在记不住，也可以借助文档、收藏夹软件来当自己的第二大脑。 积累属于自己的工具库，配合搜索软件实现随用随取。 多和其他同行交流或订阅技术推送，拓宽知识渠道，从而了解更多的工具和方法。有些东西你只要听说过，要用时也许就能节省大量查找时间。 找到让自己进入专注做事的状态的方法，比如戴上耳机、嚼口香糖等。 做事高效，离不开经验的积累，因此要多写代码、多做项目。  常见问题   按照这份路线学习，每天要学多少个小时，总共要学多久？\n回答：每个人学习能力不同，当然没有固定标准。我当时平均每天可以学习 6 个小时，寒暑假能保证 8 小时以上的学习，路线中的时长是我当时学习时长 * 1.5 倍的参考值。实话说，我的学习效率真的不高，对编程感兴趣，多学就好了。与其纠结这个时长，倒不妨多抽点时间，每天多学一点。\n  这份路线上推荐的资源，鱼皮都看完了么？\n回答：我是特么神仙啊？怎么可能都看完了！这份路线的本质是以网上现有的、死板的 Java 大学习框架为基础，结合我自己实际学习的知识、经验和感悟给它注入灵魂，从而希望给大家带来更大的帮助和价值。路线中的资源都是利用我自己的资源检索能力和渠道，通过试看、反复对比和参考评价精选出来的，不是主观臆断、空穴来风。\n  我学到这份路线的哪个位置，可以找工作？\n回答：这和你自己的领悟能力和教育背景有关。夸张点说，有些清华大学的同学，可能之前都没学过 Java，照样能找到大厂 Java 开发工作。学到同一阶段的同学，学习过程中的认真程度、积累总结数、做项目个数、基础学习的好坏不同，找到的工作肯定也不同。但一般情况下，想要进大厂，建议至少学完阶段 4 的微服务部分，然后去做一个完整的项目，用上之前学习的技术；不想进大厂的同学，学完第 3 阶段后，学下缓存和队列，一般也能找到 Java 开发的工作。\n  学完这份路线就能进大厂么？\n回答：你先学完，再问这个问题。没有绝对进大厂的保证，但是相信我，把这份路线上的大部分知识学了，再做做项目，哪怕进不了大厂，你拿到的薪水也绝对比松散学习的同学高！\n  我可以相信你么？\n回答：不要相信我，应该相信你自己。想进大厂，就不要怀疑自己的能力！\n  写在最后 觉得看文字累的朋友，欢迎看下视频版，带大家导读一下：https://www.bilibili.com/video/BV1Qf4y1K7ff/\n以上就是鱼皮熬了几天大夜、结合个人经验、并且参考了大量网上的文章和评论总结而成的学习路线，真的是非常不容易，如果大家觉得满意请务必 三连 支持下。\n我是鱼皮，持续分享编程干货的程序员，欢迎关注，下期再见~\n","date":"2021-12-01T01:23:09+08:00","permalink":"https://damaicao.github.io/post/java%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/","title":"Java学习路线"},{"content":"前端学习路线  这份学习路线并不完美，也不会有最终形态，正如前端不可预见、永无止境的未来。[by 程序员鱼皮](liyupi/code-roadmap: 编程学习路线 (github.com))\n 💂 + 💻 = 👴🏽\n大纲  前言 - 学编程需要的特质 前端学习七阶段  前端入门 巩固基础 前端工程化 前端优化 前端生态 前端求职 前端未来   尾声 - 持续学习 我的前端学习路线  前言 - 学编程需要的特质 相信自己有能力，那么你就真的会有！\n 兴趣 坚持 付出 心态  一、前端入门 开发工具   VSCode\n  WebStorm\n  Atom\n  Sublime Text\n  HBuilder X\n  记事本\n  在线 IDE\n  HTML  基本语法  CSS  盒子模型 内联元素/块状元素 文档流 浮动 float 元素堆叠 块格式化上下文(BFC) 响应式布局 Flex 布局 Grid 布局 CSS 动画 瀑布流  JavaScript  基本语法 基本类型 Javascript 对象 原型和继承 作用域 闭包 this ES6+ 单线程与异步 Javascript DOM/BOM API  二、巩固基础 前端基础知识   互联网\n  域名\n  DNS\n  服务器\n  浏览器\n 浏览器 DOM 事件流/事件委托 浏览器加载顺序 浏览器渲染过程 浏览器 EventLoop 浏览器同源策略 跨域方案/CORS 浏览器缓存 常见调试技巧    HTTP\n HTTP 请求过程 常见 HTTP 协议 HTTP 1.0/HTTP 1.1/HTTP2/HTTP3 Ajax WebSocket    计算机基础 算法和数据结构 计算机网络 操作系统 软件开发基础 设计模式 Git 版本控制 Linux 服务器 三、前端工程化 研发流程  技术选型 初始化 开发 本地测试 代码提交 编译、打包、构建 部署 集成测试 发布上线  代码托管  GitHub Gitee GitLab  Node.JS 包管理  npm yarn bower npx  开发框架 JavaScript 框架 Vue  Vue Router  React  React DOM React Router Redux MobX React Hooks  Angular  RxJS NgRx  Svelte CSS 框架  BootStrap Tailwind CSS  封装库 组件库  LayUI ElementUI VantUI Ant Design  数据可视化  EChart HighChart D3.js AntV  工具库  jQuery moment lodash axios  字体图标库  IconFont IconPark Font Awesome  脚手架   vue-cli\n  create-react-app\n  Yeoman\n  前端架构  前端模块化 SPA 多页应用 前端路由 PWA  服务端渲染  Next.js（React） Nuxt.js（Vue） Universal（Angular）  BFF  GraphQL  前端微服务  qiankun   CSS in JS  内联样式 声明样式 引入样式  CSS 模块化  CSS Modules styled-components Styled JSX Emotion  开发调试  webpack-dev-server serve  内网穿透  Ngrok NATAPP  CSS 预编译  SASS PostCSS Stylus LESS  测试 测试分类  单元测试 集成测试 E2E 测试  Mock 测试框架   Jest\n  Enzyme\n  Puppeteer\n  Mocha\n  Chai\n  Jasmine\n  Headless Browser\n  代码质量 开发规范  Style Guide  类型校验  TypeScript  代码检查  ESLint StyleLint  代码风格  Prettier  提交规范  pre-commit  提交检查  hosky  构建工具 自动化构建  Gulp npm script grant  打包工具  Webpack Rollup Vite Parcel Snowpack  CI / CD  GitLab CI Jenkins  部署 Web 服务器  Nginx Apache  容器  Docker K8s  部署策略  全量发布 蓝绿部署 滚动发布 灰度发布  监控告警  前端埋点 错误监控 性能监控 行为监控  四、前端优化 性能优化 性能指标  FP FCP FMP TTI  优化手段   性能监控\n Performance API    样式优化\n  JavaScript 优化\n  代码分割\n  资源压缩\n  打包优化\n  服务器优化\n  缓存优化\n Service Worker    动画性能\n  dns-prefetch\n  Lazy loading\n  优化启动性能\n 异步化    渲染优化\n  网络优化\n  移动端性能优化\n  用户体验  骨架屏  兼容性 浏览器兼容性  normalize.css html5shiv.js respond.js Babel Polyfill  屏幕分辨率兼容性 跨平台兼容性 SEO 安全  XSS CSRF 反爬虫 SQL 注入 DDoS  五、前端生态 静态站点构建 开发  react-static  博客  Gatsby.js Docusaurus Hugo Hexo  文档  JekyII Docsify VuePress Dumi  大前端 移动应用  Hybrid WebView React Native Flutter  移动应用打包  Week Cordova Phonegap Ionic  桌面应用  Electron NW.js Proton Native  小程序  原生 WebView  跨端开发框架  uni-app Taro Flutter Chameleon Wepy Rax  移动端调试  Chrome Dev Tools Android Simulator IOS Simulator  Serverless 云开发  腾讯云云开发 阿里云云开发  低代码 零代码\n 腾讯云低码 阿里宜搭  六、前端求职 流程 简历 面试题库 面经 面试实战 （模拟面试）\n七、前端未来   WebAssembly\n  智能 UI\n  React Server Component\n  CSS Houdini\n  WebComponents  HTML templates（HTML模板） Custom elements（自定义元素） Shadow DOM（影子DOM）  尾声 - 持续学习 优秀前端人的特质 学习资源 前端资讯 技术博客  我的前端学习路线 找项目：searchCode\ntodo 优化 html、css、js 内容\n补充尾声内容\n描述和链接\n写一条线\n","date":"2021-12-01T01:23:09+08:00","permalink":"https://damaicao.github.io/post/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/","title":"前端学习路线"},{"content":"\r图片\r\n排序算法 排序也称排序算法 (Sort Algorithm) 是将一组数据，依指定的顺序进行排列的过程\n排序的分类\n 内部排序:指将需要处理的所有数据都加载到 内部存储器 中进行排序。  外部排序法:数据量过大，无法全部加载到内存中，需要借助 外部存储 进行排序。  \rimage-20211128000834503\r\n算法时间复杂度 度量一个程序(算法)执行时间的方法\n  事后统计法\n这种方法可行,但是有两个问题：一是要想对设计的算法的运行性能进行评测，需要 实际运行该程序；二是所得时间的统计量依赖于计算机的硬件、软件等环境因素,\n这种方式，要在同一台计算机的相同状态下运行，才能比较那个算法速度更快。\n  事前估算法\n通过分析某个算法的时间复杂度来判断哪个算法更优.\n  时间频度 时间频度：一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多,它花费时间就多。一个算法中的语句执行次数称为语句频度或时间频度. 记为T(n)。[举例说明]\n 忽略常数项, 低次项,系数  时间复杂度  一般情况下，算法中的基本操作语句的重复执行次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n)，使得当n趋近于无穷大时，T(n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作 T(n)= O（f(n))，称O（f(n)）为算法的渐进时间复杂度，简称 时间复杂度 。  T(n)不同，但时间复杂度可能相同。如：T(n)=n2+7n+6与T(n)=3n2+2n+2它们的T(n)不同，但时间复杂度相同，都为O(n2)。 计算时间复杂度的方法： 用常数1代替运行时间中的所有加法常数 T(n)=n2+7n+6 =\u0026gt; T(n)=n2+7n+1 修改后的运行次数函数中，只保留最高阶项 去除最高阶项的系数  常见的时间复杂度 根据从小到大排列，常见的算法时间复杂度主要有：\nO(1) \u0026lt; O(log N) \u0026lt; O(N) \u0026lt; O(Nlog N) \u0026lt; O(N^2) \u0026lt; O(2^N) \u0026lt; O(N!)\n\r力扣（LeetCode）\r\n平均时间复杂度和最坏时间复杂度\n  平均时间复杂度 是指所有可能的输入实例均以等概率出现的情况下，该算法的运行时间。\n  最坏情况下的时间复杂度称 最坏时间复杂度 。般讨论的时间复杂度均是最坏情况下的时间复杂度。这样做的原因是：最坏情况下的时间复杂度是算法在任何输入实例上运行时间的界限，这就保证了算法的运行时间不会比最坏情况更长。\n  平均时间复杂度和最坏时间复杂度是否一致，和算法有关(如图:)。\n  \rimage-20211128004810530\r\n算法的空间复杂度 基本介绍  类似于时间复杂度的讨论，一个算法的 空间复杂度(Space Complexity) 定义为该算法所耗费的存储空间，它也是问题规模n的函数。 空间复杂度(Space Complexity)是对一个算法在运行过程中临时占用存储空间大小的量度。有的算法需要占用的临时工作单元数与解决问题的规模n有关，它随着n的增大而增大，当n较大时，将占用较多的存储单元，例如快速排序和归并排序算法就属于这种情况 在做算法分析时，主要讨论的是 时间复杂度 。从用户使用体验上看，更看重的程序执行的速度。有些 缓存产品(redis,memcache) 和 算法(基数排序) 本质就是用空间换时间.  冒泡排序 基本介绍 冒泡排序（Bubble Sorting）的基本思想是：通过对待排序序列从前向后（从下标较小的元素开始）依次比较相邻元素的值，若发现逆序则交换，使值较大的元素逐渐从前移向后部，就象水底下的气泡一样逐渐向上冒。\n因为排序的过程中，各元素不断接近自己的位置，如果一趟比较下来没有进行过交换，就说明序列有序，因此要在排序过程中设置个标志flag判断元素是否进行过交换。从而减少不必要的比较。\n代码 public static void bubbleSort(int[] arr){ boolean flag = false; for (int i = 0; i \u0026lt; arr.length - 1 ; i++) { for (int j = 0; j \u0026lt; arr.length - 1 - i ; j++) { if (arr[j] \u0026gt; arr[j + 1]){ // temp = arr[i];  // arr[i] = arr[i + 1];  // arr[i + 1] = temp;  flag = true; arr[j] = arr[j] ^ arr[j + 1]; arr[j + 1] = arr[j] ^ arr[j + 1]; arr[j] = arr[j] ^ arr[j + 1]; } } // 如果一次都没有交换  if (!flag) { break; } else{ flag = false; } } } 选择排序 选择排序 （select sorting）也是一种简单的排序方法。它的基本思想是：第一次从arr[0]~arr[n-1]中选取最小值，与arr[0]交换，第二次从arr[1]~arr[n-1]中选取最小值，与arr[1]交换，第三次从arr[2]~arr[n-1]中选取最小值，与arr[2]交换，…，第i次从arr[i-1]~arr[n-1]中选取最小值，与arr[i-1]交换，第n-1次从arr[n-2]~arr[n-1]中选取最小值，与arr[n-2]交换，总共通过n-1次，得到一个按排序码从小到大排列的有序序列。\npublic static void selectSort(int[] arr) { for (int i = 0; i \u0026lt; arr.length - 1; i++) { int minIndex = i; int min = arr[i]; for (int j = i + 1; j \u0026lt; arr.length; j++) { if (min \u0026gt; arr[j]) { min = arr[j]; minIndex = j; } } if (minIndex != i){ arr[minIndex] = arr[i]; arr[i] = min; } } } 插入排序 思想\n插入排序（Insertion Sorting）的基本思想是：肥n个待排序的元素看成为一个有序表和一个无序表，开始时有序表中只包含一个元素，无序表中包含有n-1个元素，排序过程中每次从无序表中取出第一个元素，把它的排序码依次与有序表元素的排序码进行比较，将它插入到有序表中的适当位置，使之成为新的有序表。\n就是拿后面的值与前面的值比较大小\npublic static void insertSort(int[] arr){ for (int i = 1; i \u0026lt; arr.length ; i++) { //定义待插入数  int insertVal = arr[i]; int insertIndex = i - 1; //1 insertIndex \u0026gt;= 0保证在给insertVal 找插入位置，不越界  //2.insertVal \u0026lt; arr[insertIndex] 待插入的数，还没有找到插入位置  //3. 就需要将arr[insertIndex]后移  while (insertIndex \u0026gt;= 0 \u0026amp;\u0026amp; insertVal \u0026lt;= arr[insertIndex]){ arr[insertIndex + 1] = arr[insertIndex]; insertIndex--; } if (insertIndex + 1 != i){ arr[insertIndex + 1] = insertVal; } System.out.println(\u0026#34;第\u0026#34; + i + \u0026#34;轮排序\u0026#34;); System.out.println(Arrays.toString(arr)); } } 希尔排序 介绍 希尔排序是希尔（Donald Shell）于1959年提出的一种排序算法。希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为 缩小增量排序 。\n思想 希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止\npublic static void shellSort(int[] arr) { int count = 0; for (int gap = arr.length / 2; gap \u0026gt; 0; gap /= 2) { //分组  for (int i = gap; i \u0026lt; arr.length; i++) { // 组内插入排序  for (int j = i - gap; j \u0026gt;= 0; j -= gap) { //当前元素大于步长元素,则交换  if (arr[j] \u0026gt; arr[j + gap]) { arr[j] = arr[j] ^ arr[j + gap]; arr[j + gap] = arr[j] ^ arr[j + gap]; arr[j] = arr[j] ^ arr[j + gap]; } } } System.out.println(\u0026#34;希尔排序\u0026#34;+(++count)+\u0026#34;轮\u0026#34; + Arrays.toString(arr)); } } public static void shellSort2(int[] arr) { int count = 0; for (int gap = arr.length / 2; gap \u0026gt; 0; gap /= 2) { //分组  for (int i = gap; i \u0026lt; arr.length; i++) { int j = i; int temp = arr[j]; if (arr[j] \u0026lt; arr[j - gap]){ while (j - gap \u0026gt;= 0 \u0026amp;\u0026amp; temp \u0026lt; arr[j - gap]) { arr[j] = arr[j - gap]; j -= gap; } arr[j] = temp; } } System.out.println(\u0026#34;希尔排序\u0026#34;+(++count)+\u0026#34;轮\u0026#34; + Arrays.toString(arr)); } } 快速排序 介绍 快速排序（Quicksort）是对冒泡排序的一种改进。基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，，以此达到整个数据变成有序序列\npublic static void quickSort(int[] arr, int left, int right) { int l = left; int r = right; // 中轴值  int pivot = arr[(l + r) / 2]; int temp = 0; while (l \u0026lt; r){ //在 pivot的左边一直找,找到大于等于 pivot值,才退出  while (arr[l] \u0026lt; pivot){ l += 1; } //在 pivot的右边一直找,找到小于等于 pivot.值,才退出  while (arr[r] \u0026gt; pivot){ r -= 1; } //如果1\u0026gt;=r说明 pivot的左右两的值,已经按照左边全部是  //小于等于 pivot值,右边全部是大于等于 pivot值  if( l \u0026gt;= r){ break; } if (arr[l] != arr[r]){ arr[l] ^= arr[r]; arr[r] ^= arr[l]; arr[l] ^= arr[r]; } //如果交换完后,发现这个arr[l]== pivot值相等 --,前移  if (arr[l] == pivot){ r -= 1; } //如果交换完后,发现这个arr[r]== pivot值相等 ++,前移  if (arr[r] == pivot){ l += 1; } } //如果l==r,必须1++,r--,否则为出现栈溢出  if (l == r){ l += 1; r -= 1; } // 向左递归  if (left \u0026lt; r){ quickSort(arr, left, r); } if (right \u0026gt; l){ quickSort(arr, l, right); } 归并排序 介绍 归并排序( MERGE-SORT)是利用归并的思想实现的排序方法,该算法采用经典的分治( divide-and-conquer)策略(分治法将间题分( divide)成一些小的问题然后递归求解,而治( conquer)的阶段则将分的阶段得到的各答案\u0026quot;修补\u0026quot;在起,即分而治之\n//分  public static void mergeSort(int[] arr, int left, int right, int[] temp) { if (left \u0026lt; right){ int mid = (left + right) / 2; System.out.println(mid); // 向左递归分解  mergeSort(arr, left, mid, temp); // 向右递归分解  mergeSort(arr, mid + 1, right, temp); // 合并  merge(arr, left, mid, right,temp); } } /* * @Title: merge * @Description: 合并 * @Param arr 原始数组 * @Param left 左侧初始索引 * @Param mid 中间索引 * @Param right 右侧索引 * @Param temp 中转数组 * @return void * @Author: damaicao * @Date: 2021-12-31 19:04 */ public static void merge(int[] arr, int left, int mid, int right, int[] temp) { int i = left; int j = mid + 1; int t = 0; // 先把左右两边(有序)的数据按照规则填充到temp数组  // 直到左右两边的有序序列,有一边处理完毕为止  while(i \u0026lt;= mid \u0026amp;\u0026amp; j \u0026lt;= right){ //如果左边的有序序列的当前元素,小于等于右边有序序列的当前元素  //即将左边的当前元素,拷贝到temp数组  if (arr[i] \u0026lt;= arr[j]){ temp[t++] = arr[i++]; } else{ temp[t++] = arr[j++]; } } //把有剩余数据的一边的数据依次全部填充到temp  while(i \u0026lt;= mid){ temp[t++] = arr[i++]; } while(j \u0026lt;= right){ temp[t++] = arr[j++]; } // 将temp数组的元素拷贝到arr  t = 0; int tempLeft = left; while(tempLeft \u0026lt;= right){ arr[tempLeft++] = temp[t++]; } } 基数排序 介绍  基数排序(radⅸ\tsort)属于“分配式排序”( distribution sort),又称“桶子法”( bucket sort)或 bin sort,顾名思义,它是通过键值的各个位的值,将要排序的元素分配至某些“桶”中,达到排序的作用 基数排序法是属于稳定性的排序,基数排序法的是效率高的稳定性排序法 基数排序( Radix Sort)是桶排序的扩展 基数排序是1887年赫尔曼何乐礼发明的。它是这样实现的:将整数按位数切割成不同的数字,然后按每个位数分别比较  基数排序基本思想  将所有待比较数值统一为同样的数位长度,数位较短的数前面补零。然后,从最低位开始,依次进行一次排序。这样从最低位排序一直到最高位排序完成以后,数列就变成一个有序序列 这样说明,比较难理解,下面我们看一个图文解释,理解基数排序的步骤 1)基数排序是对传统桶排序的扩展,速度很快 2)基数排序是经典的空间换时间的方式,占用内存很大,当对海量数据排序时, 容易造成 OutOfMemoryError 3)基数排序稳定的。[注:假定在待排序的记录序列中,存在多个具有相同的关键字的记录若经过排序,这些记录的相对次序保持不变,即在原列中,中,且在们之前,而在排序 后的序列中,仍在之前,则称这种排序算法是稳定的;否则称为不稳定的  相关术语解释  稳定:如果a原本在b前面,而a=b,排序之后a仍然在b的前面 不稳定:如果a原本在b的前面,而a=b,排序之后a可能会出现在b的后面 内排序:所有排序操作都在内存中成 外排序:由于数据太大,因此把数 放在磁盘中,而排序通过磁盘和内不的数据传输才能进行; 时间复杂度:—个算法执行所耗费的时间。 空间复杂度:运行完一个程序所需存的大小。 n:数据规模 k:“桶”的个数 In- place:不占用额外内存 out- place:占用额外内存 \rimage-20220102191528270\r  堆排序  堆排序是利用堆这种数据结构而设计的一种排序算法,堆排序是一种选择排序,它的最坏,最好,平均时复杂度均为 o(nlogn,它也是不稳定排序 堆是具有以下性质的元空叉树;每个结点的值都大于或等于其左右孩子结点的值,称为大顶堆,注意:没有要求结点的左孩子的值和右孩子的值的大小关系。 每个结点的值都小于或等于其左右孩子结点的值,称为小顶堆  思想  将待排序序列构造成一个大项堆 此时,整个序列的最大值就是堆顶的根节点。 将其与末尾元素进行交换,此时末尾就为最大值。 然后将剩余n-1个元素重新构造成一个堆,这样会得到n个元素的次小值。如此反复执行,便能得到一个有序序列了  ","date":"2021-12-01T01:21:44+08:00","image":"https://cdn.jsdelivr.net/gh/damaicao/damaicao-img/blog-imgs/202112010835587.webp","permalink":"https://damaicao.github.io/post/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","title":"Day02"},{"content":"\r20211118181809\r\n你好 ","date":"2021-11-26T00:22:24+08:00","image":"https://cdn.jsdelivr.net/gh/damaicao/damaicao-img/blog-imgs/20211118181809.jpg","permalink":"https://damaicao.github.io/post/%E6%96%B0%E5%8D%9A%E5%AE%A2%E7%9A%84%E7%AC%AC%E4%B8%80%E5%A4%A9/","title":"写博客的第一天"},{"content":"经典算法  汉诺塔问题 =\u0026gt; 分治算法 八皇后问题 =\u0026gt; 回溯/分治算法 马踏棋盘问题 =\u0026gt; 图的深度优化遍历算法(DFS)+贪心算法优化  主题内容  稀疏数组和队列  稀疏数组 队列   链表  单链表 双向链表 单向环形链表   栈 递归  迷宫问题 八皇后   排序算法  内部 使用内存  插入  直接 间接   选择  简单选择 堆排序   交换  冒泡 快速   归并 基数(桶排序)   外部排序 使用内存和外存   查找算法  线性查找 二分查找 插值查找 斐波那契(黄金分割法)查找   哈希表 树  二叉树  顺序存储二叉树 线索化二叉树   堆排序 赫夫曼树 赫夫曼编码 二叉排序树 平衡二叉树(AVL树)   多路查找树  二叉树与B树 2-3树 B树,B+树,B*树   图  深度优先搜索   十大算法  二分查找 分治算法 动态规划算法 KMP算法 贪心算法 普利姆算法 克鲁斯卡尔算法 迪杰斯特拉算法 弗洛伊德算法 马踏棋盘算法    ","date":"2021-11-26T00:15:58+08:00","image":"https://damaicao.github.io/image/%E5%85%83%E6%97%A6%E8%B4%BA%E5%9B%BE.png","permalink":"https://damaicao.github.io/post/%E7%AE%97%E6%B3%95%E9%97%AE%E9%A2%98/","title":"算法问题"},{"content":"\r拉菲-你不冷吗 – 锦里の画作室\r\n线性结构  数组,队列,链表, 栈\n稀疏数组 **定义:**当一个数组中大部分元素为0,或者为同一个值的数组时,可以使用稀疏数组来保存该数组。\n稀疏数组的处理方法是\n 记录数组一共有几行几列,有多少个不同的值 把具有不同值的元素的行列及值记录在一个小规模的数组中,从而缩小程序的规模  二维数组转稀硫数组的思路:\n 遍历原始的二维数组,得到有效数据的个数sum 根据sum就可以创建稀硫数组 sparseArr int[sum+1][3] 将二维数组的有效数据数据存入到稀硫数组  稀硫数组转原始的二维数组的思路:\n 先读取稀硫数组的第一行,根据第一行的数据,创建原始的二维数组,比如上面的 chessArr2=int[11[11] 在读取稀硫数组后几行的数据,并赋给原始的二维数组即可   链表 小结\n 链表是以节点的方式来存储,是 链式存储  每个节点包含data域,next域:指向下一个节点 如图:发现链表的各个节点 不一定是连续存储 链表分 带头节点的链表 和 没有头节点的链表 ,根据实际的需求来确定  双向链表  栈  栈的英文为( stack) 栈是一个先入后出( FILO-First In last out)的有序列表。 栈(stack)是限制线性表中元素的插入和删除只能在线性表的同一端进行的种特殊线性表。允许插入和删除的一端,为变化的一端,称为栈顶(Top),另端为固定的一端,称为栈底( Bottom) 根据栈的定义可知,最先放入栈中元素在栈底,最后放入的元素在栈项,而删除元素刚好相反,最后放入的元素最先删除,最先放入的元素最后删除  应用场景  子程序的调用:在跳往子程序前,会先将下个指令的地址存到堆栈中,直到子程序执行完后再将地址取出,以回到原来的程序中。 处理递归调用:和子程序的调用类似,只是除了储存下一个指令的地址外,也将参数、区域变量等数据存入堆栈中。 表达式的转换[中缀表达式转后缀表达式]与求值(实际解决)。 二叉树的遍历 图形的深度优先 (depth-first)搜索法。  前,中,后缀表达式 逆波兰表达式\n递归 简单的说：递归就是方法自己调用自己,每次调用时传入不同的变量.递归有助于编程者解决复杂的问题,同时 可以让代码变得简洁。\n递归需要遵守的重要规则\n 执行一个方法时，就创建一个新的受保护的独立空间(栈空间) 方法的局部变量是独立的，不会相互影响 递归必须向退出递归的条件逼近，否则就是无限递归，死龟了:) 当一个方法执行完毕，或者遇到return，就会返回，遵守谁调用，就将结果返回给谁，同时当方法执行完毕或者返回时，该方法也就执行完毕。  八皇后\n","date":"2021-11-26T00:15:58+08:00","image":"https://damaicao.github.io/image/%E5%85%83%E6%97%A6%E8%B4%BA%E5%9B%BE.png","permalink":"https://damaicao.github.io/post/%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84/","title":"线性结构"}]