<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>数据结构 on Damaicao的博客</title>
    <link>https://damaicao.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link>
    <description>Recent content in 数据结构 on Damaicao的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Tue, 11 Jan 2022 23:02:23 +0800</lastBuildDate><atom:link href="https://damaicao.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>十大算法</title>
      <link>https://damaicao.github.io/post/%E5%8D%81%E5%A4%A7%E7%AE%97%E6%B3%95/</link>
      <pubDate>Tue, 11 Jan 2022 23:02:23 +0800</pubDate>
      
      <guid>https://damaicao.github.io/post/%E5%8D%81%E5%A4%A7%E7%AE%97%E6%B3%95/</guid>
      <description>算法 二分查找  二分查找法只适用于从有序的数列中进行查找(比如数字和字母等)，将数列排序后再进行查找 二分查找法的运行时间为对数时间o(log2n)，即查找到需要的目标位置最多只需要log2n步，假设从[0,99]的队列(100个数，即n=100)中寻到目标数30，则需要查找步数为log2100，即最多需要查找7次(2^6&amp;lt;100 &amp;lt;2^7)  int left = 0; int right = arr.length - 1; while(left &amp;lt;= right){ int mid = (left + right) / 2; if (arr[mid] == target){ return arr[mid]; } else if (arr[mid] &amp;gt; target){ right = mid - 1; } else{ left = mid + 1; } } return -1; 分治算法   分治法是一种很重要的算法。字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题&amp;hellip;.直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。这个技巧是很多高效算法的基础，如排序算法(快速排序，归并排序)，傅立叶变换(快速傅立叶变换)&amp;hellip;.
  分治算法可以求解的一些经典问题
 二分搜索 大整数乘法 棋盘覆盖 合并排序 快速排序 线性时间选择 最接近点对问题 循环赛日程表 汉诺塔    基本步骤</description>
    </item>
    
    <item>
      <title>图</title>
      <link>https://damaicao.github.io/post/%E5%9B%BE/</link>
      <pubDate>Tue, 11 Jan 2022 11:19:09 +0800</pubDate>
      
      <guid>https://damaicao.github.io/post/%E5%9B%BE/</guid>
      <description>图 为什么用图  线性表局限于一个直接前驱和一个直接后继的关系 树也只能有一个直接前驱也就是文节点 当我们需要表示多对多的关系时，这里我们就用到了图  图是一种数据结构，其中结点可以具有零个或多个相邻元素。
两个结点之间的连接称为边。结点也可以称为顶点。
常用概念  顶点 边 路径 无向图:顶点之间的连接没有方向img 有向图img 带权图  图的表示  邻接矩阵:表示图形中顶点之间相邻关系的矩阵img 邻接表  邻接矩阵需要为每个顶点都分配n个边的空间，其实有很多边都是不存在,会造成空间的一定损失. 邻接表的实现只关心存在的边，不关心不存在的边。因此没有空间浪费，邻接表由数组+链表组成 img    图的遍历 所谓图的遍历，即是对结点的访问。一个图有那么多个结点，如何遍历这些结点，需要特定策略
一般有两种访问策略:(1深度优先遍历(⑵)广度优先遍历
深度优先遍历(Depth First Search,DFS) 基本思想  深度优先遍历，从初始访问结点出发，初始访问结点可能有多个邻接结点，深度优先遍历的策略就是首先访问第一个邻接结点，然后再以这个被访问的邻接结点作为初始结点，访问它的第一个邻接结点，可以这样理解:每次都在访问完当前结点后首先访问当前结点的第一个邻接结点。 我们可以看到，这样的访问策略是优先往纵向挖掘深入，而不是对一个结点的所有邻接结点进行横向访问。 显然，深度优先搜索是一个递归的过程  步骤  访问初始结点v，并标记结点v为已访问。 查找结点v的第一个邻接结点w。 若w存在，则继续执行4，如果w不存在，则回到第1步，将从v的下一个结点继续。 若w未被访问，对w进行深度优先遍历递归（即把w当做另一个v，然后进行步骤123） 查找结点v的w邻接结点的下一个邻接结点，转到步骤3。  广度优先搜索(BFS) 类似于一个分层搜索的过程，广度优先遍历需要使用一个队列以保持访问过的结点的顺序,以便按这个顺序来访问这些结点的邻接结点
遍历  访问初始结点v并标记结点v为已访问。 结点v入队列 当队列非空时，继续执行，否则算法结束。 出队列，取得队头结点u。 查找结点u的第一个邻接结点w。 若结点u的邻接结点w不存在，则转到步骤3;否则循环执行以下三个步骤:  若结点w尚未被访问，则访问结点w并标记为已访问。 结点w入队列 查找结点u的继w邻接结点后的下一个邻接结点w，转到步骤6。    </description>
    </item>
    
    <item>
      <title>树</title>
      <link>https://damaicao.github.io/post/%E6%A0%91/</link>
      <pubDate>Sun, 02 Jan 2022 21:32:24 +0800</pubDate>
      
      <guid>https://damaicao.github.io/post/%E6%A0%91/</guid>
      <description>哈希表(散列) 散列表(Hash table，也叫哈希表),是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。
树 数组存储方式的分析 优点:通过下标方式访问元素，速度快。对于有序数组，还可使用二分查找提高检索速度。 缺点:如果要检索具体某个值，或者插入值(按一定顺序)会整体移动，效率较低
链式存储方式的分析 优点:在一定程度上对数组存储方式有优化(比如:插入一个数值节点，只需要将插入节点，链接到链表中即可，删除效率也很好)。 缺点:在进行检索时，效率仍然较低，比如(检索某个值，需要从头节点开始遍历)
树存储方式的分析 能提高数据存储，读取的效率，比如利用二叉排序树(Binary Sort Tree)，既可以保证数据的检索速度，同时也可以保证数据的插入，删除，修改的速度。
树的常用术语(结合示意图理解)  节点 根点 交节点 子节点 叶子节点(没有子节点的节点 节点的权(节点值) 路径(从root节点找到该节点的路线) 层 子树 树的高度(最大层数 森林:多颗子树构成森林  二叉树 概念  树有很多种,每个节点最多只能有两个子节点的一种形式称为二叉树 二叉树的子节点分为左节点和右节点 如果该二叉树的所有叶子节点都在最后一层,并且结点总数=2^n-1,n为层数,则我们称为满二叉树 如果该二叉树的所有叶子节点都在最后一层或者倒数第二层,而且最后一层的叶子节点在左边连续,倒数第二层的叶子节点在右边连续,我们称为完全二叉树。  遍历  前序遍历:先输出父节点,再遍历左子树和右子树 中序遍历:先遍历左子树,再父节点,右子树 后序遍历:先遍历左子树,再遍历右子树,最后输出父节点 小结:看输出父节点的顺序,就确定是前序,中序,是后序  分析二又树的前序,中序,后序的遍历步骤
 创建一颗二叉树 前序遍历  先输出当前节点(初始的时候是root节点 如果左子节点不为空,则递归继续前序遍历 如果右子节点不为空,则递归继续前序遍历   中序遍历  如果当前节点的左子节点不为空,则递归中序遍历 输出当前节点 如果当前节点的右子节点不为空,则递归中序遍历   后序遍历  如果当前节点的左子节点不为空,则递归后序遍历 如果当前节点的右子节点不为空,则递归后序遍历 输出当前节点    查找  使用前序,中序,后序的方式来查询指定的结点 前序查找思路  先判断当前结点的no是否等于要查找的 如果是相等,则返回当前结点 如果不等,则判断当前结点的左子节点是否为空,如果不为空,则递归前序查找 如果左递归前序查找,找到结点,则返回,否继续判断,当前的结点的右子节点是否为空,如果不空,则继续向右递归前序查找   中序查找思路  判断当前结点的左子节点是否为空,如果不为空,则递归中序查找 如果找到,则返回,如果没有找到,就和当前结点比较,如果是则返回当前结点,否则继续进行右递归的中序查找 如果右递归中序查找,找到就返回,否则返回null   后序查找思路  判断当前结点的左子节点是否为空,如果不为空,则递归后序查找 如果找到,就返回,如果没有找到,就判断当前结点的右子节点是否为空,如果不为空,则右递归进行后序查找如果找到,就返回 就和当前结点进行,比如,如果是则返回,否则返回null    删除   完成删除结点的操作</description>
    </item>
    
    <item>
      <title>查找算法</title>
      <link>https://damaicao.github.io/post/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/</link>
      <pubDate>Sun, 02 Jan 2022 19:16:57 +0800</pubDate>
      
      <guid>https://damaicao.github.io/post/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/</guid>
      <description>查找算法 介绍  顺序(线性)查找 二分查找/折半查找 插值查找 斐波那契查找  线性查找 for (int i = 0; i &amp;lt; arr.length; i++) { if (arr[i] == value) { return i; } } return -1; 二分查找 返回目标索引
// if left &amp;gt; right == not find  if (left &amp;gt; right){ return -1; } int mid = (left + right) / 2; int midVal = arr[mid]; if (findVal &amp;gt; midVal){ return binarySearch(arr, mid+1 , right, findVal); } else if (findVal &amp;lt; midVal){ return binarySearch(arr, left, mid-1, findVal); } else{ return mid; } 返回所有目标索引</description>
    </item>
    
    <item>
      <title>Day02</title>
      <link>https://damaicao.github.io/post/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</link>
      <pubDate>Wed, 01 Dec 2021 01:21:44 +0800</pubDate>
      
      <guid>https://damaicao.github.io/post/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</guid>
      <description>图片
排序算法 排序也称排序算法 (Sort Algorithm) 是将一组数据，依指定的顺序进行排列的过程
排序的分类
 内部排序:指将需要处理的所有数据都加载到 内部存储器 中进行排序。  外部排序法:数据量过大，无法全部加载到内存中，需要借助 外部存储 进行排序。  image-20211128000834503
算法时间复杂度 度量一个程序(算法)执行时间的方法
  事后统计法
这种方法可行,但是有两个问题：一是要想对设计的算法的运行性能进行评测，需要 实际运行该程序；二是所得时间的统计量依赖于计算机的硬件、软件等环境因素,
这种方式，要在同一台计算机的相同状态下运行，才能比较那个算法速度更快。
  事前估算法
通过分析某个算法的时间复杂度来判断哪个算法更优.
  时间频度 时间频度：一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多,它花费时间就多。一个算法中的语句执行次数称为语句频度或时间频度. 记为T(n)。[举例说明]
 忽略常数项, 低次项,系数  时间复杂度  一般情况下，算法中的基本操作语句的重复执行次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n)，使得当n趋近于无穷大时，T(n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作 T(n)= O（f(n))，称O（f(n)）为算法的渐进时间复杂度，简称 时间复杂度 。  T(n)不同，但时间复杂度可能相同。如：T(n)=n2+7n+6与T(n)=3n2+2n+2它们的T(n)不同，但时间复杂度相同，都为O(n2)。 计算时间复杂度的方法： 用常数1代替运行时间中的所有加法常数 T(n)=n2+7n+6 =&amp;gt; T(n)=n2+7n+1 修改后的运行次数函数中，只保留最高阶项 去除最高阶项的系数  常见的时间复杂度 根据从小到大排列，常见的算法时间复杂度主要有：
O(1) &amp;lt; O(log N) &amp;lt; O(N) &amp;lt; O(Nlog N) &amp;lt; O(N^2) &amp;lt; O(2^N) &amp;lt; O(N!</description>
    </item>
    
    <item>
      <title>算法问题</title>
      <link>https://damaicao.github.io/post/%E7%AE%97%E6%B3%95%E9%97%AE%E9%A2%98/</link>
      <pubDate>Fri, 26 Nov 2021 00:15:58 +0800</pubDate>
      
      <guid>https://damaicao.github.io/post/%E7%AE%97%E6%B3%95%E9%97%AE%E9%A2%98/</guid>
      <description>经典算法  汉诺塔问题 =&amp;gt; 分治算法 八皇后问题 =&amp;gt; 回溯/分治算法 马踏棋盘问题 =&amp;gt; 图的深度优化遍历算法(DFS)+贪心算法优化  主题内容  稀疏数组和队列  稀疏数组 队列   链表  单链表 双向链表 单向环形链表   栈 递归  迷宫问题 八皇后   排序算法  内部 使用内存  插入  直接 间接   选择  简单选择 堆排序   交换  冒泡 快速   归并 基数(桶排序)   外部排序 使用内存和外存   查找算法  线性查找 二分查找 插值查找 斐波那契(黄金分割法)查找   哈希表 树  二叉树  顺序存储二叉树 线索化二叉树   堆排序 赫夫曼树 赫夫曼编码 二叉排序树 平衡二叉树(AVL树)   多路查找树  二叉树与B树 2-3树 B树,B+树,B*树   图  深度优先搜索   十大算法  二分查找 分治算法 动态规划算法 KMP算法 贪心算法 普利姆算法 克鲁斯卡尔算法 迪杰斯特拉算法 弗洛伊德算法 马踏棋盘算法    </description>
    </item>
    
    <item>
      <title>线性结构</title>
      <link>https://damaicao.github.io/post/%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84/</link>
      <pubDate>Fri, 26 Nov 2021 00:15:58 +0800</pubDate>
      
      <guid>https://damaicao.github.io/post/%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84/</guid>
      <description>拉菲-你不冷吗 – 锦里の画作室
线性结构  数组,队列,链表, 栈
稀疏数组 **定义:**当一个数组中大部分元素为0,或者为同一个值的数组时,可以使用稀疏数组来保存该数组。
稀疏数组的处理方法是
 记录数组一共有几行几列,有多少个不同的值 把具有不同值的元素的行列及值记录在一个小规模的数组中,从而缩小程序的规模  二维数组转稀硫数组的思路:
 遍历原始的二维数组,得到有效数据的个数sum 根据sum就可以创建稀硫数组 sparseArr int[sum+1][3] 将二维数组的有效数据数据存入到稀硫数组  稀硫数组转原始的二维数组的思路:
 先读取稀硫数组的第一行,根据第一行的数据,创建原始的二维数组,比如上面的 chessArr2=int[11[11] 在读取稀硫数组后几行的数据,并赋给原始的二维数组即可   链表 小结
 链表是以节点的方式来存储,是 链式存储  每个节点包含data域,next域:指向下一个节点 如图:发现链表的各个节点 不一定是连续存储 链表分 带头节点的链表 和 没有头节点的链表 ,根据实际的需求来确定  双向链表  栈  栈的英文为( stack) 栈是一个先入后出( FILO-First In last out)的有序列表。 栈(stack)是限制线性表中元素的插入和删除只能在线性表的同一端进行的种特殊线性表。允许插入和删除的一端,为变化的一端,称为栈顶(Top),另端为固定的一端,称为栈底( Bottom) 根据栈的定义可知,最先放入栈中元素在栈底,最后放入的元素在栈项,而删除元素刚好相反,最后放入的元素最先删除,最先放入的元素最后删除  应用场景  子程序的调用:在跳往子程序前,会先将下个指令的地址存到堆栈中,直到子程序执行完后再将地址取出,以回到原来的程序中。 处理递归调用:和子程序的调用类似,只是除了储存下一个指令的地址外,也将参数、区域变量等数据存入堆栈中。 表达式的转换[中缀表达式转后缀表达式]与求值(实际解决)。 二叉树的遍历 图形的深度优先 (depth-first)搜索法。  前,中,后缀表达式 逆波兰表达式</description>
    </item>
    
  </channel>
</rss>
