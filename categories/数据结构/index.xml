<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>数据结构 on Damaicao的博客</title>
    <link>https://damaicao.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link>
    <description>Recent content in 数据结构 on Damaicao的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Wed, 01 Dec 2021 01:21:44 +0800</lastBuildDate><atom:link href="https://damaicao.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Day02</title>
      <link>https://damaicao.github.io/post/day02/</link>
      <pubDate>Wed, 01 Dec 2021 01:21:44 +0800</pubDate>
      
      <guid>https://damaicao.github.io/post/day02/</guid>
      <description>图片
排序算法 排序也称排序算法 (Sort Algorithm) 是将一组数据，依指定的顺序进行排列的过程
排序的分类
 内部排序:指将需要处理的所有数据都加载到 内部存储器 中进行排序。  外部排序法:数据量过大，无法全部加载到内存中，需要借助 外部存储 进行排序。  image-20211128000834503
算法时间复杂度 度量一个程序(算法)执行时间的方法
  事后统计法
这种方法可行,但是有两个问题：一是要想对设计的算法的运行性能进行评测，需要 实际运行该程序；二是所得时间的统计量依赖于计算机的硬件、软件等环境因素,
这种方式，要在同一台计算机的相同状态下运行，才能比较那个算法速度更快。
  事前估算法
通过分析某个算法的时间复杂度来判断哪个算法更优.
  时间频度 时间频度：一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多,它花费时间就多。一个算法中的语句执行次数称为语句频度或时间频度. 记为T(n)。[举例说明]
 忽略常数项, 低次项,系数  时间复杂度  一般情况下，算法中的基本操作语句的重复执行次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n)，使得当n趋近于无穷大时，T(n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作 T(n)= O（f(n))，称O（f(n)）为算法的渐进时间复杂度，简称 时间复杂度 。  T(n)不同，但时间复杂度可能相同。如：T(n)=n2+7n+6与T(n)=3n2+2n+2它们的T(n)不同，但时间复杂度相同，都为O(n2)。 计算时间复杂度的方法： 用常数1代替运行时间中的所有加法常数 T(n)=n2+7n+6 =&amp;gt; T(n)=n2+7n+1 修改后的运行次数函数中，只保留最高阶项 去除最高阶项的系数  常见的时间复杂度 根据从小到大排列，常见的算法时间复杂度主要有：
O(1) &amp;lt; O(log N) &amp;lt; O(N) &amp;lt; O(Nlog N) &amp;lt; O(N^2) &amp;lt; O(2^N) &amp;lt; O(N!</description>
    </item>
    
    <item>
      <title>Day01</title>
      <link>https://damaicao.github.io/post/day01/</link>
      <pubDate>Fri, 26 Nov 2021 00:15:58 +0800</pubDate>
      
      <guid>https://damaicao.github.io/post/day01/</guid>
      <description>拉菲-你不冷吗 – 锦里の画作室
线性结构  数组,队列,链表, 栈
稀疏数组 **定义:**当一个数组中大部分元素为0,或者为同一个值的数组时,可以使用稀疏数组来保存该数组。
稀疏数组的处理方法是
 记录数组一共有几行几列,有多少个不同的值 把具有不同值的元素的行列及值记录在一个小规模的数组中,从而缩小程序的规模  二维数组转稀硫数组的思路:
 遍历原始的二维数组,得到有效数据的个数sum 根据sum就可以创建稀硫数组 sparseArr int[sum+1][3] 将二维数组的有效数据数据存入到稀硫数组  稀硫数组转原始的二维数组的思路:
 先读取稀硫数组的第一行,根据第一行的数据,创建原始的二维数组,比如上面的 chessArr2=int[11[11] 在读取稀硫数组后几行的数据,并赋给原始的二维数组即可   链表 小结
 链表是以节点的方式来存储,是 链式存储  每个节点包含data域,next域:指向下一个节点 如图:发现链表的各个节点 不一定是连续存储 链表分 带头节点的链表 和 没有头节点的链表 ,根据实际的需求来确定  双向链表  栈  栈的英文为( stack) 栈是一个先入后出( FILO-First In last out)的有序列表。 栈(stack)是限制线性表中元素的插入和删除只能在线性表的同一端进行的种特殊线性表。允许插入和删除的一端,为变化的一端,称为栈顶(Top),另端为固定的一端,称为栈底( Bottom) 根据栈的定义可知,最先放入栈中元素在栈底,最后放入的元素在栈项,而删除元素刚好相反,最后放入的元素最先删除,最先放入的元素最后删除  应用场景  子程序的调用:在跳往子程序前,会先将下个指令的地址存到堆栈中,直到子程序执行完后再将地址取出,以回到原来的程序中。 处理递归调用:和子程序的调用类似,只是除了储存下一个指令的地址外,也将参数、区域变量等数据存入堆栈中。 表达式的转换[中缀表达式转后缀表达式]与求值(实际解决)。 二叉树的遍历 图形的深度优先 (depth-first)搜索法。  前,中,后缀表达式 逆波兰表达式</description>
    </item>
    
    <item>
      <title>算法问题</title>
      <link>https://damaicao.github.io/post/%E7%AE%97%E6%B3%95%E9%97%AE%E9%A2%98/</link>
      <pubDate>Fri, 26 Nov 2021 00:15:58 +0800</pubDate>
      
      <guid>https://damaicao.github.io/post/%E7%AE%97%E6%B3%95%E9%97%AE%E9%A2%98/</guid>
      <description>经典算法  汉诺塔问题 =&amp;gt; 分治算法 八皇后问题 =&amp;gt; 回溯/分治算法 马踏棋盘问题 =&amp;gt; 图的深度优化遍历算法(DFS)+贪心算法优化  主题内容  稀疏数组和队列  稀疏数组 队列   链表  单链表 双向链表 单向环形链表   栈 递归  迷宫问题 八皇后   排序算法  内部 使用内存  插入  直接 间接   选择  简单选择 堆排序   交换  冒泡 快速   归并 基数(桶排序)   外部排序 使用内存和外存   查找算法  线性查找 二分查找 插值查找 斐波那契(黄金分割法)查找   哈希表 树  二叉树  顺序存储二叉树 线索化二叉树   堆排序 赫夫曼树 赫夫曼编码 二叉排序树 平衡二叉树(AVL树)   多路查找树  二叉树与B树 2-3树 B树,B+树,B*树   图  深度优先搜索   十大算法  二分查找 分治算法 动态规划算法 KMP算法 贪心算法 普利姆算法 克鲁斯卡尔算法 迪杰斯特拉算法 弗洛伊德算法 马踏棋盘算法    </description>
    </item>
    
  </channel>
</rss>
