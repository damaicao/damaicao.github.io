<!DOCTYPE html>
<html lang="zh-cn">
    <head><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content='哈希表(散列) 散列表(Hash table，也叫哈希表),是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。
树 数组存储方式的分析 优点:通过下标方式访问元素，速度快。对于有序数组，还可使用二分查找提高检索速度。 缺点:如果要检索具体某个值，或者插入值(按一定顺序)会整体移动，效率较低
链式存储方式的分析 优点:在一定程度上对数组存储方式有优化(比如:插入一个数值节点，只需要将插入节点，链接到链表中即可，删除效率也很好)。 缺点:在进行检索时，效率仍然较低，比如(检索某个值，需要从头节点开始遍历)
树存储方式的分析 能提高数据存储，读取的效率，比如利用二叉排序树(Binary Sort Tree)，既可以保证数据的检索速度，同时也可以保证数据的插入，删除，修改的速度。
树的常用术语(结合示意图理解)  节点 根点 交节点 子节点 叶子节点(没有子节点的节点 节点的权(节点值) 路径(从root节点找到该节点的路线) 层 子树 树的高度(最大层数 森林:多颗子树构成森林  二叉树 概念  树有很多种,每个节点最多只能有两个子节点的一种形式称为二叉树 二叉树的子节点分为左节点和右节点 如果该二叉树的所有叶子节点都在最后一层,并且结点总数=2^n-1,n为层数,则我们称为满二叉树 如果该二叉树的所有叶子节点都在最后一层或者倒数第二层,而且最后一层的叶子节点在左边连续,倒数第二层的叶子节点在右边连续,我们称为完全二叉树。  遍历  前序遍历:先输出父节点,再遍历左子树和右子树 中序遍历:先遍历左子树,再父节点,右子树 后序遍历:先遍历左子树,再遍历右子树,最后输出父节点 小结:看输出父节点的顺序,就确定是前序,中序,是后序  分析二又树的前序,中序,后序的遍历步骤
 创建一颗二叉树 前序遍历  先输出当前节点(初始的时候是root节点 如果左子节点不为空,则递归继续前序遍历 如果右子节点不为空,则递归继续前序遍历   中序遍历  如果当前节点的左子节点不为空,则递归中序遍历 输出当前节点 如果当前节点的右子节点不为空,则递归中序遍历   后序遍历  如果当前节点的左子节点不为空,则递归后序遍历 如果当前节点的右子节点不为空,则递归后序遍历 输出当前节点    查找  使用前序,中序,后序的方式来查询指定的结点 前序查找思路  先判断当前结点的no是否等于要查找的 如果是相等,则返回当前结点 如果不等,则判断当前结点的左子节点是否为空,如果不为空,则递归前序查找 如果左递归前序查找,找到结点,则返回,否继续判断,当前的结点的右子节点是否为空,如果不空,则继续向右递归前序查找   中序查找思路  判断当前结点的左子节点是否为空,如果不为空,则递归中序查找 如果找到,则返回,如果没有找到,就和当前结点比较,如果是则返回当前结点,否则继续进行右递归的中序查找 如果右递归中序查找,找到就返回,否则返回null   后序查找思路  判断当前结点的左子节点是否为空,如果不为空,则递归后序查找 如果找到,就返回,如果没有找到,就判断当前结点的右子节点是否为空,如果不为空,则右递归进行后序查找如果找到,就返回 就和当前结点进行,比如,如果是则返回,否则返回null    删除   完成删除结点的操作'><title>树</title>

<link rel='canonical' href='https://damaicao.github.io/post/%E6%A0%91/'>

<link rel="stylesheet" href="/scss/style.min.css"><meta property='og:title' content='树'>
<meta property='og:description' content='哈希表(散列) 散列表(Hash table，也叫哈希表),是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。
树 数组存储方式的分析 优点:通过下标方式访问元素，速度快。对于有序数组，还可使用二分查找提高检索速度。 缺点:如果要检索具体某个值，或者插入值(按一定顺序)会整体移动，效率较低
链式存储方式的分析 优点:在一定程度上对数组存储方式有优化(比如:插入一个数值节点，只需要将插入节点，链接到链表中即可，删除效率也很好)。 缺点:在进行检索时，效率仍然较低，比如(检索某个值，需要从头节点开始遍历)
树存储方式的分析 能提高数据存储，读取的效率，比如利用二叉排序树(Binary Sort Tree)，既可以保证数据的检索速度，同时也可以保证数据的插入，删除，修改的速度。
树的常用术语(结合示意图理解)  节点 根点 交节点 子节点 叶子节点(没有子节点的节点 节点的权(节点值) 路径(从root节点找到该节点的路线) 层 子树 树的高度(最大层数 森林:多颗子树构成森林  二叉树 概念  树有很多种,每个节点最多只能有两个子节点的一种形式称为二叉树 二叉树的子节点分为左节点和右节点 如果该二叉树的所有叶子节点都在最后一层,并且结点总数=2^n-1,n为层数,则我们称为满二叉树 如果该二叉树的所有叶子节点都在最后一层或者倒数第二层,而且最后一层的叶子节点在左边连续,倒数第二层的叶子节点在右边连续,我们称为完全二叉树。  遍历  前序遍历:先输出父节点,再遍历左子树和右子树 中序遍历:先遍历左子树,再父节点,右子树 后序遍历:先遍历左子树,再遍历右子树,最后输出父节点 小结:看输出父节点的顺序,就确定是前序,中序,是后序  分析二又树的前序,中序,后序的遍历步骤
 创建一颗二叉树 前序遍历  先输出当前节点(初始的时候是root节点 如果左子节点不为空,则递归继续前序遍历 如果右子节点不为空,则递归继续前序遍历   中序遍历  如果当前节点的左子节点不为空,则递归中序遍历 输出当前节点 如果当前节点的右子节点不为空,则递归中序遍历   后序遍历  如果当前节点的左子节点不为空,则递归后序遍历 如果当前节点的右子节点不为空,则递归后序遍历 输出当前节点    查找  使用前序,中序,后序的方式来查询指定的结点 前序查找思路  先判断当前结点的no是否等于要查找的 如果是相等,则返回当前结点 如果不等,则判断当前结点的左子节点是否为空,如果不为空,则递归前序查找 如果左递归前序查找,找到结点,则返回,否继续判断,当前的结点的右子节点是否为空,如果不空,则继续向右递归前序查找   中序查找思路  判断当前结点的左子节点是否为空,如果不为空,则递归中序查找 如果找到,则返回,如果没有找到,就和当前结点比较,如果是则返回当前结点,否则继续进行右递归的中序查找 如果右递归中序查找,找到就返回,否则返回null   后序查找思路  判断当前结点的左子节点是否为空,如果不为空,则递归后序查找 如果找到,就返回,如果没有找到,就判断当前结点的右子节点是否为空,如果不为空,则右递归进行后序查找如果找到,就返回 就和当前结点进行,比如,如果是则返回,否则返回null    删除   完成删除结点的操作'>
<meta property='og:url' content='https://damaicao.github.io/post/%E6%A0%91/'>
<meta property='og:site_name' content='Damaicao的博客'>
<meta property='og:type' content='article'><meta property='article:section' content='Post' /><meta property='article:tag' content='数据结构' /><meta property='article:published_time' content='2022-01-02T21:32:24&#43;08:00'/><meta property='article:modified_time' content='2022-01-02T21:32:24&#43;08:00'/>
<meta name="twitter:title" content="树">
<meta name="twitter:description" content="哈希表(散列) 散列表(Hash table，也叫哈希表),是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。
树 数组存储方式的分析 优点:通过下标方式访问元素，速度快。对于有序数组，还可使用二分查找提高检索速度。 缺点:如果要检索具体某个值，或者插入值(按一定顺序)会整体移动，效率较低
链式存储方式的分析 优点:在一定程度上对数组存储方式有优化(比如:插入一个数值节点，只需要将插入节点，链接到链表中即可，删除效率也很好)。 缺点:在进行检索时，效率仍然较低，比如(检索某个值，需要从头节点开始遍历)
树存储方式的分析 能提高数据存储，读取的效率，比如利用二叉排序树(Binary Sort Tree)，既可以保证数据的检索速度，同时也可以保证数据的插入，删除，修改的速度。
树的常用术语(结合示意图理解)  节点 根点 交节点 子节点 叶子节点(没有子节点的节点 节点的权(节点值) 路径(从root节点找到该节点的路线) 层 子树 树的高度(最大层数 森林:多颗子树构成森林  二叉树 概念  树有很多种,每个节点最多只能有两个子节点的一种形式称为二叉树 二叉树的子节点分为左节点和右节点 如果该二叉树的所有叶子节点都在最后一层,并且结点总数=2^n-1,n为层数,则我们称为满二叉树 如果该二叉树的所有叶子节点都在最后一层或者倒数第二层,而且最后一层的叶子节点在左边连续,倒数第二层的叶子节点在右边连续,我们称为完全二叉树。  遍历  前序遍历:先输出父节点,再遍历左子树和右子树 中序遍历:先遍历左子树,再父节点,右子树 后序遍历:先遍历左子树,再遍历右子树,最后输出父节点 小结:看输出父节点的顺序,就确定是前序,中序,是后序  分析二又树的前序,中序,后序的遍历步骤
 创建一颗二叉树 前序遍历  先输出当前节点(初始的时候是root节点 如果左子节点不为空,则递归继续前序遍历 如果右子节点不为空,则递归继续前序遍历   中序遍历  如果当前节点的左子节点不为空,则递归中序遍历 输出当前节点 如果当前节点的右子节点不为空,则递归中序遍历   后序遍历  如果当前节点的左子节点不为空,则递归后序遍历 如果当前节点的右子节点不为空,则递归后序遍历 输出当前节点    查找  使用前序,中序,后序的方式来查询指定的结点 前序查找思路  先判断当前结点的no是否等于要查找的 如果是相等,则返回当前结点 如果不等,则判断当前结点的左子节点是否为空,如果不为空,则递归前序查找 如果左递归前序查找,找到结点,则返回,否继续判断,当前的结点的右子节点是否为空,如果不空,则继续向右递归前序查找   中序查找思路  判断当前结点的左子节点是否为空,如果不为空,则递归中序查找 如果找到,则返回,如果没有找到,就和当前结点比较,如果是则返回当前结点,否则继续进行右递归的中序查找 如果右递归中序查找,找到就返回,否则返回null   后序查找思路  判断当前结点的左子节点是否为空,如果不为空,则递归后序查找 如果找到,就返回,如果没有找到,就判断当前结点的右子节点是否为空,如果不为空,则右递归进行后序查找如果找到,就返回 就和当前结点进行,比如,如果是则返回,否则返回null    删除   完成删除结点的操作">
    <link rel="shortcut icon" href="img/favicon.ico" />

    </head>
    <body class="
    article-page has-toc
">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex 
    
        extended
    
">
    
        <div id="article-toolbar">
            <a href="/" class="back-home">
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-chevron-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="15 6 9 12 15 18" />
</svg>



                <span>返回</span>
            </a>
        </div>
    
<main class="main full-width">
    <article class="main-article">
    <header class="article-header">

    <div class="article-details">
    
    <header class="article-category">
        
            <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" >
                数据结构
            </a>
        
    </header>
    

    <h2 class="article-title">
        <a href="/post/%E6%A0%91/">树</a>
    </h2>

    

    
    <footer class="article-time">
        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4" />
  <circle cx="18" cy="18" r="4" />
  <path d="M15 3v4" />
  <path d="M7 3v4" />
  <path d="M3 11h16" />
  <path d="M18 16.496v1.504l1 1" />
</svg>
                <time class="article-time--published">Jan 02, 2022</time>
            </div>
        

        
    </footer>
    
</div>
</header>

    <section class="article-content">
    <h1 id="哈希表散列">哈希表(散列)</h1>
<p><strong>散列表</strong>(Hash table，也叫哈希表),是根据<code>关键码值(Key value)</code>而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做<code>散列函数</code>，存放记录的数组叫做<code>散列表</code>。</p>
<h1 id="树">树</h1>
<h2 id="数组存储方式的分析"><strong>数组存储方式的分析</strong></h2>
<p>优点:通过下标方式访问元素，速度快。对于有序数组，还可使用二分查找提高检索速度。
缺点:如果要检索具体某个值，或者插入值(按一定顺序)会整体移动，效率较低</p>
<h2 id="链式存储方式的分析"><strong>链式存储方式的分析</strong></h2>
<p>优点:在一定程度上对数组存储方式有优化(比如:插入一个数值节点，只需要将插入节点，链接到链表中即可，删除效率也很好)。
缺点:在进行检索时，效率仍然较低，比如(检索某个值，需要从头节点开始遍历)</p>
<h2 id="树存储方式的分析"><strong>树存储方式的分析</strong></h2>
<p>能提高数据存储，读取的效率，比如利用二叉排序树(Binary Sort Tree)，既可以保证数据的检索速度，同时也可以保证数据的插入，删除，修改的速度。</p>
<h2 id="树的常用术语结合示意图理解">树的常用术语(结合示意图理解)</h2>
<ol>
<li>节点</li>
<li>根点</li>
<li>交节点</li>
<li>子节点</li>
<li>叶子节点(没有子节点的节点</li>
<li>节点的权(节点值)</li>
<li>路径(从root节点找到该节点的路线)</li>
<li>层</li>
<li>子树</li>
<li>树的高度(最大层数</li>
<li>森林:多颗子树构成森林</li>
</ol>
<h2 id="二叉树">二叉树</h2>
<h3 id="概念">概念</h3>
<ol>
<li>树有很多种,每个节点最多只能有两个子节点的一种形式称为二叉树</li>
<li>二叉树的子节点分为左节点和右节点</li>
<li>如果该二叉树的所有叶子节点都在最后一层,并且结点总数=2^n-1,n为层数,则我们称为满二叉树</li>
<li>如果该二叉树的所有叶子节点都在最后一层或者倒数第二层,而且最后一层的叶子节点在左边连续,倒数第二层的叶子节点在右边连续,我们称为完全二叉树。</li>
</ol>
<h3 id="遍历">遍历</h3>
<ol>
<li>前序遍历:先输出父节点,再遍历左子树和右子树</li>
<li>中序遍历:先遍历左子树,再父节点,右子树</li>
<li>后序遍历:先遍历左子树,再遍历右子树,最后输出父节点</li>
<li><strong>小结</strong>:看输出父节点的顺序,就确定是前序,中序,是后序</li>
</ol>
<p>分析二又树的前序,中序,后序的遍历步骤</p>
<ol>
<li>创建一颗二叉树</li>
<li>前序遍历
<ol>
<li>先输出当前节点(初始的时候是root节点</li>
<li>如果左子节点不为空,则递归继续前序遍历</li>
<li>如果右子节点不为空,则递归继续前序遍历</li>
</ol>
</li>
<li>中序遍历
<ol>
<li>如果当前节点的左子节点不为空,则递归中序遍历</li>
<li>输出当前节点</li>
<li>如果当前节点的右子节点不为空,则递归中序遍历</li>
</ol>
</li>
<li>后序遍历
<ol>
<li>如果当前节点的左子节点不为空,则递归后序遍历</li>
<li>如果当前节点的右子节点不为空,则递归后序遍历</li>
<li>输出当前节点</li>
</ol>
</li>
</ol>
<h3 id="查找">查找</h3>
<ol>
<li>使用前序,中序,后序的方式来查询指定的结点</li>
<li><strong>前序查找思路</strong>
<ol>
<li>先判断当前结点的no是否等于要查找的</li>
<li>如果是相等,则返回当前结点</li>
<li>如果不等,则判断当前结点的左子节点是否为空,如果不为空,则递归前序查找</li>
<li>如果左递归前序查找,找到结点,则返回,否继续判断,当前的结点的右子节点是否为空,如果不空,则继续向右递归前序查找</li>
</ol>
</li>
<li><strong>中序查找思路</strong>
<ol>
<li>判断当前结点的左子节点是否为空,如果不为空,则递归中序查找</li>
<li>如果找到,则返回,如果没有找到,就和当前结点比较,如果是则返回当前结点,否则继续进行右递归的中序查找</li>
<li>如果右递归中序查找,找到就返回,否则返回null</li>
</ol>
</li>
<li><strong>后序查找思路</strong>
<ol>
<li>判断当前结点的左子节点是否为空,如果不为空,则递归后序查找</li>
<li>如果找到,就返回,如果没有找到,就判断当前结点的右子节点是否为空,如果不为空,则右递归进行后序查找如果找到,就返回</li>
<li>就和当前结点进行,比如,如果是则返回,否则返回null</li>
</ol>
</li>
</ol>
<h3 id="删除">删除</h3>
<ol>
<li>
<p>完成删除结点的操作</p>
</li>
<li>
<p>规定</p>
<ol>
<li>如果删除的节点是叶子节点,则删除该节点</li>
<li>如果删除的节点是非叶子节点,则删除该子树</li>
</ol>
</li>
<li>
<p>思路</p>
<ol>
<li>首先先处理</li>
<li>考虑如果树是空树root,如果只有一个root结点,则等价将二叉树置空</li>
</ol>
</li>
<li>
<p>然后进行下面步骤</p>
<ol>
<li>因为我们的二叉树是单向的,所以我们是判斷当前结点的子结点是否需要删除结点而不能去判断当前这个结点是不是需要删除结点</li>
<li>如果当前结点的左子结点不为空,并且左子结点就是要删除结点,就将 this.left=null 并且就返回(结束递归删除</li>
<li>如果当前结点的右子结点不为空,并且右子结点就是要删除结点,就将 this.right=null并且就返回(结束递归删除</li>
<li>如果第2和第3步没有删除结点,那么我们就需要向左子树进行递归删除</li>
<li>如果第4步也没有删除结点,则应当向右子树进行递归删除</li>
</ol>
</li>
</ol>
<h2 id="顺序存储二叉树">顺序存储二叉树</h2>
<p>从数据存储来看,数组存储方式和树的存储方式可以相互转换,即数组可以转换成树,树也可以转换成数组</p>
<p>特点</p>
<ol>
<li>顺序二叉树通常只考虑完全二又树</li>
<li>第n个元素的左子节点为2*n+1</li>
<li>第n个元素的右子节点为2*n+2</li>
<li>第n个元素的父节点为(n-1)/2</li>
<li>n表示二叉树中的第几个元素</li>
</ol>
<h3 id="线索化二叉树">线索化二叉树</h3>
<ol>
<li>n个结点的二叉链表中含有n+1【公式2n-(n-1)=n+1】个空指针域。利用叉链表中的空指针域,存放指向该结点在<strong>某种遍历次序</strong>下的前驱和后继结点的指针(这种附加的指针称为&quot;线索&quot;)</li>
<li>这种加上了线索的二叉链表称为<strong>线索链表</strong>,相应的二叉树称为<strong>线索二叉树(</strong> Threaded BinaryTree)。根据线索性质的不同,线索二叉树可分为<code>前序线索二叉树</code>、<code>中序线索二叉树</code>和<code>后序线索二叉树</code>三种</li>
<li>一个结点的前一个结点,称为前驱结点</li>
<li>一个结点的后一个结点,称为后继结点</li>
</ol>
<p>说明:当线索化二叉树后,Node节点的属性left和 right,有如下情况:</p>
<ol>
<li>left指向的是左子树,也可能是指向的前驱节点</li>
<li>right指向的是右子树,也可能是指向后继节点</li>
<li><figure 
	>
	<a href="https://cdn.jsdelivr.net/gh/damaicao/damaicao-img/blog-imgs/202201061551215.png" >
		<img src="https://cdn.jsdelivr.net/gh/damaicao/damaicao-img/blog-imgs/202201061551215.png"
			
			
			
			loading="lazy"
			alt="image-20220106155105122">
	</a>
	
	<figcaption>image-20220106155105122</figcaption>
	
</figure></li>
</ol>
<h2 id="赫夫曼树">赫夫曼树</h2>
<p>给定n个权值作为n个叶子结点,构造一棵二又树,若该树的<strong>带权路径长度wpl</strong>达到最小,称这样的二叉树为<strong>最优二叉树</strong>,也称为<strong>哈夫曼树</strong>,还有的书翻译为霍夫曼树。</p>
<p><strong>赫夫曼树</strong>是带权路径长度最短的树,权值较大的结点离根较近</p>
<p><strong>路径和路径长度</strong>:在一棵树中,从一个结点往下可以达到的孩子或孙子结点之间的通路,称为路径。通路中分支的数目称为路径长度。若规定根结点的层数为1,则从根结点到第L层结点的路径长度为L-1</p>
<p><strong>结点的权及带权路径长度</strong>:若将树中结点赋给一个有着某种含义的数值,则这个数值称为该结点的权。</p>
<p><strong>结点的带权路径长度为</strong>:从根结点到该结点之间的路径长度与该结点的权的乘积</p>
<p><strong>树的带权路径长度</strong>:树的带权路径长度规定为所有叶子结点的带权路径长度之和,记为 WPL(weighted path length)权值越大的结点离根结点越近的二叉树才是最优二叉树。</p>
<p><strong>WPL最小的就是赫夫曼树</strong></p>
<p><strong>赫夫曼树的步骤</strong></p>
<ol>
<li>从小到大进行排序,将每一个数据,每个数据都是一个节点,每个节点可以看成是颗最简单的二叉树</li>
<li>取出根节点权值最小的两颗二叉树</li>
<li>组成一颗新的二叉树,该新的二叉树的根节点的权值是前面两颗二叉树根节点权值的和</li>
<li>再将这颗新的二叉树,以根节点的权值大小再次排序,不断重复1-2-3-4的步骤,直到数列中,所有的数据都被处理,就得到一颗赫夫曼树</li>
</ol>
<h5 id="赫夫曼编码">赫夫曼编码</h5>
<ol>
<li>赫夫曼编码也翻译为<strong>哈夫曼编码</strong>( Huffman Coding),又称霍夫曼编码,是一种编玛方式属于一种程序算法</li>
<li>赫夫曼编码是赫哈夫曼树在电讯通信中的经典的应用之</li>
<li>赫夫曼编码广泛地用于数据文件压缩。其压缩率通常在20%~90%之间</li>
<li>赫夫曼码是可变字长编码(ⅥC的一种。 Huffman-于1952年提出一种编码方法,称之为最佳编码</li>
<li>注意,这个赫夫曼树根据排序方法不同,也可能不太一样,这样对应的赫夫曼编码也不完全样,但是wpl是
样的,都是最小的最后生成的赫夫曼编码的长度是一样如:如果我们让每次生成的新的二又树总是排在权值
相同的二叉树的最后一个,则生成的二叉树为</li>
</ol>
<h5 id="赫夫曼解码">赫夫曼解码</h5>
<h2 id="二叉排序树">二叉排序树</h2>
<p>既可以保证数据的检索速度,同时也以保证数据的插入,删除,修改的速度</p>
<p><strong>二叉排序树</strong>:<strong>BST:( Binary Sort(Search)Tree)</strong>,对于二叉排序树的任何一个非叶子节点,要求左子节点的值比当前节点的值小,右子节点的值比当前节点的值大。(左&lt;当前&lt;右 )
<strong>特别说明</strong>:如果有相同的值,可以将该节点放在左子节点或右子节点</p>
<h3 id="二叉排序树的删除">二叉排序树的删除</h3>
<p>注意</p>
<ol>
<li>只有没有子结点</li>
<li>1个子节点</li>
<li>2个子节点</li>
</ol>
<h2 id="平衡二叉树avl树">平衡二叉树(AVL树)</h2>
<p>左边BST存在的问题分析</p>
<ol>
<li>左子树全部为空,从形式上看,更像一个单链表</li>
<li>插入速度没有影响</li>
<li>查询速度明显降低(因为需要次比较)不能发挥BST的优势,因为每次还需要比较左子树,其查询速度比单链表还慢</li>
<li>解决方案平衡二叉树(AVL)</li>
</ol>
<h4 id="基本介绍">基本介绍</h4>
<ol>
<li>平衡二叉树也叫<strong>平衡二叉搜索树</strong>( Self-balancing binary search tree)又被称为AVL树,可以保证查询效率较高</li>
<li>具有以下特点:它是一棵空树或它的左右两个子树的高度差的绝对值不超过1,并且左右两个子树都是一棵平衡二叉树。平衡二叉树的常用实现方法有红黑树AⅥ、替罪羊树、 Treap、伸展树等</li>
</ol>
<p>左旋转,右旋转,双旋转</p>
<p><figure 
	>
	<a href="https://cdn.jsdelivr.net/gh/damaicao/damaicao-img/blog-imgs/202201102038907.png" >
		<img src="https://cdn.jsdelivr.net/gh/damaicao/damaicao-img/blog-imgs/202201102038907.png"
			
			
			
			loading="lazy"
			alt="img">
	</a>
	
	<figcaption>img</figcaption>
	
</figure></p>
<h2 id="多路查找树">多路查找树</h2>
<h3 id="多叉树">多叉树</h3>
<ol>
<li>在二叉树中，每个节点有数据项，最多有两个子节点。如果<strong>允许每个节点可以有更多的数据项和更多的子节点</strong>，就是<code>多叉树(multiway tree)</code></li>
<li>2-3-4树就是多叉树，多叉树通过重新组织节点，减少树的高度，能对二叉树进行优化。</li>
</ol>
<h3 id="b树">B树</h3>
<p>B树通过重新组织节点，降低树的高度，并且减少i/o读写次数来提升效率。</p>
<ol>
<li>如图B树通过<strong>重新组织节点，隆低了树的高度</strong></li>
<li>文件系统及数据库系统的设计者利用了<strong>磁盘预读</strong>原理，将一个节点的大小设为等于一个页(页得大小通常为4k)，这样每个节点只需要一次l/o就可以完全载入</li>
<li>将树的度M设置为1024，在600亿个元素中最多只需要4次I/o操作就可以读取到想要的元素,B树()广泛应用于文件存储系统以及数据库系统中</li>
</ol>
<p>结点度:连接这节点的路的条数</p>
<p>树的度:就是某个结点的子节点数最多的那个数值</p>
<h3 id="2-3树">2-3树</h3>
<p>最简单的B树</p>
<p><strong>特点</strong></p>
<ol>
<li>2-3树的所有叶子节点都在同一层.(只要是B树都满足这个条件)</li>
<li>有两个子节点的节点叫二节点，二节点要么没有子节点，要么有两个子节点.</li>
<li>有三个子节点的节点叫三节点，三节点要么没有子节点，要么有三个子节点.2-3树是由二节点和三节点构成的树。</li>
<li>二节点有两个节点且仅有一个数据项，三节点三个结点有且仅有两个数据项</li>
</ol>
<p><strong>插入规则</strong></p>
<ol>
<li>2-3树的<strong>所有叶子节点都在同一层</strong>.(只要是B树都满足这个条件)</li>
<li>有两个子节点的节点叫二节点,二节点要么没有子节点,要么有两个子节点.</li>
<li>有三个子节点的节点叫三节点,三节点要么没有子节点,要么有三个子节点</li>
<li><strong>当按照规则插入一个数到某个节点时,不能满足上面三个要求,就需要拆，先向上拆,，如果上层满,则拆本层，拆后仍然需要满足上面3个条件。</strong></li>
<li>对于三节点的子树的值大小仍然遵守(BST二叉排序树)的规则</li>
</ol>
<h2 id="b树b树和b树">B树,B+树和B*树</h2>
<p>B-tree树即B树，B即Balanced，平衡的意思。有人把B-tree翻译成B-树，容易让人产生误解。会以为B-树是一种树，而B树又是另一种树。实际上，B-tree就是指的B树。</p>
<h3 id="b树说明">B树说明</h3>
<ol>
<li>B树的阶:节点的最多子节点个数。比如2-3树的阶是3，2-3-4树的阶是4</li>
<li>B-树的搜索，从根结点开始，对结点内的关键字(有序)序列进行二分查找,如果命中则结束，否则进入查询关键字所属范围的儿子结点;重复,直到所对应的儿子指针为空，或已经是叶子结点</li>
<li>关键字集合分布在整颗树中，即叶子节点和非叶子节点都存放数据</li>
<li>搜索有可能在非叶子结点结束</li>
<li>其搜索性能等价于在关键字全集内做一次二分查找</li>
</ol>
<p><figure 
	>
	<a href="https://www.yiibai.com/uploads/images/2018/11/12/085347_39239.png" >
		<img src="https://www.yiibai.com/uploads/images/2018/11/12/085347_39239.png"
			
			
			
			loading="lazy"
			alt="img">
	</a>
	
	<figcaption>img</figcaption>
	
</figure></p>
<h3 id="b树说明-1">B+树说明</h3>
<p>多路搜索树</p>
<ol>
<li>B+树的搜索与B树也基本相同，区别是B+树只有达到叶子结点才命中〈B树可以在非叶子结点命中)，其性能也等价于在关键字全集做一次二分查找</li>
<li>所有<strong>关键字都出现在叶子结点的链表中</strong>（即数据只能在叶子节点【也叫稠密索引】)，且链表中的关键字(数据)恰好是有序的。</li>
<li>不可能在非叶子结点命中</li>
<li>非叶子结点相当于是叶子结点的索引(稀疏索引)叶子结点相当于是存储(关键字)数据的数据层</li>
<li>更适合文件索引系统</li>
<li>B权对和B+树各有自己的应用场景，不能说B+树完全比B树好，反之亦然.</li>
</ol>
<p><figure 
	>
	<a href="https://cdn.jsdelivr.net/gh/damaicao/damaicao-img/blog-imgs/202201102037509.png" >
		<img src="https://cdn.jsdelivr.net/gh/damaicao/damaicao-img/blog-imgs/202201102037509.png"
			
			
			
			loading="lazy"
			alt="img">
	</a>
	
	<figcaption>img</figcaption>
	
</figure></p>
<h3 id="b树说明-2">B*树说明</h3>
<p>B*树是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针。</p>
<ol>
<li><em>B</em>树定义了非叶子结点关键字个数至少为(2/3)*M，即块的最低使用率为2/3，而B+树的块的最低使用率为B+树的1/2。</li>
<li>第1个特点我们可以看出，B*树分配新结点的概率比B+树要低，空间使用率更高<figure 
	>
	<a href="https://cdn.jsdelivr.net/gh/damaicao/damaicao-img/blog-imgs/202201102042819.png" >
		<img src="https://cdn.jsdelivr.net/gh/damaicao/damaicao-img/blog-imgs/202201102042819.png"
			
			
			
			loading="lazy"
			alt="在这里插入图片描述">
	</a>
	
	<figcaption>在这里插入图片描述</figcaption>
	
</figure></li>
</ol>

</section>


    <footer class="article-footer">
    
    <section class="article-tags">
        
            <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>
        
    </section>


    
    <section class="article-copyright">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M14.5 9a3.5 4 0 1 0 0 6" />
</svg>



        <span>Licensed under CC BY-NC-SA 4.0</span>
    </section>
    </footer>


    
</article>

    <aside class="related-contents--wrapper">
    
    
        <h2 class="section-title">相关文章</h2>
        <div class="related-contents">
            <div class="flex article-list--tile">
                
                    
<article class="has-image">
    <a href="/post/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/">
        
        
            <div class="article-image">
                
                    <img src="https://cdn.jsdelivr.net/gh/damaicao/damaicao-img/blog-imgs/202112010835587.webp" loading="lazy" data-key="" data-hash="https://cdn.jsdelivr.net/gh/damaicao/damaicao-img/blog-imgs/202112010835587.webp"/>
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">Day02</h2>
        </div>
    </a>
</article>
                
                    
<article class="has-image">
    <a href="/post/%E7%AE%97%E6%B3%95%E9%97%AE%E9%A2%98/">
        
        
            <div class="article-image">
                
                    <img src="/image/%e5%85%83%e6%97%a6%e8%b4%ba%e5%9b%be.png" loading="lazy" data-key="" data-hash="/image/元旦贺图.png"/>
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">算法问题</h2>
        </div>
    </a>
</article>
                
                    
<article class="has-image">
    <a href="/post/%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84/">
        
        
            <div class="article-image">
                
                    <img src="/image/%e5%85%83%e6%97%a6%e8%b4%ba%e5%9b%be.png" loading="lazy" data-key="" data-hash="/image/元旦贺图.png"/>
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">线性结构</h2>
        </div>
    </a>
</article>
                
            </div>
        </div>
    
</aside>

     
    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
            2021 - 
        
        2022 Damaicao的博客
    </section>
    
    <section class="powerby">
        Built with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> <br />
        Theme <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="3.5.0">Stack</a></b> designed by <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a>
    </section>
</footer>


    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer="true"
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer="true"
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css"integrity="sha256-c0uckgykQ9v5k&#43;IqViZOZKc47Jn7KQil4/MP3ySA3F8="crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css"integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE="crossorigin="anonymous"
            >

            </main>
    
        <aside class="sidebar right-sidebar sticky">
            <section class="widget archives">
                <div class="widget-icon">
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <line x1="5" y1="9" x2="19" y2="9" />
  <line x1="5" y1="15" x2="19" y2="15" />
  <line x1="11" y1="4" x2="7" y2="20" />
  <line x1="17" y1="4" x2="13" y2="20" />
</svg>



                </div>
                <h2 class="widget-title section-title">目录</h2>
                
                <div class="widget--toc">
                    <nav id="TableOfContents">
  <ul>
    <li><a href="#数组存储方式的分析"><strong>数组存储方式的分析</strong></a></li>
    <li><a href="#链式存储方式的分析"><strong>链式存储方式的分析</strong></a></li>
    <li><a href="#树存储方式的分析"><strong>树存储方式的分析</strong></a></li>
    <li><a href="#树的常用术语结合示意图理解">树的常用术语(结合示意图理解)</a></li>
    <li><a href="#二叉树">二叉树</a>
      <ul>
        <li><a href="#概念">概念</a></li>
        <li><a href="#遍历">遍历</a></li>
        <li><a href="#查找">查找</a></li>
        <li><a href="#删除">删除</a></li>
      </ul>
    </li>
    <li><a href="#顺序存储二叉树">顺序存储二叉树</a>
      <ul>
        <li><a href="#线索化二叉树">线索化二叉树</a></li>
      </ul>
    </li>
    <li><a href="#赫夫曼树">赫夫曼树</a>
      <ul>
        <li></li>
      </ul>
    </li>
    <li><a href="#二叉排序树">二叉排序树</a>
      <ul>
        <li><a href="#二叉排序树的删除">二叉排序树的删除</a></li>
      </ul>
    </li>
    <li><a href="#平衡二叉树avl树">平衡二叉树(AVL树)</a>
      <ul>
        <li></li>
      </ul>
    </li>
    <li><a href="#多路查找树">多路查找树</a>
      <ul>
        <li><a href="#多叉树">多叉树</a></li>
        <li><a href="#b树">B树</a></li>
        <li><a href="#2-3树">2-3树</a></li>
      </ul>
    </li>
    <li><a href="#b树b树和b树">B树,B+树和B*树</a>
      <ul>
        <li><a href="#b树说明">B树说明</a></li>
        <li><a href="#b树说明-1">B+树说明</a></li>
        <li><a href="#b树说明-2">B*树说明</a></li>
      </ul>
    </li>
  </ul>
</nav>
                </div>
            </section>
        </aside>
    

        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js"integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g="crossorigin="anonymous"
                defer="false"
                >
            </script><script type="text/javascript" src="/ts/main.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>

    </body>
</html>
