<!DOCTYPE html>
<html lang="zh-cn">
    <head><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content='算法 二分查找  二分查找法只适用于从有序的数列中进行查找(比如数字和字母等)，将数列排序后再进行查找 二分查找法的运行时间为对数时间o(log2n)，即查找到需要的目标位置最多只需要log2n步，假设从[0,99]的队列(100个数，即n=100)中寻到目标数30，则需要查找步数为log2100，即最多需要查找7次(2^6&amp;lt;100 &amp;lt;2^7)  int left = 0; int right = arr.length - 1; while(left &amp;lt;= right){ int mid = (left &#43; right) / 2; if (arr[mid] == target){ return arr[mid]; } else if (arr[mid] &amp;gt; target){ right = mid - 1; } else{ left = mid &#43; 1; } } return -1; 分治算法   分治法是一种很重要的算法。字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题&amp;hellip;.直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。这个技巧是很多高效算法的基础，如排序算法(快速排序，归并排序)，傅立叶变换(快速傅立叶变换)&amp;hellip;.
  分治算法可以求解的一些经典问题
 二分搜索 大整数乘法 棋盘覆盖 合并排序 快速排序 线性时间选择 最接近点对问题 循环赛日程表 汉诺塔    基本步骤'><title>十大算法</title>

<link rel='canonical' href='https://damaicao.github.io/post/%E5%8D%81%E5%A4%A7%E7%AE%97%E6%B3%95/'>

<link rel="stylesheet" href="/scss/style.min.css"><meta property='og:title' content='十大算法'>
<meta property='og:description' content='算法 二分查找  二分查找法只适用于从有序的数列中进行查找(比如数字和字母等)，将数列排序后再进行查找 二分查找法的运行时间为对数时间o(log2n)，即查找到需要的目标位置最多只需要log2n步，假设从[0,99]的队列(100个数，即n=100)中寻到目标数30，则需要查找步数为log2100，即最多需要查找7次(2^6&amp;lt;100 &amp;lt;2^7)  int left = 0; int right = arr.length - 1; while(left &amp;lt;= right){ int mid = (left &#43; right) / 2; if (arr[mid] == target){ return arr[mid]; } else if (arr[mid] &amp;gt; target){ right = mid - 1; } else{ left = mid &#43; 1; } } return -1; 分治算法   分治法是一种很重要的算法。字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题&amp;hellip;.直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。这个技巧是很多高效算法的基础，如排序算法(快速排序，归并排序)，傅立叶变换(快速傅立叶变换)&amp;hellip;.
  分治算法可以求解的一些经典问题
 二分搜索 大整数乘法 棋盘覆盖 合并排序 快速排序 线性时间选择 最接近点对问题 循环赛日程表 汉诺塔    基本步骤'>
<meta property='og:url' content='https://damaicao.github.io/post/%E5%8D%81%E5%A4%A7%E7%AE%97%E6%B3%95/'>
<meta property='og:site_name' content='Damaicao的博客'>
<meta property='og:type' content='article'><meta property='article:section' content='Post' /><meta property='article:tag' content='算法' /><meta property='article:published_time' content='2022-01-11T23:02:23&#43;08:00'/><meta property='article:modified_time' content='2022-01-11T23:02:23&#43;08:00'/>
<meta name="twitter:title" content="十大算法">
<meta name="twitter:description" content="算法 二分查找  二分查找法只适用于从有序的数列中进行查找(比如数字和字母等)，将数列排序后再进行查找 二分查找法的运行时间为对数时间o(log2n)，即查找到需要的目标位置最多只需要log2n步，假设从[0,99]的队列(100个数，即n=100)中寻到目标数30，则需要查找步数为log2100，即最多需要查找7次(2^6&amp;lt;100 &amp;lt;2^7)  int left = 0; int right = arr.length - 1; while(left &amp;lt;= right){ int mid = (left &#43; right) / 2; if (arr[mid] == target){ return arr[mid]; } else if (arr[mid] &amp;gt; target){ right = mid - 1; } else{ left = mid &#43; 1; } } return -1; 分治算法   分治法是一种很重要的算法。字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题&amp;hellip;.直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。这个技巧是很多高效算法的基础，如排序算法(快速排序，归并排序)，傅立叶变换(快速傅立叶变换)&amp;hellip;.
  分治算法可以求解的一些经典问题
 二分搜索 大整数乘法 棋盘覆盖 合并排序 快速排序 线性时间选择 最接近点对问题 循环赛日程表 汉诺塔    基本步骤">
    <link rel="shortcut icon" href="img/favicon.ico" />

    </head>
    <body class="
    article-page has-toc
">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex 
    
        extended
    
">
    
        <div id="article-toolbar">
            <a href="/" class="back-home">
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-chevron-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="15 6 9 12 15 18" />
</svg>



                <span>返回</span>
            </a>
        </div>
    
<main class="main full-width">
    <article class="main-article">
    <header class="article-header">

    <div class="article-details">
    
    <header class="article-category">
        
            <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" >
                数据结构
            </a>
        
    </header>
    

    <h2 class="article-title">
        <a href="/post/%E5%8D%81%E5%A4%A7%E7%AE%97%E6%B3%95/">十大算法</a>
    </h2>

    

    
    <footer class="article-time">
        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4" />
  <circle cx="18" cy="18" r="4" />
  <path d="M15 3v4" />
  <path d="M7 3v4" />
  <path d="M3 11h16" />
  <path d="M18 16.496v1.504l1 1" />
</svg>
                <time class="article-time--published">Jan 11, 2022</time>
            </div>
        

        
    </footer>
    
</div>
</header>

    <section class="article-content">
    <h1 id="算法">算法</h1>
<h2 id="二分查找">二分查找</h2>
<ol>
<li>二分查找法只适用于从有序的数列中进行查找(比如数字和字母等)，将数列排序后再进行查找</li>
<li>二分查找法的运行时间为对数时间o(log2n)，即查找到需要的目标位置最多只需要log2n步，假设从[0,99]的队列(100个数，即n=100)中寻到目标数30，则需要查找步数为log2100，即最多需要查找7次(2^6&lt;100 &lt;2^7)</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">int</span> left <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">int</span> right <span style="color:#f92672">=</span> arr<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span> <span style="color:#f92672">-</span> 1<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">while</span><span style="color:#f92672">(</span>left <span style="color:#f92672">&lt;=</span> right<span style="color:#f92672">){</span>
            <span style="color:#66d9ef">int</span> mid <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>left <span style="color:#f92672">+</span> right<span style="color:#f92672">)</span> <span style="color:#f92672">/</span> 2<span style="color:#f92672">;</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>arr<span style="color:#f92672">[</span>mid<span style="color:#f92672">]</span> <span style="color:#f92672">==</span> target<span style="color:#f92672">){</span>
                <span style="color:#66d9ef">return</span> arr<span style="color:#f92672">[</span>mid<span style="color:#f92672">];</span>
            <span style="color:#f92672">}</span>
            <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>arr<span style="color:#f92672">[</span>mid<span style="color:#f92672">]</span> <span style="color:#f92672">&gt;</span> target<span style="color:#f92672">){</span>
                right <span style="color:#f92672">=</span> mid <span style="color:#f92672">-</span> 1<span style="color:#f92672">;</span>
            <span style="color:#f92672">}</span>
            <span style="color:#66d9ef">else</span><span style="color:#f92672">{</span>
                left <span style="color:#f92672">=</span> mid <span style="color:#f92672">+</span> 1<span style="color:#f92672">;</span>
            <span style="color:#f92672">}</span>
        <span style="color:#f92672">}</span>
        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>1<span style="color:#f92672">;</span>
</code></pre></div><h2 id="分治算法">分治算法</h2>
<ol>
<li>
<p>分治法是一种很重要的算法。字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题&hellip;.直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。这个技巧是很多高效算法的基础，如排序算法(快速排序，归并排序)，傅立叶变换(快速傅立叶变换)&hellip;.</p>
</li>
<li>
<p>分治算法可以求解的一些经典问题</p>
<ol>
<li>二分搜索</li>
<li>大整数乘法</li>
<li>棋盘覆盖</li>
<li>合并排序</li>
<li>快速排序</li>
<li>线性时间选择</li>
<li>最接近点对问题</li>
<li>循环赛日程表</li>
<li>汉诺塔</li>
</ol>
</li>
<li>
<p>基本步骤</p>
<ol>
<li>分解:将原问题分解为若千个规模较小，相互独立，与原问题形式相同的子问题</li>
<li>解决:若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题</li>
<li>合并:将各个子问题的解合并为原问题的解。</li>
</ol>
</li>
<li>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">hanoitower</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> num<span style="color:#f92672">,</span> <span style="color:#66d9ef">char</span> a<span style="color:#f92672">,</span> <span style="color:#66d9ef">char</span> b<span style="color:#f92672">,</span> <span style="color:#66d9ef">char</span> c<span style="color:#f92672">){</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>num <span style="color:#f92672">==</span> 1<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;第一个盘&#34;</span> <span style="color:#f92672">+</span> a <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;-&gt;&#34;</span> <span style="color:#f92672">+</span> c<span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span>
        <span style="color:#66d9ef">else</span><span style="color:#f92672">{</span>
            hanoitower<span style="color:#f92672">(</span>num <span style="color:#f92672">-</span> 1<span style="color:#f92672">,</span> a<span style="color:#f92672">,</span> c<span style="color:#f92672">,</span> b<span style="color:#f92672">);</span>
            System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;第&#34;</span> <span style="color:#f92672">+</span> num <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;个盘从&#34;</span> <span style="color:#f92672">+</span> a <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;-&gt;&#34;</span> <span style="color:#f92672">+</span> c<span style="color:#f92672">);</span>
            hanoitower<span style="color:#f92672">(</span>num <span style="color:#f92672">-</span> 1<span style="color:#f92672">,</span> b<span style="color:#f92672">,</span> a<span style="color:#f92672">,</span> c<span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
</code></pre></div></li>
</ol>
<h2 id="动态规划">动态规划</h2>
<ol>
<li>介绍
<ol>
<li>**动态规划(Dynamic Programming)**算法的核心思想是:<strong>将大问题划分为小问题进行解决，从而一步步获取最优解的处理算法</strong></li>
<li>动态规划算法与分治算法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。</li>
<li>与分治法不同的是，<strong>适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的</strong>。(即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解)</li>
<li>动态规划可以通过填表的方式来逐步推进，得到最优解.</li>
</ol>
</li>
<li>性质
<ol>
<li><strong>最优化原理</strong>：假设问题的最优解所包括的子问题的解也是最优的，就称该问题具有最优子结构，即满足最优化原理。</li>
<li><strong>无后效性</strong>：即某阶段状态一旦确定。就不受这个状态以后决策的影响。也就是说，某状态以后的过程不会影响曾经的状态。仅仅与当前状态有关；</li>
<li><strong>有重叠子问题</strong>：即子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到（该性质并非动态规划适用的必要条件，可是假设没有这条性质。动态规划算法同其它算法相比就不具备优势）。</li>
</ol>
</li>
<li>算法的主要思想，利用动态规划来解决。每次遍历到的第i个物品，根据w[i]和v[i]来确定是否需要将该物品放入背包中。即对于给定的n个物品，设v[i]、w[i]分别为第i个物品的价值和重量，c为背包的容量。再令<code>v[i][j]</code>表示在前i个物品中能够装入容量为的背包中的最大价值。</li>
<li></li>
</ol>
<h2 id="kmp算法">KMP算法</h2>
<ol>
<li>介绍
<ol>
<li><code>KMP</code>是一个解决模式串在文本串是否出现过，如果出现过，最早出现的位置的经典算法</li>
<li>Knuth-Morris-Pratt字符串查找算法，简称为“<code>KMP算法</code>”，常用于在一个文本串S内查找一个模式串P的出现位置，这个算法由Donald Knuth、Vaughan Pratt. James H. Morris三人于1977年联合发表，故取这3人的姓氏命名此算法.</li>
<li><code>KMP</code>方法算法就利用之前判断过信息，通过一个next数组，保存模式串中前后最长公共子序列的长度，每次回溯时，通过next数组找到，前面匹配过的位置，省去了大量的计算时间</li>
</ol>
</li>
</ol>
<h2 id="贪心算法">贪心算法</h2>
<h2 id="普里姆算法">普里姆算法</h2>
<p><strong>最小生成树</strong>:给定一个带权的无向连通图,如何选取一棵生成树,使树上所有边上权的总和为最小</p>
<ol>
<li>N个顶点，—定有N-1条边</li>
<li>包含全部顶点</li>
<li>N-1条边都在图中</li>
<li>求最小生成树的算法主要是<strong>普里姆算法</strong>和克鲁斯卡尔算法</li>
<li>普利姆(Prim)算法求最小生成树，也就是在包含n个顶点的连通图中，找出只有(n-1)条边包含所有n个顶点的连通子图，也就是所谓的极小连通子图</li>
</ol>
<h2 id="克鲁斯卡尔算法">克鲁斯卡尔算法</h2>
<ol>
<li>克鲁斯卡尔(<code>Kruskal</code>)算法，是用来求加权连通图的最小生成树的算法。</li>
<li>基本思想:按照权值从小到天的顺序选择n-1条边，并保证这n-1条边不构成回路</li>
<li>具体做法:首先构造一个只含n个顶点的森林，然后依权值从小到大从连通网中选择边加入到森林中，并使森林中不产生回路，直至森林变成一棵树为止</li>
</ol>
<h2 id="迪杰斯算法">迪杰斯算法</h2>
<p>迪杰斯特拉(Dijkstra)算法是典型<strong>最短路径算法</strong>，用于计算一个结点到其他结点的最短路径。</p>
<p>它的主要特点是以起始点为<strong>中心向外层层扩展(广度优先搜索思想)</strong>，直到扩展到终点为止。</p>
<h2 id="弗洛伊德算法">弗洛伊德算法</h2>
<ol>
<li>弗洛伊德算法(Floyd)计算图中各个顶点之间的最短路径</li>
<li>迪杰斯特拉算法用于计算图中某一个顶点到其他顶点的最短路径。</li>
<li><strong>弗洛伊德算法</strong>VS<strong>迪杰斯特拉算法</strong>:
<ol>
<li>迪杰斯特拉算法通过选定的被访问顶点，求出从出发访问顶点到其他顶点的最短路径;</li>
<li>弗洛伊德算法中每一个顶点都是出发访问点，所以需要将每一个顶点看做被访问顶点，求出从每一个顶点到其他顶点的最短路径。</li>
</ol>
</li>
</ol>
<h2 id="骑士周游">骑士周游</h2>
<ol>
<li>创建棋盘<code>chessBoa	rd</code> ,是一个二维数组</li>
<li>将当前位置设置为已经访问，然后根据当前位置，计算马儿还能走哪些位置，并放入到一个集合中(<code>ArrayList</code>),最多有8个位置，每走一步，就使用step+1</li>
<li>遍历<code>ArrayList</code>中存放的所有位置，看看哪个可以走通,如果走通，就继续，走不通，就回溯.</li>
<li>判断马儿是否完成了任务，使用step和应该走的步数比较，如果没有达到数量，则表示没有完成任务，将整个棋盘置o</li>
<li>注意:马儿不同的走法[(策略），会得到不同的结果，效率也会有影响(优化)</li>
</ol>

</section>


    <footer class="article-footer">
    
    <section class="article-tags">
        
            <a href="/tags/%E7%AE%97%E6%B3%95/">算法</a>
        
    </section>


    
    <section class="article-copyright">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M14.5 9a3.5 4 0 1 0 0 6" />
</svg>



        <span>Licensed under CC BY-NC-SA 4.0</span>
    </section>
    </footer>


    
</article>

    <aside class="related-contents--wrapper">
    
    
        <h2 class="section-title">相关文章</h2>
        <div class="related-contents">
            <div class="flex article-list--tile">
                
                    
<article class="">
    <a href="/post/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/">
        
        

        <div class="article-details">
            <h2 class="article-title">查找算法</h2>
        </div>
    </a>
</article>
                
            </div>
        </div>
    
</aside>

     
    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
            2021 - 
        
        2022 Damaicao的博客
    </section>
    
    <section class="powerby">
        Built with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> <br />
        Theme <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="3.5.0">Stack</a></b> designed by <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a>
    </section>
</footer>


    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer="true"
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer="true"
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css"integrity="sha256-c0uckgykQ9v5k&#43;IqViZOZKc47Jn7KQil4/MP3ySA3F8="crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css"integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE="crossorigin="anonymous"
            >

            </main>
    
        <aside class="sidebar right-sidebar sticky">
            <section class="widget archives">
                <div class="widget-icon">
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <line x1="5" y1="9" x2="19" y2="9" />
  <line x1="5" y1="15" x2="19" y2="15" />
  <line x1="11" y1="4" x2="7" y2="20" />
  <line x1="17" y1="4" x2="13" y2="20" />
</svg>



                </div>
                <h2 class="widget-title section-title">目录</h2>
                
                <div class="widget--toc">
                    <nav id="TableOfContents">
  <ul>
    <li><a href="#二分查找">二分查找</a></li>
    <li><a href="#分治算法">分治算法</a></li>
    <li><a href="#动态规划">动态规划</a></li>
    <li><a href="#kmp算法">KMP算法</a></li>
    <li><a href="#贪心算法">贪心算法</a></li>
    <li><a href="#普里姆算法">普里姆算法</a></li>
    <li><a href="#克鲁斯卡尔算法">克鲁斯卡尔算法</a></li>
    <li><a href="#迪杰斯算法">迪杰斯算法</a></li>
    <li><a href="#弗洛伊德算法">弗洛伊德算法</a></li>
    <li><a href="#骑士周游">骑士周游</a></li>
  </ul>
</nav>
                </div>
            </section>
        </aside>
    

        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js"integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g="crossorigin="anonymous"
                defer="false"
                >
            </script><script type="text/javascript" src="/ts/main.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>

    </body>
</html>
